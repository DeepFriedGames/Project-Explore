# compiler: R8
# compiler_version: 1.5.69
# min_api: 16
# pg_map_id: 3a1e4ea
android.arch.core.internal.FastSafeIterableMap -> a.a.a.a.a:
    java.util.HashMap mHashMap -> e
android.arch.core.internal.SafeIterableMap -> a.a.a.a.b:
    int mSize -> d
    java.util.WeakHashMap mIterators -> c
    android.arch.core.internal.SafeIterableMap$Entry mStart -> a
    android.arch.core.internal.SafeIterableMap$Entry mEnd -> b
    android.arch.core.internal.SafeIterableMap$Entry access$100(android.arch.core.internal.SafeIterableMap) -> a
    java.util.Iterator descendingIterator() -> a
    java.util.Map$Entry eldest() -> b
    android.arch.core.internal.SafeIterableMap$IteratorWithAdditions iteratorWithAdditions() -> c
    java.util.Map$Entry newest() -> d
android.arch.core.internal.SafeIterableMap$1 -> a.a.a.a.b$a:
android.arch.core.internal.SafeIterableMap$AscendingIterator -> a.a.a.a.b$b:
    android.arch.core.internal.SafeIterableMap$Entry forward(android.arch.core.internal.SafeIterableMap$Entry) -> a
android.arch.core.internal.SafeIterableMap$DescendingIterator -> a.a.a.a.b$c:
    android.arch.core.internal.SafeIterableMap$Entry forward(android.arch.core.internal.SafeIterableMap$Entry) -> a
android.arch.core.internal.SafeIterableMap$Entry -> a.a.a.a.b$d:
    android.arch.core.internal.SafeIterableMap$Entry mNext -> a
    android.arch.core.internal.SafeIterableMap$Entry mPrevious -> b
android.arch.core.internal.SafeIterableMap$IteratorWithAdditions -> a.a.a.a.b$e:
    android.arch.core.internal.SafeIterableMap this$0 -> c
    boolean mBeforeStart -> b
    android.arch.core.internal.SafeIterableMap$Entry mCurrent -> a
android.arch.core.internal.SafeIterableMap$ListIterator -> a.a.a.a.b$f:
    android.arch.core.internal.SafeIterableMap$Entry mExpectedEnd -> a
    android.arch.core.internal.SafeIterableMap$Entry mNext -> b
    android.arch.core.internal.SafeIterableMap$Entry forward(android.arch.core.internal.SafeIterableMap$Entry) -> a
    android.arch.core.internal.SafeIterableMap$Entry nextNode() -> a
android.arch.core.internal.SafeIterableMap$SupportRemove -> a.a.a.a.b$g:
android.arch.lifecycle.GenericLifecycleObserver -> android.arch.lifecycle.GenericLifecycleObserver:
    void onStateChanged(android.arch.lifecycle.LifecycleOwner,android.arch.lifecycle.Lifecycle$Event) -> a
android.arch.lifecycle.Lifecycle -> android.arch.lifecycle.a:
android.arch.lifecycle.Lifecycle$Event -> android.arch.lifecycle.a$a:
android.arch.lifecycle.Lifecycle$State -> android.arch.lifecycle.a$b:
    android.arch.lifecycle.Lifecycle$State DESTROYED -> a
    android.arch.lifecycle.Lifecycle$State INITIALIZED -> b
    android.arch.lifecycle.Lifecycle$State CREATED -> c
    android.arch.lifecycle.Lifecycle$State STARTED -> d
    android.arch.lifecycle.Lifecycle$State[] $VALUES -> f
    android.arch.lifecycle.Lifecycle$State RESUMED -> e
android.arch.lifecycle.LifecycleObserver -> android.arch.lifecycle.b:
android.arch.lifecycle.LifecycleOwner -> android.arch.lifecycle.c:
    android.arch.lifecycle.Lifecycle getLifecycle() -> a
android.arch.lifecycle.LifecycleRegistry -> android.arch.lifecycle.d:
    android.arch.core.internal.FastSafeIterableMap mObserverMap -> a
    android.arch.lifecycle.Lifecycle$State mState -> b
    android.arch.lifecycle.LifecycleOwner mLifecycleOwner -> c
    boolean mHandlingEvent -> e
    java.util.ArrayList mParentStates -> g
    boolean mNewEventOccurred -> f
    int mAddingObserverCounter -> d
    void backwardPass() -> a
    void handleLifecycleEvent(android.arch.lifecycle.Lifecycle$Event) -> a
    void markState(android.arch.lifecycle.Lifecycle$State) -> a
    android.arch.lifecycle.Lifecycle$State min(android.arch.lifecycle.Lifecycle$State,android.arch.lifecycle.Lifecycle$State) -> a
    android.arch.lifecycle.Lifecycle$Event downEvent(android.arch.lifecycle.Lifecycle$State) -> b
    void forwardPass() -> b
    android.arch.lifecycle.Lifecycle$State getStateAfter(android.arch.lifecycle.Lifecycle$Event) -> b
    boolean isSynced() -> c
    void pushParentState(android.arch.lifecycle.Lifecycle$State) -> c
    void popParentState() -> d
    android.arch.lifecycle.Lifecycle$Event upEvent(android.arch.lifecycle.Lifecycle$State) -> d
    void sync() -> e
android.arch.lifecycle.LifecycleRegistry$1 -> android.arch.lifecycle.d$a:
    int[] $SwitchMap$android$arch$lifecycle$Lifecycle$State -> b
    int[] $SwitchMap$android$arch$lifecycle$Lifecycle$Event -> a
android.arch.lifecycle.LifecycleRegistry$ObserverWithState -> android.arch.lifecycle.d$b:
    android.arch.lifecycle.Lifecycle$State mState -> a
    android.arch.lifecycle.GenericLifecycleObserver mLifecycleObserver -> b
    void dispatchEvent(android.arch.lifecycle.LifecycleOwner,android.arch.lifecycle.Lifecycle$Event) -> a
android.arch.lifecycle.LifecycleRegistryOwner -> android.arch.lifecycle.e:
    android.arch.lifecycle.LifecycleRegistry getLifecycle() -> a
android.arch.lifecycle.OnLifecycleEvent -> android.arch.lifecycle.f:
android.arch.lifecycle.ReflectiveGenericLifecycleObserver -> android.arch.lifecycle.ReflectiveGenericLifecycleObserver:
    android.arch.lifecycle.ReflectiveGenericLifecycleObserver$CallbackInfo mInfo -> b
    java.util.Map sInfoCache -> c
    java.lang.Object mWrapped -> a
    android.arch.lifecycle.ReflectiveGenericLifecycleObserver$CallbackInfo createInfo(java.lang.Class) -> a
    void invokeCallback(android.arch.lifecycle.ReflectiveGenericLifecycleObserver$MethodReference,android.arch.lifecycle.LifecycleOwner,android.arch.lifecycle.Lifecycle$Event) -> a
    void invokeCallbacks(android.arch.lifecycle.ReflectiveGenericLifecycleObserver$CallbackInfo,android.arch.lifecycle.LifecycleOwner,android.arch.lifecycle.Lifecycle$Event) -> a
    void invokeMethodsForEvent(java.util.List,android.arch.lifecycle.LifecycleOwner,android.arch.lifecycle.Lifecycle$Event) -> a
    void onStateChanged(android.arch.lifecycle.LifecycleOwner,android.arch.lifecycle.Lifecycle$Event) -> a
    void verifyAndPutHandler(java.util.Map,android.arch.lifecycle.ReflectiveGenericLifecycleObserver$MethodReference,android.arch.lifecycle.Lifecycle$Event,java.lang.Class) -> a
    android.arch.lifecycle.ReflectiveGenericLifecycleObserver$CallbackInfo getInfo(java.lang.Class) -> b
android.arch.lifecycle.ReflectiveGenericLifecycleObserver$CallbackInfo -> android.arch.lifecycle.ReflectiveGenericLifecycleObserver$a:
    java.util.Map mEventToHandlers -> a
    java.util.Map mHandlerToEvent -> b
android.arch.lifecycle.ReflectiveGenericLifecycleObserver$MethodReference -> android.arch.lifecycle.ReflectiveGenericLifecycleObserver$b:
    int mCallType -> a
    java.lang.reflect.Method mMethod -> b
android.arch.lifecycle.ReportFragment -> android.arch.lifecycle.g:
    android.arch.lifecycle.ReportFragment$ActivityInitializationListener mProcessListener -> a
    void dispatch(android.arch.lifecycle.Lifecycle$Event) -> a
    void dispatchCreate(android.arch.lifecycle.ReportFragment$ActivityInitializationListener) -> a
    void injectIfNeededIn(android.app.Activity) -> a
    void dispatchResume(android.arch.lifecycle.ReportFragment$ActivityInitializationListener) -> b
    void dispatchStart(android.arch.lifecycle.ReportFragment$ActivityInitializationListener) -> c
android.arch.lifecycle.ReportFragment$ActivityInitializationListener -> android.arch.lifecycle.g$a:
    void onResume() -> d
    void onCreate() -> e
    void onStart() -> f
android.support.v4.app.ActivityCompat$OnRequestPermissionsResultCallback -> a.b.a.a.a:
android.support.v4.app.ActivityCompat$RequestPermissionsRequestCodeValidator -> a.b.a.a.b:
android.support.v4.app.BackStackRecord -> a.b.a.a.c:
    int mBreadCrumbShortTitleRes -> o
    int mIndex -> l
    int mBreadCrumbTitleRes -> m
    boolean mAddToBackStack -> i
    java.lang.String mName -> j
    int mTransitionStyle -> h
    boolean mCommitted -> k
    int mPopExitAnim -> f
    int mTransition -> g
    int mExitAnim -> d
    int mPopEnterAnim -> e
    java.util.ArrayList mOps -> b
    int mEnterAnim -> c
    boolean mReorderingAllowed -> s
    java.lang.CharSequence mBreadCrumbTitleText -> n
    java.lang.CharSequence mBreadCrumbShortTitleText -> p
    java.util.ArrayList mCommitRunnables -> t
    java.util.ArrayList mSharedElementTargetNames -> r
    android.support.v4.app.FragmentManagerImpl mManager -> a
    java.util.ArrayList mSharedElementSourceNames -> q
    android.support.v4.app.FragmentTransaction add(android.support.v4.app.Fragment,java.lang.String) -> a
    void addOp(android.support.v4.app.BackStackRecord$Op) -> a
    void bumpBackStackNesting(int) -> a
    int commit() -> a
    int commitInternal(boolean) -> a
    void doAddOp(int,android.support.v4.app.Fragment,java.lang.String,int) -> a
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    void dump(java.lang.String,java.io.PrintWriter,boolean) -> a
    android.support.v4.app.Fragment expandOps(java.util.ArrayList,android.support.v4.app.Fragment) -> a
    boolean generateOps(java.util.ArrayList,java.util.ArrayList) -> a
    boolean interactsWith(java.util.ArrayList,int,int) -> a
    android.support.v4.app.FragmentTransaction remove(android.support.v4.app.Fragment) -> a
    void setOnStartPostponedListener(android.support.v4.app.Fragment$OnStartEnterTransitionListener) -> a
    int commitAllowingStateLoss() -> b
    void executePopOps(boolean) -> b
    boolean interactsWith(int) -> b
    boolean isFragmentPostponed(android.support.v4.app.BackStackRecord$Op) -> b
    android.support.v4.app.Fragment trackAddedFragmentsInPop(java.util.ArrayList,android.support.v4.app.Fragment) -> b
    void executeOps() -> c
    java.lang.String getName() -> d
    boolean isPostponed() -> e
    void runOnCommitRunnables() -> f
android.support.v4.app.BackStackRecord$Op -> a.b.a.a.c$a:
    int popExitAnim -> f
    android.support.v4.app.Fragment fragment -> b
    int exitAnim -> d
    int popEnterAnim -> e
    int enterAnim -> c
    int cmd -> a
android.support.v4.app.BackStackState -> a.b.a.a.d:
    java.util.ArrayList mSharedElementTargetNames -> k
    java.util.ArrayList mSharedElementSourceNames -> j
    int mBreadCrumbShortTitleRes -> h
    boolean mReorderingAllowed -> l
    int mBreadCrumbTitleRes -> f
    int[] mOps -> a
    int mIndex -> e
    java.lang.CharSequence mBreadCrumbTitleText -> g
    int mTransition -> b
    int mTransitionStyle -> c
    java.lang.CharSequence mBreadCrumbShortTitleText -> i
    java.lang.String mName -> d
    android.support.v4.app.BackStackRecord instantiate(android.support.v4.app.FragmentManagerImpl) -> a
android.support.v4.app.BackStackState$1 -> a.b.a.a.d$a:
android.support.v4.app.BaseFragmentActivityApi14 -> a.b.a.a.e:
    boolean mStartedIntentSenderFromFragment -> b
    void checkForValidRequestCode(int) -> a
    android.view.View dispatchFragmentsOnCreateView(android.view.View,java.lang.String,android.content.Context,android.util.AttributeSet) -> a
android.support.v4.app.BaseFragmentActivityApi16 -> a.b.a.a.f:
    boolean mStartedActivityFromFragment -> c
android.support.v4.app.BundleCompat -> a.b.a.a.g:
    android.os.IBinder getBinder(android.os.Bundle,java.lang.String) -> a
android.support.v4.app.BundleCompat$BundleCompatBaseImpl -> a.b.a.a.g$a:
    boolean sGetIBinderMethodFetched -> b
    java.lang.reflect.Method sGetIBinderMethod -> a
    android.os.IBinder getBinder(android.os.Bundle,java.lang.String) -> a
android.support.v4.app.DialogFragment -> a.b.a.a.h:
    boolean mDismissed -> d0
    boolean mShownByMe -> e0
    int mBackStackId -> a0
    boolean mCancelable -> Y
    boolean mShowsDialog -> Z
    int mTheme -> X
    boolean mViewDestroyed -> c0
    int mStyle -> W
    android.app.Dialog mDialog -> b0
    void onDestroyView() -> F
    void onDetach() -> G
    void onStart() -> J
    void onStop() -> K
    void onAttach(android.content.Context) -> a
    void setupDialog(android.app.Dialog,int) -> a
    void show(android.support.v4.app.FragmentManager,java.lang.String) -> a
    void onActivityCreated(android.os.Bundle) -> b
    void onCreate(android.os.Bundle) -> c
    android.view.LayoutInflater onGetLayoutInflater(android.os.Bundle) -> d
    void onSaveInstanceState(android.os.Bundle) -> e
    void dismissInternal(boolean) -> g
    void setShowsDialog(boolean) -> h
    android.app.Dialog onCreateDialog(android.os.Bundle) -> n
android.support.v4.app.Fragment -> a.b.a.a.i:
    boolean mInLayout -> m
    android.support.v4.app.Fragment$AnimationInfo mAnimationInfo -> N
    boolean mPerformedCreateView -> o
    boolean mHiddenChanged -> P
    boolean mUserVisibleHint -> J
    int mTargetIndex -> h
    boolean mRemoving -> k
    boolean mLoadersStarted -> L
    android.support.v4.app.FragmentHostCallback mHost -> r
    int mIndex -> d
    android.view.View mInnerView -> H
    java.lang.String mTag -> x
    java.lang.Object USE_DEFAULT_TRANSITION -> V
    boolean mHidden -> y
    boolean mCalled -> E
    int mContainerId -> w
    boolean mRetainInstance -> A
    android.support.v4.app.Fragment mParentFragment -> u
    java.lang.String mWho -> e
    boolean mHasMenu -> C
    boolean mCheckedForLoaderManager -> M
    boolean mRestored -> n
    boolean mIsNewlyAdded -> O
    boolean mDeferStart -> I
    android.os.Bundle mSavedFragmentState -> b
    boolean mAdded -> j
    int mTargetRequestCode -> i
    boolean mFromLayout -> l
    android.support.v4.app.FragmentManagerImpl mChildFragmentManager -> s
    android.os.Bundle mArguments -> f
    android.support.v4.app.FragmentManagerNonConfig mChildNonConfig -> t
    android.support.v4.app.FragmentManagerImpl mFragmentManager -> q
    boolean mIsCreated -> S
    int mState -> a
    android.support.v4.app.Fragment mTarget -> g
    android.util.SparseArray mSavedViewState -> c
    android.view.ViewGroup mContainer -> F
    android.view.LayoutInflater mLayoutInflater -> R
    android.support.v4.util.SimpleArrayMap sClassMap -> U
    boolean mDetached -> z
    android.support.v4.app.LoaderManagerImpl mLoaderManager -> K
    android.arch.lifecycle.LifecycleRegistry mLifecycleRegistry -> T
    int mFragmentId -> v
    float mPostponedAlpha -> Q
    boolean mRetaining -> B
    int mBackStackNesting -> p
    android.view.View mView -> G
    boolean mMenuVisible -> D
    boolean isPostponed() -> A
    boolean isStateSaved() -> B
    void noteStateNotSaved() -> C
    void onDestroy() -> D
    void onDestroyOptionsMenu() -> E
    void onDestroyView() -> F
    void onDetach() -> G
    void onPause() -> H
    void onResume() -> I
    void onStart() -> J
    void onStop() -> K
    android.support.v4.app.FragmentManager peekChildFragmentManager() -> L
    void performDestroy() -> M
    void performDestroyView() -> N
    void performDetach() -> O
    void performLowMemory() -> P
    void performPause() -> Q
    void performReallyStop() -> R
    void performResume() -> S
    void performStart() -> T
    void performStop() -> U
    void startPostponedEnterTransition() -> V
    void callStartTransitionListener() -> W
    android.support.v4.app.Fragment$AnimationInfo ensureAnimationInfo() -> X
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    android.support.v4.app.Fragment findFragmentByWho(java.lang.String) -> a
    android.view.LayoutInflater getLayoutInflater(android.os.Bundle) -> a
    android.arch.lifecycle.Lifecycle getLifecycle() -> a
    android.support.v4.app.Fragment instantiate(android.content.Context,java.lang.String,android.os.Bundle) -> a
    boolean isSupportFragmentClass(android.content.Context,java.lang.String) -> a
    void onActivityResult(int,int,android.content.Intent) -> a
    void onAttach(android.app.Activity) -> a
    void onAttach(android.content.Context) -> a
    void onAttachFragment(android.support.v4.app.Fragment) -> a
    boolean onContextItemSelected(android.view.MenuItem) -> a
    android.view.animation.Animation onCreateAnimation(int,boolean,int) -> a
    void onCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> a
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> a
    void onHiddenChanged(boolean) -> a
    void onInflate(android.app.Activity,android.util.AttributeSet,android.os.Bundle) -> a
    void onInflate(android.content.Context,android.util.AttributeSet,android.os.Bundle) -> a
    void onOptionsMenuClosed(android.view.Menu) -> a
    void onRequestPermissionsResult(int,java.lang.String[],int[]) -> a
    void onViewCreated(android.view.View,android.os.Bundle) -> a
    void performConfigurationChanged(android.content.res.Configuration) -> a
    void setAnimatingAway(android.view.View) -> a
    void setAnimator(android.animation.Animator) -> a
    void setIndex(int,android.support.v4.app.Fragment) -> a
    void setNextAnim(int) -> a
    void setNextTransition(int,int) -> a
    void setOnStartEnterTransitionListener(android.support.v4.app.Fragment$OnStartEnterTransitionListener) -> a
    void access$800(android.support.v4.app.Fragment) -> b
    android.support.v4.app.FragmentActivity getActivity() -> b
    void onActivityCreated(android.os.Bundle) -> b
    android.animation.Animator onCreateAnimator(int,boolean,int) -> b
    void onMultiWindowModeChanged(boolean) -> b
    boolean onOptionsItemSelected(android.view.MenuItem) -> b
    void onPrepareOptionsMenu(android.view.Menu) -> b
    boolean performCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> b
    android.view.View performCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> b
    void setStateAfterAnimating(int) -> b
    boolean getAllowEnterTransitionOverlap() -> c
    void onCreate(android.os.Bundle) -> c
    void onPictureInPictureModeChanged(boolean) -> c
    boolean performContextItemSelected(android.view.MenuItem) -> c
    void performOptionsMenuClosed(android.view.Menu) -> c
    boolean getAllowReturnTransitionOverlap() -> d
    android.view.LayoutInflater onGetLayoutInflater(android.os.Bundle) -> d
    void performMultiWindowModeChanged(boolean) -> d
    boolean performOptionsItemSelected(android.view.MenuItem) -> d
    boolean performPrepareOptionsMenu(android.view.Menu) -> d
    android.view.View getAnimatingAway() -> e
    void onSaveInstanceState(android.os.Bundle) -> e
    void performPictureInPictureModeChanged(boolean) -> e
    android.animation.Animator getAnimator() -> f
    void onViewStateRestored(android.os.Bundle) -> f
    void setHideReplaced(boolean) -> f
    android.support.v4.app.FragmentManager getChildFragmentManager() -> g
    void performActivityCreated(android.os.Bundle) -> g
    java.lang.Object getEnterTransition() -> h
    void performCreate(android.os.Bundle) -> h
    android.support.v4.app.SharedElementCallback getEnterTransitionCallback() -> i
    android.view.LayoutInflater performGetLayoutInflater(android.os.Bundle) -> i
    java.lang.Object getExitTransition() -> j
    void performSaveInstanceState(android.os.Bundle) -> j
    android.support.v4.app.SharedElementCallback getExitTransitionCallback() -> k
    void restoreChildFragmentState(android.os.Bundle) -> k
    android.support.v4.app.FragmentManager getFragmentManager() -> l
    void restoreViewState(android.os.Bundle) -> l
    int getNextAnim() -> m
    void setArguments(android.os.Bundle) -> m
    int getNextTransition() -> n
    int getNextTransitionStyle() -> o
    java.lang.Object getReenterTransition() -> p
    android.content.res.Resources getResources() -> q
    java.lang.Object getReturnTransition() -> r
    java.lang.Object getSharedElementEnterTransition() -> s
    java.lang.Object getSharedElementReturnTransition() -> t
    int getStateAfterAnimating() -> u
    android.view.View getView() -> v
    void initState() -> w
    void instantiateChildFragmentManager() -> x
    boolean isHideReplaced() -> y
    boolean isInBackStack() -> z
android.support.v4.app.Fragment$1 -> a.b.a.a.i$a:
    android.support.v4.app.Fragment this$0 -> a
android.support.v4.app.Fragment$2 -> a.b.a.a.i$b:
    android.support.v4.app.Fragment this$0 -> a
    android.support.v4.app.Fragment instantiate(android.content.Context,java.lang.String,android.os.Bundle) -> a
    android.view.View onFindViewById(int) -> a
    boolean onHasView() -> a
android.support.v4.app.Fragment$AnimationInfo -> a.b.a.a.i$c:
    java.lang.Object mReenterTransition -> j
    java.lang.Object mSharedElementEnterTransition -> k
    java.lang.Object mReturnTransition -> h
    java.lang.Object mExitTransition -> i
    android.support.v4.app.Fragment$OnStartEnterTransitionListener mStartEnterTransitionListener -> r
    java.lang.Object mEnterTransition -> g
    int mNextTransitionStyle -> f
    int mNextAnim -> d
    java.lang.Boolean mAllowReturnTransitionOverlap -> m
    int mNextTransition -> e
    java.lang.Boolean mAllowEnterTransitionOverlap -> n
    android.support.v4.app.SharedElementCallback mEnterTransitionCallback -> o
    boolean mEnterTransitionPostponed -> q
    int mStateAfterAnimating -> c
    java.lang.Object mSharedElementReturnTransition -> l
    boolean mIsHideReplaced -> s
    android.support.v4.app.SharedElementCallback mExitTransitionCallback -> p
    android.animation.Animator mAnimator -> b
    android.view.View mAnimatingAway -> a
    java.lang.Object access$000(android.support.v4.app.Fragment$AnimationInfo) -> a
    java.lang.Object access$100(android.support.v4.app.Fragment$AnimationInfo) -> b
    java.lang.Object access$200(android.support.v4.app.Fragment$AnimationInfo) -> c
    java.lang.Object access$300(android.support.v4.app.Fragment$AnimationInfo) -> d
    java.lang.Object access$400(android.support.v4.app.Fragment$AnimationInfo) -> e
    java.lang.Object access$500(android.support.v4.app.Fragment$AnimationInfo) -> f
    java.lang.Boolean access$600(android.support.v4.app.Fragment$AnimationInfo) -> g
    java.lang.Boolean access$700(android.support.v4.app.Fragment$AnimationInfo) -> h
android.support.v4.app.Fragment$InstantiationException -> a.b.a.a.i$d:
android.support.v4.app.Fragment$OnStartEnterTransitionListener -> a.b.a.a.i$e:
    void onStartEnterTransition() -> a
    void startListening() -> b
android.support.v4.app.FragmentActivity -> a.b.a.a.j:
    android.os.Handler mHandler -> d
    boolean mReallyStopped -> i
    android.support.v4.app.FragmentController mFragments -> e
    boolean mRetaining -> j
    int mNextCandidateRequestIndex -> k
    boolean mCreated -> f
    boolean mResumed -> g
    android.support.v4.util.SparseArrayCompat mPendingFragmentActivityResults -> l
    boolean mStopped -> h
    android.view.View dispatchFragmentsOnCreateView(android.view.View,java.lang.String,android.content.Context,android.util.AttributeSet) -> a
    void doReallyStop(boolean) -> a
    android.arch.lifecycle.Lifecycle getLifecycle() -> a
    void markState(android.support.v4.app.FragmentManager,android.arch.lifecycle.Lifecycle$State) -> a
    void onAttachFragment(android.support.v4.app.Fragment) -> a
    boolean onPrepareOptionsPanel(android.view.View,android.view.Menu) -> a
    android.support.v4.app.FragmentManager getSupportFragmentManager() -> b
    void onReallyStop() -> c
    void onResumeFragments() -> d
    java.lang.Object onRetainCustomNonConfigurationInstance() -> e
    void supportInvalidateOptionsMenu() -> f
android.support.v4.app.FragmentActivity$1 -> a.b.a.a.j$a:
    android.support.v4.app.FragmentActivity this$0 -> a
android.support.v4.app.FragmentActivity$HostCallbacks -> a.b.a.a.j$b:
    android.support.v4.app.FragmentActivity this$0 -> j
    void onAttachFragment(android.support.v4.app.Fragment) -> a
    android.view.View onFindViewById(int) -> a
    boolean onHasView() -> a
    void onDump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> b
    boolean onShouldSaveFragmentState(android.support.v4.app.Fragment) -> b
    android.view.LayoutInflater onGetLayoutInflater() -> i
    int onGetWindowAnimations() -> j
    boolean onHasWindowAnimations() -> k
    void onSupportInvalidateOptionsMenu() -> l
android.support.v4.app.FragmentActivity$NonConfigurationInstances -> a.b.a.a.j$c:
    android.support.v4.util.SimpleArrayMap loaders -> b
    android.support.v4.app.FragmentManagerNonConfig fragments -> a
android.support.v4.app.FragmentContainer -> a.b.a.a.k:
    android.support.v4.app.Fragment instantiate(android.content.Context,java.lang.String,android.os.Bundle) -> a
    android.view.View onFindViewById(int) -> a
    boolean onHasView() -> a
android.support.v4.app.FragmentController -> a.b.a.a.l:
    android.support.v4.app.FragmentHostCallback mHost -> a
    void attachHost(android.support.v4.app.Fragment) -> a
    android.support.v4.app.FragmentController createController(android.support.v4.app.FragmentHostCallback) -> a
    void dispatchActivityCreated() -> a
    void dispatchConfigurationChanged(android.content.res.Configuration) -> a
    boolean dispatchContextItemSelected(android.view.MenuItem) -> a
    boolean dispatchCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> a
    void dispatchMultiWindowModeChanged(boolean) -> a
    void dispatchOptionsMenuClosed(android.view.Menu) -> a
    void dumpLoaders(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    android.support.v4.app.Fragment findFragmentByWho(java.lang.String) -> a
    android.view.View onCreateView(android.view.View,java.lang.String,android.content.Context,android.util.AttributeSet) -> a
    void restoreAllState(android.os.Parcelable,android.support.v4.app.FragmentManagerNonConfig) -> a
    void restoreLoaderNonConfig(android.support.v4.util.SimpleArrayMap) -> a
    void dispatchCreate() -> b
    boolean dispatchOptionsItemSelected(android.view.MenuItem) -> b
    void dispatchPictureInPictureModeChanged(boolean) -> b
    boolean dispatchPrepareOptionsMenu(android.view.Menu) -> b
    void dispatchDestroy() -> c
    void doLoaderStop(boolean) -> c
    void dispatchLowMemory() -> d
    void dispatchPause() -> e
    void dispatchReallyStop() -> f
    void dispatchResume() -> g
    void dispatchStart() -> h
    void dispatchStop() -> i
    void doLoaderDestroy() -> j
    void doLoaderStart() -> k
    boolean execPendingActions() -> l
    android.support.v4.app.FragmentManager getSupportFragmentManager() -> m
    void noteStateNotSaved() -> n
    void reportLoaderStart() -> o
    android.support.v4.util.SimpleArrayMap retainLoaderNonConfig() -> p
    android.support.v4.app.FragmentManagerNonConfig retainNestedNonConfig() -> q
    android.os.Parcelable saveAllState() -> r
android.support.v4.app.FragmentHostCallback -> a.b.a.a.m:
    android.support.v4.app.LoaderManagerImpl mLoaderManager -> g
    android.content.Context mContext -> b
    android.os.Handler mHandler -> c
    boolean mLoadersStarted -> i
    android.support.v4.util.SimpleArrayMap mAllLoaderManagers -> e
    android.support.v4.app.FragmentManagerImpl mFragmentManager -> d
    boolean mRetainLoaders -> f
    boolean mCheckedForLoaderManager -> h
    android.app.Activity mActivity -> a
    void doLoaderStop(boolean) -> a
    void dumpLoaders(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    android.support.v4.app.LoaderManagerImpl getLoaderManager(java.lang.String,boolean,boolean) -> a
    void inactivateFragment(java.lang.String) -> a
    void onAttachFragment(android.support.v4.app.Fragment) -> a
    void restoreLoaderNonConfig(android.support.v4.util.SimpleArrayMap) -> a
    void doLoaderDestroy() -> b
    void onDump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> b
    boolean onShouldSaveFragmentState(android.support.v4.app.Fragment) -> b
    void doLoaderStart() -> c
    android.app.Activity getActivity() -> d
    android.content.Context getContext() -> e
    android.support.v4.app.FragmentManagerImpl getFragmentManagerImpl() -> f
    android.os.Handler getHandler() -> g
    boolean getRetainLoaders() -> h
    android.view.LayoutInflater onGetLayoutInflater() -> i
    int onGetWindowAnimations() -> j
    boolean onHasWindowAnimations() -> k
    void onSupportInvalidateOptionsMenu() -> l
    void reportLoaderStart() -> m
    android.support.v4.util.SimpleArrayMap retainLoaderNonConfig() -> n
android.support.v4.app.FragmentManager -> a.b.a.a.n:
    android.support.v4.app.FragmentTransaction beginTransaction() -> a
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    void popBackStack(int,int) -> a
    java.util.List getFragments() -> b
    boolean isStateSaved() -> c
    boolean popBackStackImmediate() -> d
android.support.v4.app.FragmentManager$BackStackEntry -> a.b.a.a.n$a:
android.support.v4.app.FragmentManager$FragmentLifecycleCallbacks -> a.b.a.a.n$b:
    void onFragmentActivityCreated(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment,android.os.Bundle) -> a
    void onFragmentAttached(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment,android.content.Context) -> a
    void onFragmentDestroyed(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment) -> a
    void onFragmentViewCreated(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment,android.view.View,android.os.Bundle) -> a
    void onFragmentCreated(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment,android.os.Bundle) -> b
    void onFragmentDetached(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment) -> b
    void onFragmentPreAttached(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment,android.content.Context) -> b
    void onFragmentPaused(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment) -> c
    void onFragmentPreCreated(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment,android.os.Bundle) -> c
    void onFragmentResumed(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment) -> d
    void onFragmentSaveInstanceState(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment,android.os.Bundle) -> d
    void onFragmentStarted(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment) -> e
    void onFragmentStopped(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment) -> f
    void onFragmentViewDestroyed(android.support.v4.app.FragmentManager,android.support.v4.app.Fragment) -> g
android.support.v4.app.FragmentManager$OnBackStackChangedListener -> a.b.a.a.n$c:
    void onBackStackChanged() -> a
android.support.v4.app.FragmentManagerImpl -> a.b.a.a.o:
    int mCurState -> l
    java.util.concurrent.CopyOnWriteArrayList mLifecycleCallbacks -> k
    java.util.ArrayList mTmpAddedFragments -> x
    java.util.ArrayList mCreatedMenus -> g
    boolean mHavePendingDeferredStart -> u
    java.lang.reflect.Field sAnimationListenerField -> E
    android.view.animation.Interpolator DECELERATE_CUBIC -> G
    android.support.v4.app.FragmentContainer mContainer -> n
    boolean mNeedMenuInvalidate -> q
    java.util.ArrayList mPendingActions -> a
    boolean mDestroyed -> s
    java.lang.String mNoTransactionsBecause -> t
    java.util.ArrayList mAvailBackStackIndices -> i
    java.util.ArrayList mTmpIsPop -> w
    boolean mExecutingActions -> b
    android.support.v4.app.Fragment mParent -> o
    java.util.ArrayList mBackStack -> f
    android.view.animation.Interpolator DECELERATE_QUINT -> F
    java.util.ArrayList mAdded -> d
    android.support.v4.app.FragmentHostCallback mHost -> m
    int mNextFragmentIndex -> c
    boolean mStateSaved -> r
    java.util.ArrayList mPostponedTransactions -> A
    android.util.SparseArray mStateArray -> z
    java.lang.Runnable mExecCommit -> C
    java.util.ArrayList mBackStackChangeListeners -> j
    java.util.ArrayList mBackStackIndices -> h
    android.support.v4.app.Fragment mPrimaryNav -> p
    java.util.ArrayList mTmpRecords -> v
    android.support.v4.app.FragmentManagerNonConfig mSavedNonConfig -> B
    android.util.SparseArray mActive -> e
    android.os.Bundle mStateBundle -> y
    boolean DEBUG -> D
    void cleanupExec() -> A
    void endAnimatingAwayFragments() -> B
    void forcePostponedTransactions() -> C
    void scheduleCommit() -> D
    void access$500(android.support.v4.app.FragmentManagerImpl) -> a
    void access$600(android.support.v4.app.FragmentManagerImpl,android.support.v4.app.BackStackRecord,boolean,boolean,boolean) -> a
    void addAddedFragments(android.support.v4.util.ArraySet) -> a
    void addBackStackState(android.support.v4.app.BackStackRecord) -> a
    void addFragment(android.support.v4.app.Fragment,boolean) -> a
    void animateRemoveFragment(android.support.v4.app.Fragment,android.support.v4.app.FragmentManagerImpl$AnimationOrAnimator,int) -> a
    void attachController(android.support.v4.app.FragmentHostCallback,android.support.v4.app.FragmentContainer,android.support.v4.app.Fragment) -> a
    void attachFragment(android.support.v4.app.Fragment) -> a
    android.support.v4.app.FragmentTransaction beginTransaction() -> a
    void completeExecute(android.support.v4.app.BackStackRecord,boolean,boolean,boolean) -> a
    void dispatchConfigurationChanged(android.content.res.Configuration) -> a
    boolean dispatchContextItemSelected(android.view.MenuItem) -> a
    boolean dispatchCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> a
    void dispatchMultiWindowModeChanged(boolean) -> a
    void dispatchOnFragmentActivityCreated(android.support.v4.app.Fragment,android.os.Bundle,boolean) -> a
    void dispatchOnFragmentAttached(android.support.v4.app.Fragment,android.content.Context,boolean) -> a
    void dispatchOnFragmentViewCreated(android.support.v4.app.Fragment,android.view.View,android.os.Bundle,boolean) -> a
    void dispatchOptionsMenuClosed(android.view.Menu) -> a
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    void enqueueAction(android.support.v4.app.FragmentManagerImpl$OpGenerator,boolean) -> a
    void executeOps(java.util.ArrayList,java.util.ArrayList,int,int) -> a
    void executePostponedTransaction(java.util.ArrayList,java.util.ArrayList) -> a
    android.support.v4.app.Fragment findFragmentById(int) -> a
    android.support.v4.app.Fragment findFragmentByTag(java.lang.String) -> a
    android.view.animation.Animation$AnimationListener getAnimationListener(android.view.animation.Animation) -> a
    android.support.v4.app.Fragment getFragment(android.os.Bundle,java.lang.String) -> a
    android.support.v4.app.FragmentManagerImpl$AnimationOrAnimator loadAnimation(android.support.v4.app.Fragment,int,boolean,int) -> a
    android.support.v4.app.FragmentManagerImpl$AnimationOrAnimator makeFadeAnimation(android.content.Context,float,float) -> a
    android.support.v4.app.FragmentManagerImpl$AnimationOrAnimator makeOpenCloseAnimation(android.content.Context,float,float,float,float) -> a
    boolean modifiesAlpha(android.animation.Animator) -> a
    boolean modifiesAlpha(android.support.v4.app.FragmentManagerImpl$AnimationOrAnimator) -> a
    void moveToState(int,boolean) -> a
    void moveToState(android.support.v4.app.Fragment,int,int,int,boolean) -> a
    void popBackStack(int,int) -> a
    boolean popBackStackImmediate(java.lang.String,int,int) -> a
    boolean popBackStackState(java.util.ArrayList,java.util.ArrayList,java.lang.String,int,int) -> a
    int postponePostponableTransactions(java.util.ArrayList,java.util.ArrayList,int,int,android.support.v4.util.ArraySet) -> a
    void putFragment(android.os.Bundle,java.lang.String,android.support.v4.app.Fragment) -> a
    void restoreAllState(android.os.Parcelable,android.support.v4.app.FragmentManagerNonConfig) -> a
    void setBackStackIndex(int,android.support.v4.app.BackStackRecord) -> a
    void setHWLayerAnimListenerIfAlpha(android.view.View,android.support.v4.app.FragmentManagerImpl$AnimationOrAnimator) -> a
    void setRetaining(android.support.v4.app.FragmentManagerNonConfig) -> a
    void throwException(java.lang.RuntimeException) -> a
    int allocBackStackIndex(android.support.v4.app.BackStackRecord) -> b
    void completeShowHideFragment(android.support.v4.app.Fragment) -> b
    void dispatchOnFragmentCreated(android.support.v4.app.Fragment,android.os.Bundle,boolean) -> b
    void dispatchOnFragmentDestroyed(android.support.v4.app.Fragment,boolean) -> b
    void dispatchOnFragmentPreAttached(android.support.v4.app.Fragment,android.content.Context,boolean) -> b
    boolean dispatchOptionsItemSelected(android.view.MenuItem) -> b
    void dispatchPictureInPictureModeChanged(boolean) -> b
    boolean dispatchPrepareOptionsMenu(android.view.Menu) -> b
    void executeOpsTogether(java.util.ArrayList,java.util.ArrayList,int,int) -> b
    android.support.v4.app.Fragment findFragmentByWho(java.lang.String) -> b
    void freeBackStackIndex(int) -> b
    boolean generateOpsForPendingActions(java.util.ArrayList,java.util.ArrayList) -> b
    java.util.List getFragments() -> b
    void makeRemovedFragmentsInvisible(android.support.v4.util.ArraySet) -> b
    boolean shouldRunOnHWLayer(android.view.View,android.support.v4.app.FragmentManagerImpl$AnimationOrAnimator) -> b
    int transitToStyleIndex(int,boolean) -> b
    void detachFragment(android.support.v4.app.Fragment) -> c
    void dispatchOnFragmentDetached(android.support.v4.app.Fragment,boolean) -> c
    void dispatchOnFragmentPreCreated(android.support.v4.app.Fragment,android.os.Bundle,boolean) -> c
    void ensureExecReady(boolean) -> c
    boolean isStateAtLeast(int) -> c
    boolean isStateSaved() -> c
    void removeRedundantOperationsAndExecute(java.util.ArrayList,java.util.ArrayList) -> c
    void dispatchOnFragmentPaused(android.support.v4.app.Fragment,boolean) -> d
    void dispatchOnFragmentSaveInstanceState(android.support.v4.app.Fragment,android.os.Bundle,boolean) -> d
    void dispatchStateChange(int) -> d
    void ensureInflatedFragmentView(android.support.v4.app.Fragment) -> d
    boolean popBackStackImmediate() -> d
    void dispatchActivityCreated() -> e
    void dispatchOnFragmentResumed(android.support.v4.app.Fragment,boolean) -> e
    void hideFragment(android.support.v4.app.Fragment) -> e
    int reverseTransit(int) -> e
    void dispatchCreate() -> f
    void dispatchOnFragmentStarted(android.support.v4.app.Fragment,boolean) -> f
    void makeActive(android.support.v4.app.Fragment) -> f
    void dispatchDestroy() -> g
    void dispatchOnFragmentStopped(android.support.v4.app.Fragment,boolean) -> g
    void makeInactive(android.support.v4.app.Fragment) -> g
    void dispatchDestroyView() -> h
    void dispatchOnFragmentViewDestroyed(android.support.v4.app.Fragment,boolean) -> h
    void moveFragmentToExpectedState(android.support.v4.app.Fragment) -> h
    void dispatchLowMemory() -> i
    void moveToState(android.support.v4.app.Fragment) -> i
    void dispatchPause() -> j
    void performPendingDeferredStart(android.support.v4.app.Fragment) -> j
    void dispatchReallyStop() -> k
    void removeFragment(android.support.v4.app.Fragment) -> k
    void dispatchResume() -> l
    android.os.Bundle saveFragmentBasicState(android.support.v4.app.Fragment) -> l
    void dispatchStart() -> m
    void saveFragmentViewState(android.support.v4.app.Fragment) -> m
    void dispatchStop() -> n
    void setPrimaryNavigationFragment(android.support.v4.app.Fragment) -> n
    void doPendingDeferredStart() -> o
    void showFragment(android.support.v4.app.Fragment) -> o
    boolean execPendingActions() -> p
    android.support.v4.app.Fragment findFragmentUnder(android.support.v4.app.Fragment) -> p
    android.view.LayoutInflater$Factory2 getLayoutInflaterFactory() -> q
    android.support.v4.app.Fragment getPrimaryNavigationFragment() -> r
    void noteStateNotSaved() -> s
    void reportBackStackChanged() -> t
    android.support.v4.app.FragmentManagerNonConfig retainNonConfig() -> u
    android.os.Parcelable saveAllState() -> v
    void saveNonConfig() -> w
    void startPendingDeferredFragments() -> x
    void burpActive() -> y
    void checkStateLoss() -> z
android.support.v4.app.FragmentManagerImpl$1 -> a.b.a.a.o$a:
    android.support.v4.app.FragmentManagerImpl this$0 -> a
android.support.v4.app.FragmentManagerImpl$2 -> a.b.a.a.o$b:
    android.support.v4.app.FragmentManagerImpl this$0 -> c
    android.support.v4.app.Fragment val$fragment -> b
android.support.v4.app.FragmentManagerImpl$3 -> a.b.a.a.o$c:
    android.view.ViewGroup val$container -> a
    android.support.v4.app.FragmentManagerImpl this$0 -> d
    android.view.View val$viewToAnimate -> b
    android.support.v4.app.Fragment val$fragment -> c
android.support.v4.app.FragmentManagerImpl$4 -> a.b.a.a.o$d:
    android.view.ViewGroup val$container -> a
    android.view.View val$animatingView -> b
    android.support.v4.app.Fragment val$fragment -> c
android.support.v4.app.FragmentManagerImpl$AnimateOnHWLayerIfNeededListener -> a.b.a.a.o$e:
    android.view.View mView -> b
android.support.v4.app.FragmentManagerImpl$AnimateOnHWLayerIfNeededListener$1 -> a.b.a.a.o$e$a:
    android.support.v4.app.FragmentManagerImpl$AnimateOnHWLayerIfNeededListener this$0 -> a
android.support.v4.app.FragmentManagerImpl$AnimationListenerWrapper -> a.b.a.a.o$f:
    android.view.animation.Animation$AnimationListener mWrapped -> a
android.support.v4.app.FragmentManagerImpl$AnimationOrAnimator -> a.b.a.a.o$g:
    android.view.animation.Animation animation -> a
    android.animation.Animator animator -> b
android.support.v4.app.FragmentManagerImpl$AnimatorOnHWLayerIfNeededListener -> a.b.a.a.o$h:
    android.view.View mView -> a
android.support.v4.app.FragmentManagerImpl$FragmentTag -> a.b.a.a.o$i:
    int[] Fragment -> a
android.support.v4.app.FragmentManagerImpl$OpGenerator -> a.b.a.a.o$j:
    boolean generateOps(java.util.ArrayList,java.util.ArrayList) -> a
android.support.v4.app.FragmentManagerImpl$PopBackStackState -> a.b.a.a.o$k:
    android.support.v4.app.FragmentManagerImpl this$0 -> d
    java.lang.String mName -> a
    int mId -> b
    int mFlags -> c
    boolean generateOps(java.util.ArrayList,java.util.ArrayList) -> a
android.support.v4.app.FragmentManagerImpl$StartEnterTransitionListener -> a.b.a.a.o$l:
    android.support.v4.app.BackStackRecord mRecord -> b
    boolean mIsBack -> a
    int mNumPostponed -> c
    boolean access$300(android.support.v4.app.FragmentManagerImpl$StartEnterTransitionListener) -> a
    void onStartEnterTransition() -> a
    android.support.v4.app.BackStackRecord access$400(android.support.v4.app.FragmentManagerImpl$StartEnterTransitionListener) -> b
    void startListening() -> b
    void cancelTransaction() -> c
    void completeTransaction() -> d
    boolean isReady() -> e
android.support.v4.app.FragmentManagerNonConfig -> a.b.a.a.p:
    java.util.List mChildNonConfigs -> b
    java.util.List mFragments -> a
    java.util.List getChildNonConfigs() -> a
    java.util.List getFragments() -> b
android.support.v4.app.FragmentManagerState -> a.b.a.a.q:
    int[] mAdded -> b
    android.support.v4.app.BackStackState[] mBackStack -> c
    int mPrimaryNavActiveIndex -> d
    int mNextFragmentIndex -> e
    android.support.v4.app.FragmentState[] mActive -> a
android.support.v4.app.FragmentManagerState$1 -> a.b.a.a.q$a:
android.support.v4.app.FragmentState -> a.b.a.a.r:
    java.lang.String mTag -> f
    android.support.v4.app.Fragment mInstance -> l
    boolean mHidden -> j
    java.lang.String mClassName -> a
    int mFragmentId -> d
    boolean mRetainInstance -> g
    android.os.Bundle mArguments -> i
    int mContainerId -> e
    boolean mDetached -> h
    int mIndex -> b
    android.os.Bundle mSavedFragmentState -> k
    boolean mFromLayout -> c
    android.support.v4.app.Fragment instantiate(android.support.v4.app.FragmentHostCallback,android.support.v4.app.FragmentContainer,android.support.v4.app.Fragment,android.support.v4.app.FragmentManagerNonConfig) -> a
android.support.v4.app.FragmentState$1 -> a.b.a.a.r$a:
android.support.v4.app.FragmentTransaction -> a.b.a.a.s:
    android.support.v4.app.FragmentTransaction add(android.support.v4.app.Fragment,java.lang.String) -> a
    int commit() -> a
    android.support.v4.app.FragmentTransaction remove(android.support.v4.app.Fragment) -> a
    int commitAllowingStateLoss() -> b
android.support.v4.app.FragmentTransition -> a.b.a.a.t:
    int[] INVERSE_OPS -> a
    void access$000(java.util.ArrayList,int) -> a
    java.util.ArrayList access$100(java.lang.Object,android.support.v4.app.Fragment,java.util.ArrayList,android.view.View) -> a
    void access$200(android.support.v4.app.Fragment,android.support.v4.app.Fragment,boolean,android.support.v4.util.ArrayMap,boolean) -> a
    android.support.v4.util.ArrayMap access$300(android.support.v4.util.ArrayMap,java.lang.Object,android.support.v4.app.FragmentTransition$FragmentContainerTransition) -> a
    android.view.View access$400(android.support.v4.util.ArrayMap,android.support.v4.app.FragmentTransition$FragmentContainerTransition,java.lang.Object,boolean) -> a
    void addSharedElementsWithMatchingNames(java.util.ArrayList,android.support.v4.util.ArrayMap,java.util.Collection) -> a
    void addToFirstInLastOut(android.support.v4.app.BackStackRecord,android.support.v4.app.BackStackRecord$Op,android.util.SparseArray,boolean,boolean) -> a
    void calculateFragments(android.support.v4.app.BackStackRecord,android.util.SparseArray,boolean) -> a
    android.support.v4.util.ArrayMap calculateNameOverrides(int,java.util.ArrayList,java.util.ArrayList,int,int) -> a
    java.lang.Object configureSharedElementsOrdered(android.view.ViewGroup,android.view.View,android.support.v4.util.ArrayMap,android.support.v4.app.FragmentTransition$FragmentContainerTransition,java.util.ArrayList,java.util.ArrayList,java.lang.Object,java.lang.Object) -> a
    void configureTransitionsOrdered(android.support.v4.app.FragmentManagerImpl,int,android.support.v4.app.FragmentTransition$FragmentContainerTransition,android.view.View,android.support.v4.util.ArrayMap) -> a
    android.support.v4.app.FragmentTransition$FragmentContainerTransition ensureContainer(android.support.v4.app.FragmentTransition$FragmentContainerTransition,android.util.SparseArray,int) -> a
    java.lang.String findKeyForValue(android.support.v4.util.ArrayMap,java.lang.String) -> a
    java.lang.Object getEnterTransition(android.support.v4.app.Fragment,boolean) -> a
    java.lang.Object getSharedElementTransition(android.support.v4.app.Fragment,android.support.v4.app.Fragment,boolean) -> a
    java.lang.Object mergeTransitions(java.lang.Object,java.lang.Object,java.lang.Object,android.support.v4.app.Fragment,boolean) -> a
    void replaceHide(java.lang.Object,android.support.v4.app.Fragment,java.util.ArrayList) -> a
    void retainValues(android.support.v4.util.ArrayMap,android.support.v4.util.ArrayMap) -> a
    void scheduleTargetChange(android.view.ViewGroup,android.support.v4.app.Fragment,android.view.View,java.util.ArrayList,java.lang.Object,java.util.ArrayList,java.lang.Object,java.util.ArrayList) -> a
    void setOutEpicenter(java.lang.Object,java.lang.Object,android.support.v4.util.ArrayMap,boolean,android.support.v4.app.BackStackRecord) -> a
    void startTransitions(android.support.v4.app.FragmentManagerImpl,java.util.ArrayList,java.util.ArrayList,int,int,boolean) -> a
    void calculatePopFragments(android.support.v4.app.BackStackRecord,android.util.SparseArray,boolean) -> b
    void callSharedElementStartEnd(android.support.v4.app.Fragment,android.support.v4.app.Fragment,boolean,android.support.v4.util.ArrayMap,boolean) -> b
    android.support.v4.util.ArrayMap captureInSharedElements(android.support.v4.util.ArrayMap,java.lang.Object,android.support.v4.app.FragmentTransition$FragmentContainerTransition) -> b
    java.util.ArrayList configureEnteringExitingViews(java.lang.Object,android.support.v4.app.Fragment,java.util.ArrayList,android.view.View) -> b
    java.lang.Object configureSharedElementsReordered(android.view.ViewGroup,android.view.View,android.support.v4.util.ArrayMap,android.support.v4.app.FragmentTransition$FragmentContainerTransition,java.util.ArrayList,java.util.ArrayList,java.lang.Object,java.lang.Object) -> b
    void configureTransitionsReordered(android.support.v4.app.FragmentManagerImpl,int,android.support.v4.app.FragmentTransition$FragmentContainerTransition,android.view.View,android.support.v4.util.ArrayMap) -> b
    java.lang.Object getExitTransition(android.support.v4.app.Fragment,boolean) -> b
    android.view.View getInEpicenterView(android.support.v4.util.ArrayMap,android.support.v4.app.FragmentTransition$FragmentContainerTransition,java.lang.Object,boolean) -> b
    void setViewVisibility(java.util.ArrayList,int) -> b
    android.support.v4.util.ArrayMap captureOutSharedElements(android.support.v4.util.ArrayMap,java.lang.Object,android.support.v4.app.FragmentTransition$FragmentContainerTransition) -> c
android.support.v4.app.FragmentTransition$1 -> a.b.a.a.t$a:
    java.util.ArrayList val$exitingViews -> a
android.support.v4.app.FragmentTransition$2 -> a.b.a.a.t$b:
    java.lang.Object val$exitTransition -> g
    java.util.ArrayList val$exitingViews -> f
    java.util.ArrayList val$enteringViews -> e
    java.lang.Object val$enterTransition -> a
    android.view.View val$nonExistentView -> b
    android.support.v4.app.Fragment val$inFragment -> c
    java.util.ArrayList val$sharedElementsIn -> d
android.support.v4.app.FragmentTransition$3 -> a.b.a.a.t$c:
    android.support.v4.util.ArrayMap val$inSharedElements -> d
    android.support.v4.app.Fragment val$inFragment -> a
    android.support.v4.app.Fragment val$outFragment -> b
    android.graphics.Rect val$epicenter -> f
    android.view.View val$epicenterView -> e
    boolean val$inIsPop -> c
android.support.v4.app.FragmentTransition$4 -> a.b.a.a.t$d:
    java.lang.Object val$enterTransition -> j
    android.support.v4.util.ArrayMap val$nameOverrides -> a
    android.graphics.Rect val$inEpicenter -> k
    java.util.ArrayList val$sharedElementsOut -> i
    android.support.v4.app.FragmentTransition$FragmentContainerTransition val$fragments -> c
    java.lang.Object val$finalSharedElementTransition -> b
    java.util.ArrayList val$sharedElementsIn -> d
    boolean val$inIsPop -> h
    android.view.View val$nonExistentView -> e
    android.support.v4.app.Fragment val$inFragment -> f
    android.support.v4.app.Fragment val$outFragment -> g
android.support.v4.app.FragmentTransition$FragmentContainerTransition -> a.b.a.a.t$e:
    android.support.v4.app.BackStackRecord firstOutTransaction -> f
    boolean firstOutIsPop -> e
    android.support.v4.app.Fragment lastIn -> a
    android.support.v4.app.BackStackRecord lastInTransaction -> c
    android.support.v4.app.Fragment firstOut -> d
    boolean lastInIsPop -> b
android.support.v4.app.FragmentTransitionCompat21 -> a.b.a.a.u:
    java.lang.String access$000(java.util.Map,java.lang.String) -> a
    void addTarget(java.lang.Object,android.view.View) -> a
    void addTargets(java.lang.Object,java.util.ArrayList) -> a
    void beginDelayedTransition(android.view.ViewGroup,java.lang.Object) -> a
    void bfsAddViewChildren(java.util.List,android.view.View) -> a
    void captureTransitioningViews(java.util.ArrayList,android.view.View) -> a
    java.lang.Object cloneTransition(java.lang.Object) -> a
    boolean containedBeforeIndex(java.util.List,android.view.View,int) -> a
    void findNamedViews(java.util.Map,android.view.View) -> a
    void getBoundsOnScreen(android.view.View,android.graphics.Rect) -> a
    boolean hasSimpleTarget(android.transition.Transition) -> a
    boolean isNullOrEmpty(java.util.List) -> a
    java.lang.Object mergeTransitionsInSequence(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.util.ArrayList prepareSetNameOverridesReordered(java.util.ArrayList) -> a
    void replaceTargets(java.lang.Object,java.util.ArrayList,java.util.ArrayList) -> a
    void scheduleHideFragmentView(java.lang.Object,android.view.View,java.util.ArrayList) -> a
    void scheduleNameReset(android.view.ViewGroup,java.util.ArrayList,java.util.Map) -> a
    void scheduleRemoveTargets(java.lang.Object,java.lang.Object,java.util.ArrayList,java.lang.Object,java.util.ArrayList,java.lang.Object,java.util.ArrayList) -> a
    void setEpicenter(java.lang.Object,android.graphics.Rect) -> a
    void setNameOverridesOrdered(android.view.View,java.util.ArrayList,java.util.Map) -> a
    void setNameOverridesReordered(android.view.View,java.util.ArrayList,java.util.ArrayList,java.util.ArrayList,java.util.Map) -> a
    java.lang.String findKeyForValue(java.util.Map,java.lang.String) -> b
    java.lang.Object mergeTransitionsTogether(java.lang.Object,java.lang.Object,java.lang.Object) -> b
    void removeTarget(java.lang.Object,android.view.View) -> b
    void setSharedElementTargets(java.lang.Object,android.view.View,java.util.ArrayList) -> b
    void swapSharedElementTargets(java.lang.Object,java.util.ArrayList,java.util.ArrayList) -> b
    java.lang.Object wrapTransitionInSet(java.lang.Object) -> b
    void setEpicenter(java.lang.Object,android.view.View) -> c
android.support.v4.app.FragmentTransitionCompat21$1 -> a.b.a.a.u$a:
    android.graphics.Rect val$epicenter -> a
android.support.v4.app.FragmentTransitionCompat21$2 -> a.b.a.a.u$b:
    android.view.View val$fragmentView -> a
    java.util.ArrayList val$exitingViews -> b
android.support.v4.app.FragmentTransitionCompat21$3 -> a.b.a.a.u$c:
    java.util.ArrayList val$outNames -> e
    java.util.ArrayList val$sharedElementsOut -> d
    java.util.ArrayList val$inNames -> c
    java.util.ArrayList val$sharedElementsIn -> b
    int val$numSharedElements -> a
android.support.v4.app.FragmentTransitionCompat21$4 -> a.b.a.a.u$d:
    java.util.Map val$nameOverrides -> b
    java.util.ArrayList val$sharedElementsIn -> a
android.support.v4.app.FragmentTransitionCompat21$5 -> a.b.a.a.u$e:
    java.lang.Object val$sharedElementTransition -> e
    java.lang.Object val$exitTransition -> c
    java.util.ArrayList val$sharedElementsIn -> f
    java.lang.Object val$enterTransition -> a
    java.util.ArrayList val$exitingViews -> d
    java.util.ArrayList val$enteringViews -> b
android.support.v4.app.FragmentTransitionCompat21$6 -> a.b.a.a.u$f:
    android.graphics.Rect val$epicenter -> a
android.support.v4.app.FragmentTransitionCompat21$7 -> a.b.a.a.u$g:
    java.util.Map val$nameOverrides -> b
    java.util.ArrayList val$sharedElementsIn -> a
android.support.v4.app.LoaderManager -> a.b.a.a.v:
android.support.v4.app.LoaderManager$LoaderCallbacks -> a.b.a.a.v$a:
    android.support.v4.content.Loader onCreateLoader(int,android.os.Bundle) -> a
    void onLoadFinished(android.support.v4.content.Loader,java.lang.Object) -> a
    void onLoaderReset(android.support.v4.content.Loader) -> a
android.support.v4.app.LoaderManagerImpl -> a.b.a.a.w:
    android.support.v4.util.SparseArrayCompat mInactiveLoaders -> b
    android.support.v4.app.FragmentHostCallback mHost -> f
    boolean mRetaining -> e
    boolean DEBUG -> g
    java.lang.String mWho -> c
    android.support.v4.util.SparseArrayCompat mLoaders -> a
    boolean mStarted -> d
    void doDestroy() -> a
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    void updateHostController(android.support.v4.app.FragmentHostCallback) -> a
    void doReportNextStart() -> b
    void doReportStart() -> c
    void doRetain() -> d
    void doStart() -> e
    void doStop() -> f
    void finishRetain() -> g
    boolean hasRunningLoaders() -> h
android.support.v4.app.LoaderManagerImpl$LoaderInfo -> a.b.a.a.w$a:
    boolean mListenerRegistered -> m
    boolean mRetaining -> i
    android.os.Bundle mArgs -> b
    java.lang.Object mData -> g
    boolean mRetainingStarted -> j
    boolean mReportNextStart -> k
    boolean mDestroyed -> l
    android.support.v4.app.LoaderManagerImpl this$0 -> o
    android.support.v4.app.LoaderManagerImpl$LoaderInfo mPendingLoader -> n
    android.support.v4.content.Loader mLoader -> d
    int mId -> a
    android.support.v4.app.LoaderManager$LoaderCallbacks mCallbacks -> c
    boolean mHaveData -> e
    boolean mDeliveredData -> f
    boolean mStarted -> h
    void callOnLoadFinished(android.support.v4.content.Loader,java.lang.Object) -> a
    void destroy() -> a
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    void finishRetain() -> b
    void reportStart() -> c
    void retain() -> d
    void start() -> e
    void stop() -> f
android.support.v4.app.NotificationBuilderWithActions -> a.b.a.a.x:
    void addAction(android.support.v4.app.NotificationCompatBase$Action) -> a
android.support.v4.app.NotificationBuilderWithBuilderAccessor -> a.b.a.a.y:
    android.app.Notification build() -> a
    android.app.Notification$Builder getBuilder() -> b
android.support.v4.app.NotificationCompat -> a.b.a.a.z:
    android.support.v4.app.NotificationCompat$NotificationCompatImpl IMPL -> a
    void addActionsToBuilder(android.support.v4.app.NotificationBuilderWithActions,java.util.ArrayList) -> a
    android.os.Bundle getExtras(android.app.Notification) -> a
android.support.v4.app.NotificationCompat$Action -> a.b.a.a.z$a:
    android.support.v4.app.RemoteInput[] mDataOnlyRemoteInputs -> c
    android.support.v4.app.RemoteInput[] mRemoteInputs -> b
    android.os.Bundle mExtras -> a
    java.lang.CharSequence title -> f
    int icon -> e
    android.app.PendingIntent actionIntent -> g
    boolean mAllowGeneratedReplies -> d
    android.app.PendingIntent getActionIntent() -> a
    boolean getAllowGeneratedReplies() -> b
    android.support.v4.app.RemoteInput[] getDataOnlyRemoteInputs() -> c
    android.support.v4.app.RemoteInputCompatBase$RemoteInput[] getDataOnlyRemoteInputs() -> c
    android.os.Bundle getExtras() -> d
    int getIcon() -> e
    android.support.v4.app.RemoteInput[] getRemoteInputs() -> f
    android.support.v4.app.RemoteInputCompatBase$RemoteInput[] getRemoteInputs() -> f
    java.lang.CharSequence getTitle() -> g
android.support.v4.app.NotificationCompat$Action$1 -> a.b.a.a.z$a$a:
android.support.v4.app.NotificationCompat$BigTextStyle -> a.b.a.a.z$b:
    java.lang.CharSequence mBigText -> e
    void apply(android.support.v4.app.NotificationBuilderWithBuilderAccessor) -> a
    android.support.v4.app.NotificationCompat$BigTextStyle bigText(java.lang.CharSequence) -> a
android.support.v4.app.NotificationCompat$Builder -> a.b.a.a.z$c:
    android.content.Context mContext -> a
    int mPriority -> j
    android.app.Notification mNotification -> M
    android.widget.RemoteViews mContentView -> E
    java.lang.CharSequence mContentTitle -> b
    boolean mShowWhen -> k
    int mBadgeIcon -> I
    android.support.v4.app.NotificationCompat$Style mStyle -> m
    android.widget.RemoteViews mTickerView -> f
    boolean mLocalOnly -> w
    android.widget.RemoteViews mHeadsUpContentView -> G
    java.lang.CharSequence mContentInfo -> h
    int mVisibility -> C
    android.app.PendingIntent mFullScreenIntent -> e
    java.lang.CharSequence[] mRemoteInputHistory -> o
    java.util.ArrayList mPeople -> N
    boolean mColorizedSet -> y
    java.lang.String mCategory -> z
    int mProgress -> q
    android.os.Bundle mExtras -> A
    int mGroupAlertBehavior -> L
    java.lang.String mChannelId -> H
    long mTimeout -> K
    java.lang.String mShortcutId -> J
    java.lang.CharSequence mContentText -> c
    int mNumber -> i
    boolean mUseChronometer -> l
    android.graphics.Bitmap mLargeIcon -> g
    android.widget.RemoteViews mBigContentView -> F
    boolean mColorized -> x
    java.lang.String mGroupKey -> s
    int mColor -> B
    boolean mProgressIndeterminate -> r
    java.lang.String mSortKey -> u
    android.app.PendingIntent mContentIntent -> d
    boolean mGroupSummary -> t
    java.lang.CharSequence mSubText -> n
    java.util.ArrayList mActions -> v
    android.app.Notification mPublicVersion -> D
    int mProgressMax -> p
    int access$000(android.support.v4.app.NotificationCompat$Builder) -> a
    android.support.v4.app.NotificationCompat$Builder addAction(int,java.lang.CharSequence,android.app.PendingIntent) -> a
    android.app.Notification build() -> a
    android.support.v4.app.NotificationCompat$Builder setAutoCancel(boolean) -> a
    android.support.v4.app.NotificationCompat$Builder setChannelId(java.lang.String) -> a
    android.support.v4.app.NotificationCompat$Builder setContentIntent(android.app.PendingIntent) -> a
    android.support.v4.app.NotificationCompat$Builder setContentText(java.lang.CharSequence) -> a
    void setFlag(int,boolean) -> a
    android.support.v4.app.NotificationCompat$Builder setPriority(int) -> a
    android.support.v4.app.NotificationCompat$Builder setStyle(android.support.v4.app.NotificationCompat$Style) -> a
    android.support.v4.app.NotificationCompat$Builder setWhen(long) -> a
    android.support.v4.app.NotificationCompat$BuilderExtender getExtender() -> b
    android.support.v4.app.NotificationCompat$Builder setContentTitle(java.lang.CharSequence) -> b
    android.support.v4.app.NotificationCompat$Builder setLocalOnly(boolean) -> b
    android.support.v4.app.NotificationCompat$Builder setSmallIcon(int) -> b
    android.support.v4.app.NotificationCompat$Builder setTicker(java.lang.CharSequence) -> c
    java.lang.CharSequence limitCharSequenceLength(java.lang.CharSequence) -> d
android.support.v4.app.NotificationCompat$BuilderExtender -> a.b.a.a.z$d:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder,android.support.v4.app.NotificationBuilderWithBuilderAccessor) -> a
android.support.v4.app.NotificationCompat$NotificationCompatApi16Impl -> a.b.a.a.z$e:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder,android.support.v4.app.NotificationCompat$BuilderExtender) -> a
android.support.v4.app.NotificationCompat$NotificationCompatApi19Impl -> a.b.a.a.z$f:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder,android.support.v4.app.NotificationCompat$BuilderExtender) -> a
android.support.v4.app.NotificationCompat$NotificationCompatApi20Impl -> a.b.a.a.z$g:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder,android.support.v4.app.NotificationCompat$BuilderExtender) -> a
android.support.v4.app.NotificationCompat$NotificationCompatApi21Impl -> a.b.a.a.z$h:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder,android.support.v4.app.NotificationCompat$BuilderExtender) -> a
android.support.v4.app.NotificationCompat$NotificationCompatApi24Impl -> a.b.a.a.z$i:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder,android.support.v4.app.NotificationCompat$BuilderExtender) -> a
android.support.v4.app.NotificationCompat$NotificationCompatApi26Impl -> a.b.a.a.z$j:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder,android.support.v4.app.NotificationCompat$BuilderExtender) -> a
android.support.v4.app.NotificationCompat$NotificationCompatBaseImpl -> a.b.a.a.z$k:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder,android.support.v4.app.NotificationCompat$BuilderExtender) -> a
android.support.v4.app.NotificationCompat$NotificationCompatBaseImpl$BuilderBase -> a.b.a.a.z$k$a:
    android.app.Notification$Builder mBuilder -> a
    android.app.Notification build() -> a
    android.app.Notification$Builder getBuilder() -> b
android.support.v4.app.NotificationCompat$NotificationCompatImpl -> a.b.a.a.z$l:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder,android.support.v4.app.NotificationCompat$BuilderExtender) -> a
android.support.v4.app.NotificationCompat$Style -> a.b.a.a.z$m:
    java.lang.CharSequence mBigContentTitle -> b
    java.lang.CharSequence mSummaryText -> c
    android.support.v4.app.NotificationCompat$Builder mBuilder -> a
    boolean mSummaryTextSet -> d
    void addCompatExtras(android.os.Bundle) -> a
    void apply(android.support.v4.app.NotificationBuilderWithBuilderAccessor) -> a
    void setBuilder(android.support.v4.app.NotificationCompat$Builder) -> a
    android.widget.RemoteViews makeBigContentView(android.support.v4.app.NotificationBuilderWithBuilderAccessor) -> b
    android.widget.RemoteViews makeContentView(android.support.v4.app.NotificationBuilderWithBuilderAccessor) -> c
    android.widget.RemoteViews makeHeadsUpContentView(android.support.v4.app.NotificationBuilderWithBuilderAccessor) -> d
android.support.v4.app.NotificationCompatApi20 -> a.b.a.a.a0:
    void addAction(android.app.Notification$Builder,android.support.v4.app.NotificationCompatBase$Action) -> a
android.support.v4.app.NotificationCompatApi20$Builder -> a.b.a.a.a0$a:
    android.widget.RemoteViews mBigContentView -> d
    android.os.Bundle mExtras -> b
    android.widget.RemoteViews mContentView -> c
    int mGroupAlertBehavior -> e
    android.app.Notification$Builder b -> a
    void addAction(android.support.v4.app.NotificationCompatBase$Action) -> a
    android.app.Notification build() -> a
    void removeSoundAndVibration(android.app.Notification) -> a
    android.app.Notification$Builder getBuilder() -> b
android.support.v4.app.NotificationCompatApi21$Builder -> a.b.a.a.b0:
    android.widget.RemoteViews mBigContentView -> d
    android.os.Bundle mExtras -> b
    android.widget.RemoteViews mHeadsUpContentView -> e
    android.widget.RemoteViews mContentView -> c
    int mGroupAlertBehavior -> f
    android.app.Notification$Builder b -> a
    void addAction(android.support.v4.app.NotificationCompatBase$Action) -> a
    android.app.Notification build() -> a
    void removeSoundAndVibration(android.app.Notification) -> a
    android.app.Notification$Builder getBuilder() -> b
android.support.v4.app.NotificationCompatApi24 -> a.b.a.a.c0:
    void addAction(android.app.Notification$Builder,android.support.v4.app.NotificationCompatBase$Action) -> a
android.support.v4.app.NotificationCompatApi24$Builder -> a.b.a.a.c0$a:
    android.app.Notification$Builder b -> a
    int mGroupAlertBehavior -> b
    void addAction(android.support.v4.app.NotificationCompatBase$Action) -> a
    android.app.Notification build() -> a
    void removeSoundAndVibration(android.app.Notification) -> a
    android.app.Notification$Builder getBuilder() -> b
android.support.v4.app.NotificationCompatApi26$Builder -> a.b.a.a.d0:
    android.app.Notification$Builder mB -> a
    void addAction(android.support.v4.app.NotificationCompatBase$Action) -> a
    android.app.Notification build() -> a
    android.app.Notification$Builder getBuilder() -> b
android.support.v4.app.NotificationCompatBase$Action -> a.b.a.a.e0:
    android.app.PendingIntent getActionIntent() -> a
    boolean getAllowGeneratedReplies() -> b
    android.support.v4.app.RemoteInputCompatBase$RemoteInput[] getDataOnlyRemoteInputs() -> c
    android.os.Bundle getExtras() -> d
    int getIcon() -> e
    android.support.v4.app.RemoteInputCompatBase$RemoteInput[] getRemoteInputs() -> f
    java.lang.CharSequence getTitle() -> g
android.support.v4.app.NotificationCompatBase$Action$Factory -> a.b.a.a.e0$a:
android.support.v4.app.NotificationCompatJellybean -> a.b.a.a.f0:
    java.lang.reflect.Field sExtrasField -> b
    java.lang.Object sExtrasLock -> a
    boolean sExtrasFieldAccessFailed -> c
    void addBigTextStyle(android.support.v4.app.NotificationBuilderWithBuilderAccessor,java.lang.CharSequence,boolean,java.lang.CharSequence,java.lang.CharSequence) -> a
    android.util.SparseArray buildActionExtrasMap(java.util.List) -> a
    android.os.Bundle getExtras(android.app.Notification) -> a
    android.os.Bundle writeActionAndGetExtras(android.app.Notification$Builder,android.support.v4.app.NotificationCompatBase$Action) -> a
android.support.v4.app.NotificationCompatJellybean$Builder -> a.b.a.a.f0$a:
    android.widget.RemoteViews mContentView -> d
    android.os.Bundle mExtras -> b
    android.widget.RemoteViews mBigContentView -> e
    java.util.List mActionExtrasList -> c
    android.app.Notification$Builder b -> a
    void addAction(android.support.v4.app.NotificationCompatBase$Action) -> a
    android.app.Notification build() -> a
    android.app.Notification$Builder getBuilder() -> b
android.support.v4.app.NotificationCompatKitKat$Builder -> a.b.a.a.g0:
    android.widget.RemoteViews mContentView -> d
    android.os.Bundle mExtras -> b
    android.widget.RemoteViews mBigContentView -> e
    java.util.List mActionExtrasList -> c
    android.app.Notification$Builder b -> a
    void addAction(android.support.v4.app.NotificationCompatBase$Action) -> a
    android.app.Notification build() -> a
    android.app.Notification$Builder getBuilder() -> b
android.support.v4.app.OneShotPreDrawListener -> a.b.a.a.h0:
    java.lang.Runnable mRunnable -> c
    android.view.View mView -> a
    android.view.ViewTreeObserver mViewTreeObserver -> b
    android.support.v4.app.OneShotPreDrawListener add(android.view.View,java.lang.Runnable) -> a
    void removeListener() -> a
android.support.v4.app.RemoteInput -> a.b.a.a.i0:
android.support.v4.app.RemoteInput$1 -> a.b.a.a.i0$a:
android.support.v4.app.RemoteInput$Impl -> a.b.a.a.i0$b:
android.support.v4.app.RemoteInput$ImplApi20 -> a.b.a.a.i0$c:
android.support.v4.app.RemoteInput$ImplBase -> a.b.a.a.i0$d:
android.support.v4.app.RemoteInput$ImplJellybean -> a.b.a.a.i0$e:
android.support.v4.app.RemoteInputCompatApi20 -> a.b.a.a.j0:
    android.app.RemoteInput[] fromCompat(android.support.v4.app.RemoteInputCompatBase$RemoteInput[]) -> a
android.support.v4.app.RemoteInputCompatBase$RemoteInput -> a.b.a.a.k0:
    boolean getAllowFreeFormInput() -> a
    java.util.Set getAllowedDataTypes() -> b
    java.lang.CharSequence[] getChoices() -> c
    android.os.Bundle getExtras() -> d
    java.lang.CharSequence getLabel() -> e
    java.lang.String getResultKey() -> f
android.support.v4.app.RemoteInputCompatBase$RemoteInput$Factory -> a.b.a.a.k0$a:
android.support.v4.app.RemoteInputCompatJellybean -> a.b.a.a.l0:
    android.os.Bundle toBundle(android.support.v4.app.RemoteInputCompatBase$RemoteInput) -> a
    android.os.Bundle[] toBundleArray(android.support.v4.app.RemoteInputCompatBase$RemoteInput[]) -> a
android.support.v4.app.SharedElementCallback -> a.b.a.a.m0:
    void onMapSharedElements(java.util.List,java.util.Map) -> a
    void onSharedElementEnd(java.util.List,java.util.List,java.util.List) -> a
    void onSharedElementStart(java.util.List,java.util.List,java.util.List) -> b
android.support.v4.app.SuperNotCalledException -> a.b.a.a.n0:
android.support.v4.app.SupportActivity -> a.b.a.a.o0:
    android.arch.lifecycle.LifecycleRegistry mLifecycleRegistry -> a
    android.arch.lifecycle.Lifecycle getLifecycle() -> a
android.support.v4.content.Loader -> a.b.a.b.a:
    java.lang.String dataToString(java.lang.Object) -> a
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    void registerListener(int,android.support.v4.content.Loader$OnLoadCompleteListener) -> a
    void reset() -> a
    void unregisterListener(android.support.v4.content.Loader$OnLoadCompleteListener) -> a
    void startLoading() -> b
android.support.v4.content.Loader$OnLoadCanceledListener -> a.b.a.b.a$a:
android.support.v4.content.Loader$OnLoadCompleteListener -> a.b.a.b.a$b:
android.support.v4.media.MediaBrowserCompat$CustomActionCallback -> android.support.v4.media.MediaBrowserCompat$a:
    void onError(java.lang.String,android.os.Bundle,android.os.Bundle) -> a
    void onProgressUpdate(java.lang.String,android.os.Bundle,android.os.Bundle) -> b
    void onResult(java.lang.String,android.os.Bundle,android.os.Bundle) -> c
android.support.v4.media.MediaBrowserCompat$CustomActionResultReceiver -> android.support.v4.media.MediaBrowserCompat$CustomActionResultReceiver:
    android.os.Bundle mExtras -> d
    java.lang.String mAction -> c
    android.support.v4.media.MediaBrowserCompat$CustomActionCallback mCallback -> e
    void onReceiveResult(int,android.os.Bundle) -> a
android.support.v4.media.MediaBrowserCompat$ItemCallback -> android.support.v4.media.MediaBrowserCompat$b:
    void onError(java.lang.String) -> a
    void onItemLoaded(android.support.v4.media.MediaBrowserCompat$MediaItem) -> a
android.support.v4.media.MediaBrowserCompat$ItemReceiver -> android.support.v4.media.MediaBrowserCompat$ItemReceiver:
    android.support.v4.media.MediaBrowserCompat$ItemCallback mCallback -> d
    java.lang.String mMediaId -> c
    void onReceiveResult(int,android.os.Bundle) -> a
android.support.v4.media.MediaBrowserCompat$MediaItem -> android.support.v4.media.MediaBrowserCompat$MediaItem:
    android.support.v4.media.MediaDescriptionCompat mDescription -> b
    int mFlags -> a
android.support.v4.media.MediaBrowserCompat$MediaItem$1 -> android.support.v4.media.MediaBrowserCompat$MediaItem$a:
android.support.v4.media.MediaBrowserCompat$SearchCallback -> android.support.v4.media.MediaBrowserCompat$c:
    void onError(java.lang.String,android.os.Bundle) -> a
    void onSearchResult(java.lang.String,android.os.Bundle,java.util.List) -> a
android.support.v4.media.MediaBrowserCompat$SearchResultReceiver -> android.support.v4.media.MediaBrowserCompat$SearchResultReceiver:
    android.os.Bundle mExtras -> d
    java.lang.String mQuery -> c
    android.support.v4.media.MediaBrowserCompat$SearchCallback mCallback -> e
    void onReceiveResult(int,android.os.Bundle) -> a
android.support.v4.media.MediaDescriptionCompat -> android.support.v4.media.MediaDescriptionCompat:
    android.net.Uri mMediaUri -> h
    android.net.Uri mIconUri -> f
    java.lang.Object mDescriptionObj -> i
    java.lang.CharSequence mTitle -> b
    java.lang.CharSequence mSubtitle -> c
    java.lang.CharSequence mDescription -> d
    android.os.Bundle mExtras -> g
    java.lang.String mMediaId -> a
    android.graphics.Bitmap mIcon -> e
    android.support.v4.media.MediaDescriptionCompat fromMediaDescription(java.lang.Object) -> a
    java.lang.Object getMediaDescription() -> a
android.support.v4.media.MediaDescriptionCompat$1 -> android.support.v4.media.MediaDescriptionCompat$a:
android.support.v4.media.MediaDescriptionCompat$Builder -> android.support.v4.media.MediaDescriptionCompat$b:
    android.net.Uri mMediaUri -> h
    android.net.Uri mIconUri -> f
    java.lang.CharSequence mTitle -> b
    java.lang.CharSequence mSubtitle -> c
    java.lang.CharSequence mDescription -> d
    android.os.Bundle mExtras -> g
    java.lang.String mMediaId -> a
    android.graphics.Bitmap mIcon -> e
    android.support.v4.media.MediaDescriptionCompat build() -> a
    android.support.v4.media.MediaDescriptionCompat$Builder setDescription(java.lang.CharSequence) -> a
    android.support.v4.media.MediaDescriptionCompat$Builder setExtras(android.os.Bundle) -> a
    android.support.v4.media.MediaDescriptionCompat$Builder setIconBitmap(android.graphics.Bitmap) -> a
    android.support.v4.media.MediaDescriptionCompat$Builder setIconUri(android.net.Uri) -> a
    android.support.v4.media.MediaDescriptionCompat$Builder setMediaId(java.lang.String) -> a
    android.support.v4.media.MediaDescriptionCompat$Builder setMediaUri(android.net.Uri) -> b
    android.support.v4.media.MediaDescriptionCompat$Builder setSubtitle(java.lang.CharSequence) -> b
    android.support.v4.media.MediaDescriptionCompat$Builder setTitle(java.lang.CharSequence) -> c
android.support.v4.media.MediaDescriptionCompatApi21 -> android.support.v4.media.a:
    java.lang.Object fromParcel(android.os.Parcel) -> a
    java.lang.CharSequence getDescription(java.lang.Object) -> a
    void writeToParcel(java.lang.Object,android.os.Parcel,int) -> a
    android.os.Bundle getExtras(java.lang.Object) -> b
    android.graphics.Bitmap getIconBitmap(java.lang.Object) -> c
    android.net.Uri getIconUri(java.lang.Object) -> d
    java.lang.String getMediaId(java.lang.Object) -> e
    java.lang.CharSequence getSubtitle(java.lang.Object) -> f
    java.lang.CharSequence getTitle(java.lang.Object) -> g
android.support.v4.media.MediaDescriptionCompatApi21$Builder -> android.support.v4.media.a$a:
    java.lang.Object build(java.lang.Object) -> a
    java.lang.Object newInstance() -> a
    void setDescription(java.lang.Object,java.lang.CharSequence) -> a
    void setExtras(java.lang.Object,android.os.Bundle) -> a
    void setIconBitmap(java.lang.Object,android.graphics.Bitmap) -> a
    void setIconUri(java.lang.Object,android.net.Uri) -> a
    void setMediaId(java.lang.Object,java.lang.String) -> a
    void setSubtitle(java.lang.Object,java.lang.CharSequence) -> b
    void setTitle(java.lang.Object,java.lang.CharSequence) -> c
android.support.v4.media.MediaDescriptionCompatApi23 -> android.support.v4.media.b:
    android.net.Uri getMediaUri(java.lang.Object) -> h
android.support.v4.media.MediaDescriptionCompatApi23$Builder -> android.support.v4.media.b$a:
    void setMediaUri(java.lang.Object,android.net.Uri) -> b
android.support.v4.media.MediaMetadataCompat -> android.support.v4.media.MediaMetadataCompat:
    android.support.v4.util.ArrayMap METADATA_KEYS_TYPE -> c
    android.os.Bundle mBundle -> a
    java.lang.Object mMetadataObj -> b
    android.support.v4.media.MediaMetadataCompat fromMediaMetadata(java.lang.Object) -> a
android.support.v4.media.MediaMetadataCompat$1 -> android.support.v4.media.MediaMetadataCompat$a:
android.support.v4.media.MediaMetadataCompatApi21 -> android.support.v4.media.c:
    void writeToParcel(java.lang.Object,android.os.Parcel,int) -> a
android.support.v4.media.RatingCompat -> android.support.v4.media.RatingCompat:
    float mRatingValue -> b
    int mRatingStyle -> a
android.support.v4.media.RatingCompat$1 -> android.support.v4.media.RatingCompat$a:
android.support.v4.media.session.IMediaControllerCallback -> android.support.v4.media.session.a:
    void onEvent(java.lang.String,android.os.Bundle) -> a
    void onExtrasChanged(android.os.Bundle) -> a
    void onMetadataChanged(android.support.v4.media.MediaMetadataCompat) -> a
    void onPlaybackStateChanged(android.support.v4.media.session.PlaybackStateCompat) -> a
    void onQueueChanged(java.util.List) -> a
    void onQueueTitleChanged(java.lang.CharSequence) -> a
    void onShuffleModeChanged(int) -> a
    void onShuffleModeChangedDeprecated(boolean) -> a
    void onVolumeInfoChanged(android.support.v4.media.session.ParcelableVolumeInfo) -> a
    void onCaptioningEnabledChanged(boolean) -> b
    void onRepeatModeChanged(int) -> b
    void onSessionDestroyed() -> b
android.support.v4.media.session.IMediaControllerCallback$Stub -> android.support.v4.media.session.a$a:
android.support.v4.media.session.IMediaSession -> android.support.v4.media.session.b:
    void registerCallbackListener(android.support.v4.media.session.IMediaControllerCallback) -> a
android.support.v4.media.session.IMediaSession$Stub -> android.support.v4.media.session.b$a:
    android.support.v4.media.session.IMediaSession asInterface(android.os.IBinder) -> a
android.support.v4.media.session.IMediaSession$Stub$Proxy -> android.support.v4.media.session.b$a$a:
    android.os.IBinder mRemote -> a
    void registerCallbackListener(android.support.v4.media.session.IMediaControllerCallback) -> a
android.support.v4.media.session.MediaControllerCompat$Callback -> android.support.v4.media.session.c:
    android.support.v4.media.session.MediaControllerCompat$Callback$MessageHandler mHandler -> a
    boolean mHasExtraCallback -> b
    void onAudioInfoChanged(android.support.v4.media.session.MediaControllerCompat$PlaybackInfo) -> a
    void onExtrasChanged(android.os.Bundle) -> a
    void onMetadataChanged(android.support.v4.media.MediaMetadataCompat) -> a
    void onPlaybackStateChanged(android.support.v4.media.session.PlaybackStateCompat) -> a
    void onQueueChanged(java.util.List) -> a
    void onQueueTitleChanged(java.lang.CharSequence) -> a
    void onSessionDestroyed() -> a
    void onSessionEvent(java.lang.String,android.os.Bundle) -> a
    void postToHandler(int,java.lang.Object,android.os.Bundle) -> a
android.support.v4.media.session.MediaControllerCompat$Callback$MessageHandler -> android.support.v4.media.session.c$a:
android.support.v4.media.session.MediaControllerCompat$Callback$StubApi21 -> android.support.v4.media.session.c$b:
    java.lang.ref.WeakReference mCallback -> a
    void onAudioInfoChanged(int,int,int,int,int) -> a
    void onExtrasChanged(android.os.Bundle) -> a
    void onPlaybackStateChanged(java.lang.Object) -> a
    void onQueueChanged(java.util.List) -> a
    void onQueueTitleChanged(java.lang.CharSequence) -> a
    void onSessionEvent(java.lang.String,android.os.Bundle) -> a
    void onMetadataChanged(java.lang.Object) -> b
    void onSessionDestroyed() -> b
android.support.v4.media.session.MediaControllerCompat$Callback$StubCompat -> android.support.v4.media.session.c$c:
    java.lang.ref.WeakReference mCallback -> a
    void onEvent(java.lang.String,android.os.Bundle) -> a
    void onExtrasChanged(android.os.Bundle) -> a
    void onMetadataChanged(android.support.v4.media.MediaMetadataCompat) -> a
    void onPlaybackStateChanged(android.support.v4.media.session.PlaybackStateCompat) -> a
    void onQueueChanged(java.util.List) -> a
    void onQueueTitleChanged(java.lang.CharSequence) -> a
    void onShuffleModeChanged(int) -> a
    void onShuffleModeChangedDeprecated(boolean) -> a
    void onVolumeInfoChanged(android.support.v4.media.session.ParcelableVolumeInfo) -> a
    void onCaptioningEnabledChanged(boolean) -> b
    void onRepeatModeChanged(int) -> b
    void onSessionDestroyed() -> b
android.support.v4.media.session.MediaControllerCompat$MediaControllerImpl -> android.support.v4.media.session.d:
android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21 -> android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21:
    java.util.List mPendingCallbacks -> a
    android.support.v4.media.session.IMediaSession mExtraBinder -> b
    java.util.HashMap mCallbackMap -> c
    android.support.v4.media.session.IMediaSession access$202(android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21,android.support.v4.media.session.IMediaSession) -> a
    void access$300(android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21) -> a
    void processPendingCallbacks() -> a
android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21$ExtraBinderRequestResultReceiver -> android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21$ExtraBinderRequestResultReceiver:
    java.lang.ref.WeakReference mMediaControllerImpl -> a
android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21$ExtraCallback -> android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21$a:
    void onExtrasChanged(android.os.Bundle) -> a
    void onMetadataChanged(android.support.v4.media.MediaMetadataCompat) -> a
    void onQueueChanged(java.util.List) -> a
    void onQueueTitleChanged(java.lang.CharSequence) -> a
    void onVolumeInfoChanged(android.support.v4.media.session.ParcelableVolumeInfo) -> a
    void onSessionDestroyed() -> b
android.support.v4.media.session.MediaControllerCompat$PlaybackInfo -> android.support.v4.media.session.e:
android.support.v4.media.session.MediaControllerCompatApi21 -> android.support.v4.media.session.f:
    java.lang.Object createCallback(android.support.v4.media.session.MediaControllerCompatApi21$Callback) -> a
android.support.v4.media.session.MediaControllerCompatApi21$Callback -> android.support.v4.media.session.f$a:
    void onAudioInfoChanged(int,int,int,int,int) -> a
    void onExtrasChanged(android.os.Bundle) -> a
    void onPlaybackStateChanged(java.lang.Object) -> a
    void onQueueChanged(java.util.List) -> a
    void onQueueTitleChanged(java.lang.CharSequence) -> a
    void onSessionEvent(java.lang.String,android.os.Bundle) -> a
    void onMetadataChanged(java.lang.Object) -> b
    void onSessionDestroyed() -> b
android.support.v4.media.session.MediaControllerCompatApi21$CallbackProxy -> android.support.v4.media.session.f$b:
    android.support.v4.media.session.MediaControllerCompatApi21$Callback mCallback -> a
android.support.v4.media.session.MediaControllerCompatApi21$PlaybackInfo -> android.support.v4.media.session.f$c:
    android.media.AudioAttributes getAudioAttributes(java.lang.Object) -> a
    int toLegacyStreamType(android.media.AudioAttributes) -> a
    int getLegacyAudioStream(java.lang.Object) -> b
android.support.v4.media.session.MediaSessionCompat$QueueItem -> android.support.v4.media.session.MediaSessionCompat$QueueItem:
    android.support.v4.media.MediaDescriptionCompat mDescription -> a
    long mId -> b
    android.support.v4.media.session.MediaSessionCompat$QueueItem fromQueueItem(java.lang.Object) -> a
    java.util.List fromQueueItemList(java.util.List) -> a
android.support.v4.media.session.MediaSessionCompat$QueueItem$1 -> android.support.v4.media.session.MediaSessionCompat$QueueItem$a:
android.support.v4.media.session.MediaSessionCompat$ResultReceiverWrapper -> android.support.v4.media.session.MediaSessionCompat$ResultReceiverWrapper:
    android.os.ResultReceiver mResultReceiver -> a
android.support.v4.media.session.MediaSessionCompat$ResultReceiverWrapper$1 -> android.support.v4.media.session.MediaSessionCompat$ResultReceiverWrapper$a:
android.support.v4.media.session.MediaSessionCompat$Token -> android.support.v4.media.session.MediaSessionCompat$Token:
    java.lang.Object mInner -> a
android.support.v4.media.session.MediaSessionCompat$Token$1 -> android.support.v4.media.session.MediaSessionCompat$Token$a:
android.support.v4.media.session.MediaSessionCompatApi21$QueueItem -> android.support.v4.media.session.g:
    java.lang.Object getDescription(java.lang.Object) -> a
    long getQueueId(java.lang.Object) -> b
android.support.v4.media.session.ParcelableVolumeInfo -> android.support.v4.media.session.ParcelableVolumeInfo:
    int maxVolume -> d
    int currentVolume -> e
    int audioStream -> b
    int controlType -> c
    int volumeType -> a
android.support.v4.media.session.ParcelableVolumeInfo$1 -> android.support.v4.media.session.ParcelableVolumeInfo$a:
android.support.v4.media.session.PlaybackStateCompat -> android.support.v4.media.session.PlaybackStateCompat:
    long mActiveItemId -> j
    long mActions -> e
    long mUpdateTime -> h
    long mPosition -> b
    float mSpeed -> d
    int mErrorCode -> f
    java.util.List mCustomActions -> i
    long mBufferedPosition -> c
    java.lang.CharSequence mErrorMessage -> g
    android.os.Bundle mExtras -> k
    int mState -> a
    android.support.v4.media.session.PlaybackStateCompat fromPlaybackState(java.lang.Object) -> a
android.support.v4.media.session.PlaybackStateCompat$1 -> android.support.v4.media.session.PlaybackStateCompat$a:
android.support.v4.media.session.PlaybackStateCompat$CustomAction -> android.support.v4.media.session.PlaybackStateCompat$CustomAction:
    java.lang.CharSequence mName -> b
    android.os.Bundle mExtras -> d
    java.lang.String mAction -> a
    int mIcon -> c
    android.support.v4.media.session.PlaybackStateCompat$CustomAction fromCustomAction(java.lang.Object) -> a
android.support.v4.media.session.PlaybackStateCompat$CustomAction$1 -> android.support.v4.media.session.PlaybackStateCompat$CustomAction$a:
android.support.v4.media.session.PlaybackStateCompatApi21 -> android.support.v4.media.session.h:
    long getActions(java.lang.Object) -> a
    long getActiveQueueItemId(java.lang.Object) -> b
    long getBufferedPosition(java.lang.Object) -> c
    java.util.List getCustomActions(java.lang.Object) -> d
    java.lang.CharSequence getErrorMessage(java.lang.Object) -> e
    long getLastPositionUpdateTime(java.lang.Object) -> f
    float getPlaybackSpeed(java.lang.Object) -> g
    long getPosition(java.lang.Object) -> h
    int getState(java.lang.Object) -> i
android.support.v4.media.session.PlaybackStateCompatApi21$CustomAction -> android.support.v4.media.session.h$a:
    java.lang.String getAction(java.lang.Object) -> a
    android.os.Bundle getExtras(java.lang.Object) -> b
    int getIcon(java.lang.Object) -> c
    java.lang.CharSequence getName(java.lang.Object) -> d
android.support.v4.media.session.PlaybackStateCompatApi22 -> android.support.v4.media.session.i:
    android.os.Bundle getExtras(java.lang.Object) -> a
android.support.v4.os.IResultReceiver -> a.b.a.c.a:
    void send(int,android.os.Bundle) -> a
android.support.v4.os.IResultReceiver$Stub -> a.b.a.c.a$a:
    android.support.v4.os.IResultReceiver asInterface(android.os.IBinder) -> a
android.support.v4.os.IResultReceiver$Stub$Proxy -> a.b.a.c.a$a$a:
    android.os.IBinder mRemote -> a
android.support.v4.os.ResultReceiver -> a.b.a.c.b:
    android.support.v4.os.IResultReceiver mReceiver -> b
    android.os.Handler mHandler -> a
    void onReceiveResult(int,android.os.Bundle) -> a
android.support.v4.os.ResultReceiver$1 -> a.b.a.c.b$a:
android.support.v4.os.ResultReceiver$MyResultReceiver -> a.b.a.c.b$b:
    android.support.v4.os.ResultReceiver this$0 -> a
    void send(int,android.os.Bundle) -> a
android.support.v4.os.ResultReceiver$MyRunnable -> a.b.a.c.b$c:
    android.os.Bundle mResultData -> b
    android.support.v4.os.ResultReceiver this$0 -> c
    int mResultCode -> a
android.support.v4.util.ArrayMap -> a.b.a.d.a:
    android.support.v4.util.MapCollections mCollections -> h
    boolean retainAll(java.util.Collection) -> a
    android.support.v4.util.MapCollections getCollection() -> b
android.support.v4.util.ArrayMap$1 -> a.b.a.d.a$a:
    android.support.v4.util.ArrayMap this$0 -> d
    void colClear() -> a
    java.lang.Object colGetEntry(int,int) -> a
    int colIndexOfKey(java.lang.Object) -> a
    void colPut(java.lang.Object,java.lang.Object) -> a
    void colRemoveAt(int) -> a
    java.lang.Object colSetValue(int,java.lang.Object) -> a
    java.util.Map colGetMap() -> b
    int colIndexOfValue(java.lang.Object) -> b
    int colGetSize() -> c
android.support.v4.util.ArraySet -> a.b.a.d.b:
    int[] INT -> f
    android.support.v4.util.MapCollections mCollections -> e
    java.lang.Object[] mArray -> c
    int[] mHashes -> b
    int sTwiceBaseCacheSize -> k
    int sBaseCacheSize -> i
    java.lang.Object[] sTwiceBaseCache -> j
    int mSize -> d
    java.lang.Object[] sBaseCache -> h
    boolean mIdentityHashCode -> a
    java.lang.Object[] OBJECT -> g
    void ensureCapacity(int) -> a
    void freeArrays(int[],java.lang.Object[],int) -> a
    android.support.v4.util.MapCollections getCollection() -> a
    int indexOf(java.lang.Object) -> a
    int indexOf(java.lang.Object,int) -> a
    int indexOfNull() -> b
    java.lang.Object removeAt(int) -> b
    java.lang.Object valueAt(int) -> c
    void allocArrays(int) -> d
android.support.v4.util.ArraySet$1 -> a.b.a.d.b$a:
    android.support.v4.util.ArraySet this$0 -> d
    void colClear() -> a
    java.lang.Object colGetEntry(int,int) -> a
    int colIndexOfKey(java.lang.Object) -> a
    void colPut(java.lang.Object,java.lang.Object) -> a
    void colRemoveAt(int) -> a
    java.lang.Object colSetValue(int,java.lang.Object) -> a
    java.util.Map colGetMap() -> b
    int colIndexOfValue(java.lang.Object) -> b
    int colGetSize() -> c
android.support.v4.util.ContainerHelpers -> a.b.a.d.c:
    java.lang.Object[] EMPTY_OBJECTS -> b
    int[] EMPTY_INTS -> a
    int binarySearch(int[],int,int) -> a
    boolean equal(java.lang.Object,java.lang.Object) -> a
    int idealByteArraySize(int) -> a
    int idealIntArraySize(int) -> b
android.support.v4.util.DebugUtils -> a.b.a.d.d:
    void buildShortClassTag(java.lang.Object,java.lang.StringBuilder) -> a
android.support.v4.util.LogWriter -> a.b.a.d.e:
    java.lang.StringBuilder mBuilder -> b
    java.lang.String mTag -> a
    void flushBuilder() -> a
android.support.v4.util.MapCollections -> a.b.a.d.f:
    android.support.v4.util.MapCollections$KeySet mKeySet -> b
    android.support.v4.util.MapCollections$EntrySet mEntrySet -> a
    android.support.v4.util.MapCollections$ValuesCollection mValues -> c
    void colClear() -> a
    java.lang.Object colGetEntry(int,int) -> a
    int colIndexOfKey(java.lang.Object) -> a
    void colPut(java.lang.Object,java.lang.Object) -> a
    void colRemoveAt(int) -> a
    java.lang.Object colSetValue(int,java.lang.Object) -> a
    boolean containsAllHelper(java.util.Map,java.util.Collection) -> a
    boolean equalsSetHelper(java.util.Set,java.lang.Object) -> a
    java.lang.Object[] toArrayHelper(java.lang.Object[],int) -> a
    java.util.Map colGetMap() -> b
    int colIndexOfValue(java.lang.Object) -> b
    boolean removeAllHelper(java.util.Map,java.util.Collection) -> b
    java.lang.Object[] toArrayHelper(int) -> b
    int colGetSize() -> c
    boolean retainAllHelper(java.util.Map,java.util.Collection) -> c
    java.util.Set getEntrySet() -> d
    java.util.Set getKeySet() -> e
    java.util.Collection getValues() -> f
android.support.v4.util.MapCollections$ArrayIterator -> a.b.a.d.f$a:
    android.support.v4.util.MapCollections this$0 -> e
    int mSize -> b
    int mIndex -> c
    int mOffset -> a
    boolean mCanRemove -> d
android.support.v4.util.MapCollections$EntrySet -> a.b.a.d.f$b:
    android.support.v4.util.MapCollections this$0 -> a
    boolean add(java.util.Map$Entry) -> a
android.support.v4.util.MapCollections$KeySet -> a.b.a.d.f$c:
    android.support.v4.util.MapCollections this$0 -> a
android.support.v4.util.MapCollections$MapIterator -> a.b.a.d.f$d:
    android.support.v4.util.MapCollections this$0 -> d
    int mIndex -> b
    boolean mEntryValid -> c
    int mEnd -> a
android.support.v4.util.MapCollections$ValuesCollection -> a.b.a.d.f$e:
    android.support.v4.util.MapCollections this$0 -> a
android.support.v4.util.Pair -> a.b.a.d.g:
    java.lang.Object second -> b
    java.lang.Object first -> a
    boolean objectsEqual(java.lang.Object,java.lang.Object) -> a
android.support.v4.util.SimpleArrayMap -> a.b.a.d.h:
    java.lang.Object[] mBaseCache -> d
    java.lang.Object[] mArray -> b
    int mTwiceBaseCacheSize -> g
    int mBaseCacheSize -> e
    int[] mHashes -> a
    int mSize -> c
    java.lang.Object[] mTwiceBaseCache -> f
    int binarySearchHashes(int[],int,int) -> a
    void ensureCapacity(int) -> a
    void freeArrays(int[],java.lang.Object[],int) -> a
    int indexOf(java.lang.Object,int) -> a
    int indexOfKey(java.lang.Object) -> a
    int indexOfNull() -> a
    java.lang.Object setValueAt(int,java.lang.Object) -> a
    int indexOfValue(java.lang.Object) -> b
    java.lang.Object keyAt(int) -> b
    java.lang.Object removeAt(int) -> c
    java.lang.Object valueAt(int) -> d
    void allocArrays(int) -> e
android.support.v4.util.SparseArrayCompat -> a.b.a.d.i:
    java.lang.Object[] mValues -> c
    int[] mKeys -> b
    java.lang.Object DELETED -> e
    int mSize -> d
    boolean mGarbage -> a
    void clear() -> a
    void delete(int) -> a
    java.lang.Object get(int,java.lang.Object) -> a
    java.lang.Object get(int) -> b
    void put(int,java.lang.Object) -> b
    int size() -> b
    void gc() -> c
    int keyAt(int) -> c
    void remove(int) -> d
    java.lang.Object valueAt(int) -> e
android.support.v4.view.LayoutInflaterCompat -> a.b.a.e.a:
    android.support.v4.view.LayoutInflaterCompat$LayoutInflaterCompatBaseImpl IMPL -> c
    java.lang.reflect.Field sLayoutInflaterFactory2Field -> a
    boolean sCheckedField -> b
    void forceSetFactory2(android.view.LayoutInflater,android.view.LayoutInflater$Factory2) -> a
    void setFactory2(android.view.LayoutInflater,android.view.LayoutInflater$Factory2) -> b
android.support.v4.view.LayoutInflaterCompat$LayoutInflaterCompatApi21Impl -> a.b.a.e.a$a:
    void setFactory2(android.view.LayoutInflater,android.view.LayoutInflater$Factory2) -> a
android.support.v4.view.LayoutInflaterCompat$LayoutInflaterCompatBaseImpl -> a.b.a.e.a$b:
    void setFactory2(android.view.LayoutInflater,android.view.LayoutInflater$Factory2) -> a
android.support.v4.view.ViewCompat -> a.b.a.e.b:
    android.support.v4.view.ViewCompat$ViewCompatBaseImpl IMPL -> a
    java.lang.String getTransitionName(android.view.View) -> a
    boolean hasOverlappingRendering(android.view.View) -> b
    boolean isAttachedToWindow(android.view.View) -> c
android.support.v4.view.ViewCompat$ViewCompatApi15Impl -> a.b.a.e.b$a:
android.support.v4.view.ViewCompat$ViewCompatApi16Impl -> a.b.a.e.b$b:
    boolean hasOverlappingRendering(android.view.View) -> b
android.support.v4.view.ViewCompat$ViewCompatApi17Impl -> a.b.a.e.b$c:
android.support.v4.view.ViewCompat$ViewCompatApi18Impl -> a.b.a.e.b$d:
android.support.v4.view.ViewCompat$ViewCompatApi19Impl -> a.b.a.e.b$e:
    boolean isAttachedToWindow(android.view.View) -> c
android.support.v4.view.ViewCompat$ViewCompatApi21Impl -> a.b.a.e.b$f:
    java.lang.String getTransitionName(android.view.View) -> a
android.support.v4.view.ViewCompat$ViewCompatApi23Impl -> a.b.a.e.b$g:
android.support.v4.view.ViewCompat$ViewCompatApi24Impl -> a.b.a.e.b$h:
android.support.v4.view.ViewCompat$ViewCompatApi26Impl -> a.b.a.e.b$i:
android.support.v4.view.ViewCompat$ViewCompatBaseImpl -> a.b.a.e.b$j:
    java.util.WeakHashMap sTransitionNameMap -> a
    java.lang.String getTransitionName(android.view.View) -> a
    boolean hasOverlappingRendering(android.view.View) -> b
    boolean isAttachedToWindow(android.view.View) -> c
com.badlogic.gdx.AbstractGraphics -> b.a.a.a:
    float getRawDeltaTime() -> l
com.badlogic.gdx.AbstractInput -> b.a.a.b:
    com.badlogic.gdx.utils.IntSet keysToCatch -> c
    boolean[] pressedKeys -> a
    boolean keyJustPressed -> e
    boolean[] justPressedKeys -> b
    int pressedKeyCount -> d
    boolean isKeyPressed(int) -> a
    void setCatchKey(int,boolean) -> a
    boolean isCatchBackKey() -> b
    void setCatchBackKey(boolean) -> b
    boolean isCatchKey(int) -> c
    void setCatchMenuKey(boolean) -> c
com.badlogic.gdx.Application -> b.a.a.c:
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> a
    void debug(java.lang.String,java.lang.String) -> a
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> a
    com.badlogic.gdx.Application$ApplicationType getType() -> a
    void postRunnable(java.lang.Runnable) -> a
    void error(java.lang.String,java.lang.String) -> b
    void exit() -> b
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> b
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> b
    int getVersion() -> c
    void log(java.lang.String,java.lang.String) -> c
    com.badlogic.gdx.Graphics getGraphics() -> f
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> g
    com.badlogic.gdx.utils.Clipboard getClipboard() -> i
com.badlogic.gdx.Application$ApplicationType -> b.a.a.c$a:
    com.badlogic.gdx.Application$ApplicationType Android -> a
    com.badlogic.gdx.Application$ApplicationType HeadlessDesktop -> c
    com.badlogic.gdx.Application$ApplicationType Desktop -> b
    com.badlogic.gdx.Application$ApplicationType[] $VALUES -> g
    com.badlogic.gdx.Application$ApplicationType WebGL -> e
    com.badlogic.gdx.Application$ApplicationType Applet -> d
    com.badlogic.gdx.Application$ApplicationType iOS -> f
com.badlogic.gdx.ApplicationListener -> b.a.a.d:
    void dispose() -> a
    void resize(int,int) -> a
    void pause() -> b
    void resume() -> c
    void create() -> d
    void render() -> e
com.badlogic.gdx.ApplicationLogger -> b.a.a.e:
    void debug(java.lang.String,java.lang.String) -> a
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void error(java.lang.String,java.lang.String) -> b
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> b
    void log(java.lang.String,java.lang.String) -> c
com.badlogic.gdx.Audio -> b.a.a.f:
    com.badlogic.gdx.audio.Sound newSound(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.audio.Music newMusic(com.badlogic.gdx.files.FileHandle) -> b
com.badlogic.gdx.Files -> b.a.a.g:
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> a
    java.lang.String getLocalStoragePath() -> a
    java.lang.String getExternalStoragePath() -> b
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
com.badlogic.gdx.Files$FileType -> b.a.a.g$a:
    com.badlogic.gdx.Files$FileType[] $VALUES -> f
    com.badlogic.gdx.Files$FileType Local -> e
    com.badlogic.gdx.Files$FileType Absolute -> d
    com.badlogic.gdx.Files$FileType External -> c
    com.badlogic.gdx.Files$FileType Internal -> b
    com.badlogic.gdx.Files$FileType Classpath -> a
com.badlogic.gdx.Game -> b.a.a.h:
    com.badlogic.gdx.Screen screen -> a
    void dispose() -> a
    void resize(int,int) -> a
    void setScreen(com.badlogic.gdx.Screen) -> a
    void pause() -> b
    void resume() -> c
    com.badlogic.gdx.Screen getScreen() -> f
com.badlogic.gdx.Gdx -> b.a.a.i:
    com.badlogic.gdx.Files files -> e
    com.badlogic.gdx.graphics.GL30 gl30 -> h
    com.badlogic.gdx.graphics.GL20 gl -> f
    com.badlogic.gdx.graphics.GL20 gl20 -> g
    com.badlogic.gdx.Graphics graphics -> b
    com.badlogic.gdx.Application app -> a
    com.badlogic.gdx.Audio audio -> c
    com.badlogic.gdx.Input input -> d
com.badlogic.gdx.Graphics -> b.a.a.j:
    com.badlogic.gdx.graphics.Cursor newCursor(com.badlogic.gdx.graphics.Pixmap,int,int) -> a
    void setCursor(com.badlogic.gdx.graphics.Cursor) -> a
    boolean setFullscreenMode(com.badlogic.gdx.Graphics$DisplayMode) -> a
    void setGL20(com.badlogic.gdx.graphics.GL20) -> a
    void setGL30(com.badlogic.gdx.graphics.GL30) -> a
    boolean setWindowedMode(int,int) -> a
    boolean supportsExtension(java.lang.String) -> a
    int getWidth() -> b
    int getHeight() -> c
    int getBackBufferWidth() -> d
    com.badlogic.gdx.Graphics$DisplayMode getDisplayMode() -> e
    void requestRendering() -> f
    float getDeltaTime() -> g
    com.badlogic.gdx.graphics.GL30 getGL30() -> h
    com.badlogic.gdx.graphics.GL20 getGL20() -> i
    boolean isGL30Available() -> j
    int getBackBufferHeight() -> k
    float getRawDeltaTime() -> l
com.badlogic.gdx.Graphics$BufferFormat -> b.a.a.j$a:
    int stencil -> f
    int samples -> g
    int a -> d
    int depth -> e
    boolean coverageSampling -> h
    int g -> b
    int b -> c
    int r -> a
com.badlogic.gdx.Graphics$DisplayMode -> b.a.a.j$b:
    int bitsPerPixel -> d
    int height -> b
    int refreshRate -> c
    int width -> a
com.badlogic.gdx.Input -> b.a.a.k:
    long getCurrentEventTime() -> a
    boolean isKeyPressed(int) -> a
    boolean isPeripheralAvailable(com.badlogic.gdx.Input$Peripheral) -> a
    void setCursorPosition(int,int) -> a
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> a
    boolean isCatchBackKey() -> b
    boolean isTouched(int) -> b
    void setCatchBackKey(boolean) -> b
    int getX() -> c
    void setCatchMenuKey(boolean) -> c
    void setOnscreenKeyboardVisible(boolean) -> d
    int getY() -> g
com.badlogic.gdx.Input$OnscreenKeyboardType -> b.a.a.k$a:
    com.badlogic.gdx.Input$OnscreenKeyboardType Default -> a
    com.badlogic.gdx.Input$OnscreenKeyboardType URI -> f
    com.badlogic.gdx.Input$OnscreenKeyboardType PhonePad -> c
    com.badlogic.gdx.Input$OnscreenKeyboardType NumberPad -> b
    com.badlogic.gdx.Input$OnscreenKeyboardType[] $VALUES -> g
    com.badlogic.gdx.Input$OnscreenKeyboardType Password -> e
    com.badlogic.gdx.Input$OnscreenKeyboardType Email -> d
com.badlogic.gdx.Input$Orientation -> b.a.a.k$b:
    com.badlogic.gdx.Input$Orientation Landscape -> a
    com.badlogic.gdx.Input$Orientation[] $VALUES -> c
    com.badlogic.gdx.Input$Orientation Portrait -> b
com.badlogic.gdx.Input$Peripheral -> b.a.a.k$c:
    com.badlogic.gdx.Input$Peripheral[] $VALUES -> j
    com.badlogic.gdx.Input$Peripheral HardwareKeyboard -> a
    com.badlogic.gdx.Input$Peripheral Gyroscope -> g
    com.badlogic.gdx.Input$Peripheral Vibrator -> f
    com.badlogic.gdx.Input$Peripheral Pressure -> i
    com.badlogic.gdx.Input$Peripheral RotationVector -> h
    com.badlogic.gdx.Input$Peripheral MultitouchScreen -> c
    com.badlogic.gdx.Input$Peripheral OnscreenKeyboard -> b
    com.badlogic.gdx.Input$Peripheral Compass -> e
    com.badlogic.gdx.Input$Peripheral Accelerometer -> d
com.badlogic.gdx.InputAdapter -> b.a.a.l:
    boolean keyDown(int) -> a
    boolean keyTyped(char) -> a
    boolean scrolled(float,float) -> a
    boolean keyUp(int) -> b
    boolean mouseMoved(int,int) -> b
com.badlogic.gdx.InputProcessor -> b.a.a.m:
    boolean keyDown(int) -> a
    boolean keyTyped(char) -> a
    boolean scrolled(float,float) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchDragged(int,int,int) -> a
    boolean keyUp(int) -> b
    boolean mouseMoved(int,int) -> b
    boolean touchUp(int,int,int,int) -> b
com.badlogic.gdx.LifecycleListener -> b.a.a.n:
    void dispose() -> a
    void pause() -> b
    void resume() -> c
com.badlogic.gdx.Net -> b.a.a.o:
com.badlogic.gdx.Preferences -> b.a.a.p:
    java.util.Map get() -> a
    float getFloat(java.lang.String) -> a
    float getFloat(java.lang.String,float) -> a
    int getInteger(java.lang.String,int) -> a
    com.badlogic.gdx.Preferences putBoolean(java.lang.String,boolean) -> a
    com.badlogic.gdx.Preferences putLong(java.lang.String,long) -> a
    com.badlogic.gdx.Preferences putString(java.lang.String,java.lang.String) -> a
    boolean getBoolean(java.lang.String,boolean) -> b
    java.lang.String getString(java.lang.String) -> b
    com.badlogic.gdx.Preferences putFloat(java.lang.String,float) -> b
    com.badlogic.gdx.Preferences putInteger(java.lang.String,int) -> b
    boolean getBoolean(java.lang.String) -> c
    void remove(java.lang.String) -> d
    long getLong(java.lang.String) -> e
    int getInteger(java.lang.String) -> f
    boolean contains(java.lang.String) -> g
com.badlogic.gdx.Screen -> b.a.a.q:
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> a
    void pause() -> b
    void resume() -> c
    void hide() -> d
com.badlogic.gdx.assets.AssetDescriptor -> b.a.a.r.a:
    com.badlogic.gdx.files.FileHandle file -> d
    com.badlogic.gdx.assets.AssetLoaderParameters params -> c
    java.lang.String fileName -> a
    java.lang.Class type -> b
com.badlogic.gdx.assets.AssetErrorListener -> b.a.a.r.b:
    void error(com.badlogic.gdx.assets.AssetDescriptor,java.lang.Throwable) -> a
com.badlogic.gdx.assets.AssetLoaderParameters -> b.a.a.r.c:
    com.badlogic.gdx.assets.AssetLoaderParameters$LoadedCallback loadedCallback -> a
com.badlogic.gdx.assets.AssetLoaderParameters$LoadedCallback -> b.a.a.r.c$a:
    void finishedLoading(com.badlogic.gdx.assets.AssetManager,java.lang.String,java.lang.Class) -> a
com.badlogic.gdx.assets.AssetLoadingTask -> b.a.a.r.d:
    com.badlogic.gdx.utils.async.AsyncResult depsFuture -> i
    java.lang.Object asset -> k
    com.badlogic.gdx.utils.async.AsyncResult loadFuture -> j
    com.badlogic.gdx.assets.AssetManager manager -> a
    long startTime -> e
    com.badlogic.gdx.assets.AssetDescriptor assetDesc -> b
    com.badlogic.gdx.utils.async.AsyncExecutor executor -> d
    boolean cancel -> l
    com.badlogic.gdx.assets.loaders.AssetLoader loader -> c
    boolean asyncDone -> f
    boolean dependenciesLoaded -> g
    com.badlogic.gdx.utils.Array dependencies -> h
    void removeDuplicates(com.badlogic.gdx.utils.Array) -> a
    com.badlogic.gdx.files.FileHandle resolve(com.badlogic.gdx.assets.loaders.AssetLoader,com.badlogic.gdx.assets.AssetDescriptor) -> a
    void unload() -> a
    boolean update() -> b
    void handleAsyncLoader() -> c
    void handleSyncLoader() -> d
com.badlogic.gdx.assets.AssetManager -> b.a.a.r.e:
    int peakTasks -> l
    int loaded -> j
    int toLoad -> k
    com.badlogic.gdx.utils.Logger log -> m
    com.badlogic.gdx.assets.AssetErrorListener listener -> i
    com.badlogic.gdx.utils.ObjectMap assets -> a
    com.badlogic.gdx.utils.async.AsyncExecutor executor -> g
    com.badlogic.gdx.utils.ObjectSet injected -> d
    com.badlogic.gdx.utils.ObjectMap loaders -> e
    com.badlogic.gdx.utils.Array tasks -> h
    com.badlogic.gdx.utils.ObjectMap assetDependencies -> c
    com.badlogic.gdx.utils.ObjectMap assetTypes -> b
    com.badlogic.gdx.utils.Array loadQueue -> f
    void nextTask() -> A
    boolean updateTask() -> B
    void addAsset(java.lang.String,java.lang.Class,java.lang.Object) -> a
    void addTask(com.badlogic.gdx.assets.AssetDescriptor) -> a
    void dispose() -> a
    java.lang.Object get(java.lang.String) -> a
    java.lang.Object get(java.lang.String,java.lang.Class) -> a
    java.lang.Object get(java.lang.String,java.lang.Class,boolean) -> a
    java.lang.Object get(java.lang.String,boolean) -> a
    java.lang.String getAssetFileName(java.lang.Object) -> a
    com.badlogic.gdx.assets.loaders.AssetLoader getLoader(java.lang.Class,java.lang.String) -> a
    void handleTaskError(java.lang.Throwable) -> a
    void injectDependencies(java.lang.String,com.badlogic.gdx.utils.Array) -> a
    void injectDependency(java.lang.String,com.badlogic.gdx.assets.AssetDescriptor) -> a
    void load(java.lang.String,java.lang.Class,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void setLoader(java.lang.Class,com.badlogic.gdx.assets.loaders.AssetLoader) -> a
    void setLoader(java.lang.Class,java.lang.String,com.badlogic.gdx.assets.loaders.AssetLoader) -> a
    void setReferenceCount(java.lang.String,int) -> a
    void taskFailed(com.badlogic.gdx.assets.AssetDescriptor,java.lang.RuntimeException) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String) -> b
    boolean isLoaded(java.lang.String,java.lang.Class) -> b
    int getReferenceCount(java.lang.String) -> c
    void load(java.lang.String,java.lang.Class) -> c
    boolean isLoaded(java.lang.String) -> d
    void unload(java.lang.String) -> e
    void incrementRefCountedDependencies(java.lang.String) -> f
    void clear() -> v
    void finishLoading() -> w
    com.badlogic.gdx.utils.Logger getLogger() -> x
    float getProgress() -> y
    boolean update() -> z
com.badlogic.gdx.assets.AssetManager$RefCountedContainer -> b.a.a.r.e$a:
    java.lang.Object object -> a
    int refCount -> b
com.badlogic.gdx.assets.loaders.AssetLoader -> b.a.a.r.f.a:
    com.badlogic.gdx.assets.loaders.FileHandleResolver resolver -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
com.badlogic.gdx.assets.loaders.AsynchronousAssetLoader -> b.a.a.r.f.b:
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void unloadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
com.badlogic.gdx.assets.loaders.BitmapFontLoader -> b.a.a.r.f.c:
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData data -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter -> b.a.a.r.f.c$a:
    java.lang.String atlasName -> g
    boolean flip -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> e
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData bitmapFontData -> f
    boolean genMipMaps -> c
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> d
com.badlogic.gdx.assets.loaders.CubemapLoader -> b.a.a.r.f.d:
    com.badlogic.gdx.assets.loaders.CubemapLoader$CubemapLoaderInfo info -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.CubemapLoader$CubemapParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.CubemapLoader$CubemapParameter) -> a
    com.badlogic.gdx.graphics.Cubemap loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.CubemapLoader$CubemapParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.assets.loaders.CubemapLoader$CubemapLoaderInfo -> b.a.a.r.f.d$a:
    com.badlogic.gdx.graphics.CubemapData data -> b
    java.lang.String filename -> a
    com.badlogic.gdx.graphics.Cubemap cubemap -> c
com.badlogic.gdx.assets.loaders.CubemapLoader$CubemapParameter -> b.a.a.r.f.d$b:
    com.badlogic.gdx.graphics.CubemapData cubemapData -> d
    com.badlogic.gdx.graphics.Pixmap$Format format -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> e
    com.badlogic.gdx.graphics.Cubemap cubemap -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapV -> h
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapU -> g
com.badlogic.gdx.assets.loaders.FileHandleResolver -> b.a.a.r.f.e:
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
com.badlogic.gdx.assets.loaders.I18NBundleLoader -> b.a.a.r.f.f:
    com.badlogic.gdx.utils.I18NBundle bundle -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter) -> a
    com.badlogic.gdx.utils.I18NBundle loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter -> b.a.a.r.f.f$a:
    java.util.Locale locale -> b
    java.lang.String encoding -> c
com.badlogic.gdx.assets.loaders.ModelLoader -> b.a.a.r.f.g:
    com.badlogic.gdx.utils.Array items -> b
    com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters defaultParameters -> c
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
    com.badlogic.gdx.graphics.g3d.Model loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters -> b.a.a.r.f.g$a:
    com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter textureParameter -> b
com.badlogic.gdx.assets.loaders.MusicLoader -> b.a.a.r.f.h:
    com.badlogic.gdx.audio.Music music -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> a
    com.badlogic.gdx.audio.Music loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter -> b.a.a.r.f.h$a:
com.badlogic.gdx.assets.loaders.ParticleEffectLoader -> b.a.a.r.f.i:
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ParticleEffectLoader$ParticleEffectParameter) -> a
    com.badlogic.gdx.graphics.g2d.ParticleEffect load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ParticleEffectLoader$ParticleEffectParameter) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.ParticleEffectLoader$ParticleEffectParameter -> b.a.a.r.f.i$a:
    com.badlogic.gdx.files.FileHandle imagesDir -> d
    java.lang.String atlasPrefix -> c
    java.lang.String atlasFile -> b
com.badlogic.gdx.assets.loaders.PixmapLoader -> b.a.a.r.f.j:
    com.badlogic.gdx.graphics.Pixmap pixmap -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> a
    com.badlogic.gdx.graphics.Pixmap loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter -> b.a.a.r.f.j$a:
com.badlogic.gdx.assets.loaders.ShaderProgramLoader -> b.a.a.r.f.k:
    java.lang.String fragmentFileSuffix -> c
    java.lang.String vertexFileSuffix -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ShaderProgramLoader$ShaderProgramParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ShaderProgramLoader$ShaderProgramParameter) -> a
    com.badlogic.gdx.graphics.glutils.ShaderProgram loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ShaderProgramLoader$ShaderProgramParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.assets.loaders.ShaderProgramLoader$ShaderProgramParameter -> b.a.a.r.f.k$a:
    java.lang.String prependFragmentCode -> f
    java.lang.String fragmentFile -> c
    java.lang.String vertexFile -> b
    java.lang.String prependVertexCode -> e
    boolean logOnCompileFailure -> d
com.badlogic.gdx.assets.loaders.SkinLoader -> b.a.a.r.f.l:
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin newSkin(com.badlogic.gdx.graphics.g2d.TextureAtlas) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter -> b.a.a.r.f.l$a:
    java.lang.String textureAtlasPath -> b
    com.badlogic.gdx.utils.ObjectMap resources -> c
com.badlogic.gdx.assets.loaders.SoundLoader -> b.a.a.r.f.m:
    com.badlogic.gdx.audio.Sound sound -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> a
    com.badlogic.gdx.audio.Sound loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter -> b.a.a.r.f.m$a:
com.badlogic.gdx.assets.loaders.SynchronousAssetLoader -> b.a.a.r.f.n:
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.TextureAtlasLoader -> b.a.a.r.f.o:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData data -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter) -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter -> b.a.a.r.f.o$a:
    boolean flip -> b
com.badlogic.gdx.assets.loaders.TextureLoader -> b.a.a.r.f.p:
    com.badlogic.gdx.assets.loaders.TextureLoader$TextureLoaderInfo info -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> a
    com.badlogic.gdx.graphics.Texture loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.assets.loaders.TextureLoader$TextureLoaderInfo -> b.a.a.r.f.p$a:
    com.badlogic.gdx.graphics.TextureData data -> b
    java.lang.String filename -> a
    com.badlogic.gdx.graphics.Texture texture -> c
com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter -> b.a.a.r.f.p$b:
    com.badlogic.gdx.graphics.TextureData textureData -> e
    com.badlogic.gdx.graphics.Pixmap$Format format -> b
    com.badlogic.gdx.graphics.Texture texture -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapV -> i
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> g
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> f
    boolean genMipMaps -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapU -> h
com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver -> b.a.a.r.f.q.a:
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
com.badlogic.gdx.audio.Music -> b.a.a.s.a:
    void setLooping(boolean) -> a
    void setOnCompletionListener(com.badlogic.gdx.audio.Music$OnCompletionListener) -> a
    void pause() -> b
    void setVolume(float) -> b
    boolean isLooping() -> m
    boolean isPlaying() -> p
    void stop() -> q
    void play() -> t
com.badlogic.gdx.audio.Music$OnCompletionListener -> b.a.a.s.a$a:
    void onCompletion(com.badlogic.gdx.audio.Music) -> a
com.badlogic.gdx.audio.Sound -> b.a.a.s.b:
    long play(float,float,float) -> a
    void stop(long) -> a
    long play(float) -> c
    long loop(float) -> d
com.badlogic.gdx.backends.android.AndroidApplication -> b.a.a.t.a.a:
    int logLevel -> n
    com.badlogic.gdx.backends.android.AndroidNet net -> e
    boolean useImmersiveMode -> p
    boolean firstResume -> i
    com.badlogic.gdx.backends.android.AndroidInput input -> b
    com.badlogic.gdx.utils.SnapshotArray lifecycleListeners -> l
    com.badlogic.gdx.backends.android.AndroidFiles files -> d
    com.badlogic.gdx.backends.android.AndroidAudio audio -> c
    boolean hideStatusBar -> q
    boolean isWaitingForAudio -> s
    com.badlogic.gdx.utils.Array androidEventListeners -> m
    com.badlogic.gdx.ApplicationLogger applicationLogger -> o
    com.badlogic.gdx.utils.Array executedRunnables -> k
    com.badlogic.gdx.utils.Array runnables -> j
    com.badlogic.gdx.ApplicationListener listener -> g
    int wasFocusChanged -> r
    com.badlogic.gdx.backends.android.AndroidClipboard clipboard -> f
    com.badlogic.gdx.backends.android.AndroidGraphics graphics -> a
    android.os.Handler handler -> h
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> a
    com.badlogic.gdx.backends.android.AndroidAudio createAudio(android.content.Context,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
    com.badlogic.gdx.backends.android.AndroidInput createInput(com.badlogic.gdx.Application,android.content.Context,java.lang.Object,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
    void debug(java.lang.String,java.lang.String) -> a
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> a
    com.badlogic.gdx.Application$ApplicationType getType() -> a
    void init(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration,boolean) -> a
    void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
    void postRunnable(java.lang.Runnable) -> a
    void setApplicationLogger(com.badlogic.gdx.ApplicationLogger) -> a
    void useImmersiveMode(boolean) -> a
    void createWakeLock(boolean) -> b
    void error(java.lang.String,java.lang.String) -> b
    void exit() -> b
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> b
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> b
    int getVersion() -> c
    void hideStatusBar(boolean) -> c
    void log(java.lang.String,java.lang.String) -> c
    com.badlogic.gdx.utils.Array getRunnables() -> d
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> e
    com.badlogic.gdx.Graphics getGraphics() -> f
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> g
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> h
    com.badlogic.gdx.utils.Clipboard getClipboard() -> i
    android.content.Context getContext() -> j
    android.view.Window getApplicationWindow() -> k
    com.badlogic.gdx.utils.SnapshotArray getLifecycleListeners() -> l
    com.badlogic.gdx.backends.android.AndroidFiles createFiles() -> m
    android.widget.FrameLayout$LayoutParams createLayoutParams() -> n
    com.badlogic.gdx.ApplicationLogger getApplicationLogger() -> o
    com.badlogic.gdx.Audio getAudio() -> p
    com.badlogic.gdx.Files getFiles() -> q
    com.badlogic.gdx.Net getNet() -> r
com.badlogic.gdx.backends.android.AndroidApplication$1 -> b.a.a.t.a.a$a:
    com.badlogic.gdx.backends.android.AndroidApplication this$0 -> a
    void dispose() -> a
    void pause() -> b
    void resume() -> c
com.badlogic.gdx.backends.android.AndroidApplication$2 -> b.a.a.t.a.a$b:
    com.badlogic.gdx.backends.android.AndroidApplication this$0 -> a
com.badlogic.gdx.backends.android.AndroidApplicationBase -> b.a.a.t.a.b:
    void useImmersiveMode(boolean) -> a
    com.badlogic.gdx.utils.Array getRunnables() -> d
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> e
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> h
    android.content.Context getContext() -> j
    android.view.Window getApplicationWindow() -> k
    com.badlogic.gdx.utils.SnapshotArray getLifecycleListeners() -> l
com.badlogic.gdx.backends.android.AndroidApplicationConfiguration -> b.a.a.t.a.c:
    boolean useWakelock -> n
    int sensorDelay -> l
    boolean hideStatusBar -> o
    int touchSleepTime -> m
    boolean disableAudio -> p
    boolean useGyroscope -> i
    boolean useCompass -> j
    boolean useRotationVectorSensor -> k
    int stencil -> f
    int numSamples -> g
    int a -> d
    int depth -> e
    int g -> b
    int b -> c
    boolean useImmersiveMode -> s
    int r -> a
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> r
    boolean useGL30 -> t
    boolean useAccelerometer -> h
    int maxNetThreads -> u
    int maxSimultaneousSounds -> q
com.badlogic.gdx.backends.android.AndroidApplicationLogger -> b.a.a.t.a.d:
    void debug(java.lang.String,java.lang.String) -> a
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void error(java.lang.String,java.lang.String) -> b
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> b
    void log(java.lang.String,java.lang.String) -> c
com.badlogic.gdx.backends.android.AndroidAudio -> b.a.a.t.a.e:
    void notifyMusicDisposed(com.badlogic.gdx.backends.android.AndroidMusic) -> a
    void pause() -> b
    void resume() -> c
com.badlogic.gdx.backends.android.AndroidClipboard -> b.a.a.t.a.f:
    android.content.ClipboardManager clipboard -> a
    java.lang.String getContents() -> a
    void setContents(java.lang.String) -> a
com.badlogic.gdx.backends.android.AndroidEventListener -> b.a.a.t.a.g:
    void onActivityResult(int,int,android.content.Intent) -> a
com.badlogic.gdx.backends.android.AndroidFileHandle -> b.a.a.t.a.h:
    android.content.res.AssetManager assets -> c
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    boolean exists() -> a
    java.io.File file() -> c
    long length() -> d
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> d
    com.badlogic.gdx.files.FileHandle parent() -> g
    java.io.InputStream read() -> j
    android.content.res.AssetFileDescriptor getAssetFileDescriptor() -> n
com.badlogic.gdx.backends.android.AndroidFiles -> b.a.a.t.a.i:
    com.badlogic.gdx.backends.android.ZipResourceFile getExpansionFile() -> c
com.badlogic.gdx.backends.android.AndroidGL20 -> b.a.a.t.a.j:
    int[] ints2 -> b
    int[] ints3 -> c
    int[] ints -> a
    byte[] buffer -> d
    void glAttachShader(int,int) -> a
    void glBlendFuncSeparate(int,int,int,int) -> a
    void glBufferData(int,int,java.nio.Buffer,int) -> a
    void glClearColor(float,float,float,float) -> a
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> a
    void glDepthMask(boolean) -> a
    void glDrawElements(int,int,int,java.nio.Buffer) -> a
    void glFramebufferTexture2D(int,int,int,int,int) -> a
    int glGenRenderbuffer() -> a
    void glGenerateMipmap(int) -> a
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> a
    void glGetFloatv(int,java.nio.FloatBuffer) -> a
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> a
    void glShaderSource(int,java.lang.String) -> a
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> a
    void glTexParameterf(int,int,float) -> a
    void glTexParameteri(int,int,int) -> a
    void glUniformMatrix4fv(int,int,boolean,float[],int) -> a
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> a
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> a
    void glBindRenderbuffer(int,int) -> b
    void glBufferSubData(int,int,int,java.nio.Buffer) -> b
    void glDrawArrays(int,int,int) -> b
    void glFramebufferRenderbuffer(int,int,int,int) -> b
    int glGenBuffer() -> b
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> b
    int glGetAttribLocation(int,java.lang.String) -> b
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> b
    void glLinkProgram(int) -> b
    void glTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> b
    void glBindFramebuffer(int,int) -> c
    int glGetError() -> c
    java.lang.String glGetShaderInfoLog(int) -> c
    int glGetUniformLocation(int,java.lang.String) -> c
    void glScissor(int,int,int,int) -> c
    void glDisable(int) -> d
    int glGenTexture() -> d
    void glGetIntegerv(int,java.nio.IntBuffer) -> d
    void glRenderbufferStorage(int,int,int,int) -> d
    void glUniform1i(int,int) -> d
    void glBindBuffer(int,int) -> e
    int glCreateProgram() -> e
    void glDisableVertexAttribArray(int) -> e
    void glDeleteTexture(int) -> f
    int glGenFramebuffer() -> f
    void glPixelStorei(int,int) -> f
    void glViewport(int,int,int,int) -> f
    void glBindTexture(int,int) -> g
    void glCompileShader(int) -> g
    void glDrawElements(int,int,int,int) -> g
    void glEnable(int) -> h
    int glCheckFramebufferStatus(int) -> i
    void glUseProgram(int) -> j
    void glDeleteRenderbuffer(int) -> k
    java.lang.String glGetProgramInfoLog(int) -> l
    void glEnableVertexAttribArray(int) -> m
    java.lang.String glGetString(int) -> n
    void glClear(int) -> o
    void glDeleteFramebuffer(int) -> p
    int glCreateShader(int) -> q
    void glDeleteShader(int) -> s
    void glDeleteProgram(int) -> t
    void glDeleteBuffer(int) -> u
com.badlogic.gdx.backends.android.AndroidGL30 -> b.a.a.t.a.k:
    void glDeleteVertexArrays(int,java.nio.IntBuffer) -> a
    void glTexImage3D(int,int,int,int,int,int,int,int,int,java.nio.Buffer) -> a
    void glDrawBuffers(int,java.nio.IntBuffer) -> b
    void glDrawElementsInstanced(int,int,int,int,int) -> b
    void glGenVertexArrays(int,java.nio.IntBuffer) -> c
    void glDrawArraysInstanced(int,int,int,int) -> e
    void glBindVertexArray(int) -> r
com.badlogic.gdx.backends.android.AndroidGraphics -> b.a.a.t.a.l:
    long lastFrameTime -> i
    boolean created -> n
    float deltaTime -> j
    long frameId -> l
    boolean running -> o
    java.lang.String extensions -> h
    long frameStart -> k
    int frames -> m
    boolean pause -> p
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 view -> a
    com.badlogic.gdx.graphics.GL30 gl30 -> f
    com.badlogic.gdx.graphics.GL20 gl20 -> e
    int[] value -> u
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> s
    boolean enforceContinuousRendering -> w
    com.badlogic.gdx.backends.android.AndroidApplicationBase app -> d
    int width -> b
    boolean resume -> q
    int height -> c
    boolean destroy -> r
    com.badlogic.gdx.graphics.glutils.GLVersion glVersion -> g
    boolean isContinuous -> t
    java.lang.Object synch -> v
    boolean checkGL20() -> a
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 createGLSurfaceView(com.badlogic.gdx.backends.android.AndroidApplicationBase,com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy) -> a
    int getAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
    void logConfig(javax.microedition.khronos.egl.EGLConfig) -> a
    com.badlogic.gdx.graphics.Cursor newCursor(com.badlogic.gdx.graphics.Pixmap,int,int) -> a
    void setContinuousRendering(boolean) -> a
    void setCursor(com.badlogic.gdx.graphics.Cursor) -> a
    boolean setFullscreenMode(com.badlogic.gdx.Graphics$DisplayMode) -> a
    void setGL20(com.badlogic.gdx.graphics.GL20) -> a
    void setGL30(com.badlogic.gdx.graphics.GL30) -> a
    boolean setWindowedMode(int,int) -> a
    void setupGL(javax.microedition.khronos.opengles.GL10) -> a
    boolean supportsExtension(java.lang.String) -> a
    int getWidth() -> b
    int getHeight() -> c
    int getBackBufferWidth() -> d
    com.badlogic.gdx.Graphics$DisplayMode getDisplayMode() -> e
    void requestRendering() -> f
    float getDeltaTime() -> g
    com.badlogic.gdx.graphics.GL30 getGL30() -> h
    com.badlogic.gdx.graphics.GL20 getGL20() -> i
    boolean isGL30Available() -> j
    int getBackBufferHeight() -> k
    void clearManagedCaches() -> m
    void destroy() -> n
    android.opengl.GLSurfaceView$EGLConfigChooser getEglConfigChooser() -> o
    android.view.View getView() -> p
    boolean isContinuousRendering() -> q
    void logManagedCachesStatus() -> r
    void onPauseGLSurfaceView() -> s
    void onResumeGLSurfaceView() -> t
    void pause() -> u
    void preserveEGLContextOnPause() -> v
    void resume() -> w
    void updatePpi() -> x
    void updateSafeAreaInsets() -> y
com.badlogic.gdx.backends.android.AndroidGraphics$1 -> b.a.a.t.a.l$a:
    com.badlogic.gdx.backends.android.AndroidGraphics this$0 -> a
com.badlogic.gdx.backends.android.AndroidGraphics$AndroidDisplayMode -> b.a.a.t.a.l$b:
com.badlogic.gdx.backends.android.AndroidInput -> b.a.a.t.a.m:
    void addGenericMotionListener(android.view.View$OnGenericMotionListener) -> a
    void addKeyListener(android.view.View$OnKeyListener) -> a
    void setKeyboardAvailable(boolean) -> a
    void onResume() -> d
    void onPause() -> e
    void processEvents() -> f
com.badlogic.gdx.backends.android.AndroidMouseHandler -> b.a.a.t.a.n:
    int deltaY -> b
    int deltaX -> a
    boolean onGenericMotion(android.view.MotionEvent,com.badlogic.gdx.backends.android.DefaultAndroidInput) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.DefaultAndroidInput,int,int,int,int,int,long) -> a
com.badlogic.gdx.backends.android.AndroidMusic -> b.a.a.t.a.o:
    com.badlogic.gdx.backends.android.AndroidAudio audio -> a
    com.badlogic.gdx.audio.Music$OnCompletionListener onCompletionListener -> e
    android.media.MediaPlayer player -> b
    boolean isPrepared -> c
    boolean wasPlaying -> d
    void dispose() -> a
    void setLooping(boolean) -> a
    void setOnCompletionListener(com.badlogic.gdx.audio.Music$OnCompletionListener) -> a
    void pause() -> b
    void setVolume(float) -> b
    boolean isLooping() -> m
    boolean isPlaying() -> p
    void stop() -> q
    void play() -> t
com.badlogic.gdx.backends.android.AndroidMusic$1 -> b.a.a.t.a.o$a:
    com.badlogic.gdx.backends.android.AndroidMusic this$0 -> a
com.badlogic.gdx.backends.android.AndroidNet -> b.a.a.t.a.p:
com.badlogic.gdx.backends.android.AndroidPreferences -> b.a.a.t.a.q:
    android.content.SharedPreferences$Editor editor -> b
    android.content.SharedPreferences sharedPrefs -> a
    java.util.Map get() -> a
    float getFloat(java.lang.String) -> a
    float getFloat(java.lang.String,float) -> a
    int getInteger(java.lang.String,int) -> a
    com.badlogic.gdx.Preferences putBoolean(java.lang.String,boolean) -> a
    com.badlogic.gdx.Preferences putLong(java.lang.String,long) -> a
    com.badlogic.gdx.Preferences putString(java.lang.String,java.lang.String) -> a
    void edit() -> b
    boolean getBoolean(java.lang.String,boolean) -> b
    java.lang.String getString(java.lang.String) -> b
    com.badlogic.gdx.Preferences putFloat(java.lang.String,float) -> b
    com.badlogic.gdx.Preferences putInteger(java.lang.String,int) -> b
    boolean getBoolean(java.lang.String) -> c
    void remove(java.lang.String) -> d
    long getLong(java.lang.String) -> e
    int getInteger(java.lang.String) -> f
    boolean contains(java.lang.String) -> g
com.badlogic.gdx.backends.android.AndroidSound -> b.a.a.t.a.r:
    android.media.SoundPool soundPool -> a
    com.badlogic.gdx.utils.IntArray streamIds -> c
    int soundId -> b
    void dispose() -> a
    long play(float,float,float) -> a
    void stop(long) -> a
    long play(float) -> c
    long loop(float) -> d
com.badlogic.gdx.backends.android.AndroidTouchHandler -> b.a.a.t.a.s:
    void onTouch(android.view.MotionEvent,com.badlogic.gdx.backends.android.DefaultAndroidInput) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.DefaultAndroidInput,int,int,int,int,int,long) -> a
    boolean supportsMultitouch(android.content.Context) -> a
    int toGdxButton(int) -> a
com.badlogic.gdx.backends.android.AndroidVisibilityListener -> b.a.a.t.a.t:
    void createListener(com.badlogic.gdx.backends.android.AndroidApplicationBase) -> a
com.badlogic.gdx.backends.android.AndroidVisibilityListener$1 -> b.a.a.t.a.t$a:
    com.badlogic.gdx.backends.android.AndroidApplicationBase val$application -> a
com.badlogic.gdx.backends.android.AndroidVisibilityListener$1$1 -> b.a.a.t.a.t$a$a:
    com.badlogic.gdx.backends.android.AndroidVisibilityListener$1 this$1 -> a
com.badlogic.gdx.backends.android.AndroidZipFileHandle -> b.a.a.t.a.u:
    java.lang.String path -> g
    long fdLength -> e
    com.badlogic.gdx.backends.android.ZipResourceFile expansionFile -> f
    boolean hasAssetFd -> d
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    boolean exists() -> a
    long length() -> d
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> d
    com.badlogic.gdx.files.FileHandle parent() -> g
    java.io.InputStream read() -> j
    android.content.res.AssetFileDescriptor getAssetFileDescriptor() -> n
    java.lang.String getPath() -> o
    void initialize() -> p
com.badlogic.gdx.backends.android.DefaultAndroidAudio -> b.a.a.t.a.v:
    android.media.AudioManager manager -> b
    android.media.SoundPool soundPool -> a
    java.util.List musics -> c
    void dispose() -> a
    com.badlogic.gdx.audio.Sound newSound(com.badlogic.gdx.files.FileHandle) -> a
    void notifyMusicDisposed(com.badlogic.gdx.backends.android.AndroidMusic) -> a
    com.badlogic.gdx.audio.Music newMusic(com.badlogic.gdx.files.FileHandle) -> b
    void pause() -> b
    void resume() -> c
com.badlogic.gdx.backends.android.DefaultAndroidFiles -> b.a.a.t.a.w:
    com.badlogic.gdx.backends.android.ZipResourceFile expansionFile -> d
    android.content.res.AssetManager assets -> c
    java.lang.String externalFilesPath -> a
    java.lang.String localpath -> b
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> a
    java.lang.String getLocalStoragePath() -> a
    com.badlogic.gdx.files.FileHandle getZipFileHandleIfExists(com.badlogic.gdx.files.FileHandle,java.lang.String) -> a
    java.lang.String initExternalFilesPath(android.content.ContextWrapper) -> a
    java.lang.String getExternalStoragePath() -> b
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
    com.badlogic.gdx.backends.android.ZipResourceFile getExpansionFile() -> c
com.badlogic.gdx.backends.android.DefaultAndroidInput -> b.a.a.t.a.x:
    android.content.Context context -> B
    float[] magneticFieldValues -> I
    boolean requestFocus -> V
    boolean[] touched -> o
    android.hardware.SensorEventListener gyroscopeListener -> Q
    com.badlogic.gdx.InputProcessor processor -> L
    android.hardware.SensorEventListener rotationVectorListener -> S
    boolean hasMultitouch -> s
    java.util.ArrayList keyEvents -> i
    int[] deltaY -> n
    int[] button -> p
    boolean rotationVectorAvailable -> G
    java.util.ArrayList genericMotionListeners -> T
    com.badlogic.gdx.utils.Pool usedKeyEvents -> f
    float[] pressure -> r
    int[] touchY -> l
    float[] rotationVectorValues -> J
    boolean justTouched -> K
    boolean[] justPressedButtons -> t
    android.os.Vibrator vibrator -> E
    com.badlogic.gdx.backends.android.AndroidTouchHandler touchHandler -> C
    boolean accelerometerAvailable -> v
    int sleepTime -> D
    android.hardware.SensorEventListener accelerometerListener -> P
    boolean gyroscopeAvailable -> x
    com.badlogic.gdx.Application app -> A
    android.hardware.SensorEventListener compassListener -> R
    android.os.Handler handle -> z
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> M
    float[] gyroscopeValues -> y
    java.util.ArrayList touchEvents -> j
    float[] accelerometerValues -> w
    java.util.ArrayList keyListeners -> h
    com.badlogic.gdx.backends.android.AndroidMouseHandler mouseHandler -> U
    android.hardware.SensorManager manager -> u
    boolean compassAvailable -> F
    int[] realId -> q
    boolean keyboardAvailable -> H
    com.badlogic.gdx.Input$Orientation nativeOrientation -> N
    int[] touchX -> k
    com.badlogic.gdx.utils.Pool usedTouchEvents -> g
    int[] deltaX -> m
    long currentEventTimeStamp -> O
    void addGenericMotionListener(android.view.View$OnGenericMotionListener) -> a
    void addKeyListener(android.view.View$OnKeyListener) -> a
    int getAndroidInputType(com.badlogic.gdx.Input$OnscreenKeyboardType) -> a
    long getCurrentEventTime() -> a
    boolean isPeripheralAvailable(com.badlogic.gdx.Input$Peripheral) -> a
    float[] resize(float[]) -> a
    int[] resize(int[]) -> a
    boolean[] resize(boolean[]) -> a
    void setCursorPosition(int,int) -> a
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> a
    void setKeyboardAvailable(boolean) -> a
    void setOnscreenKeyboardVisible(boolean,com.badlogic.gdx.Input$OnscreenKeyboardType) -> a
    boolean isTouched(int) -> b
    int getX() -> c
    int lookUpPointerIndex(int) -> d
    void onResume() -> d
    void setOnscreenKeyboardVisible(boolean) -> d
    void onPause() -> e
    void processEvents() -> f
    int getY() -> g
    int getFreePointerIndex() -> h
    int getRotation() -> i
    void registerSensorListeners() -> j
    void unregisterSensorListeners() -> k
com.badlogic.gdx.backends.android.DefaultAndroidInput$1 -> b.a.a.t.a.x$a:
    com.badlogic.gdx.backends.android.DefaultAndroidInput$KeyEvent newObject() -> a
    java.lang.Object newObject() -> a
com.badlogic.gdx.backends.android.DefaultAndroidInput$2 -> b.a.a.t.a.x$b:
    com.badlogic.gdx.backends.android.DefaultAndroidInput$TouchEvent newObject() -> a
    java.lang.Object newObject() -> a
com.badlogic.gdx.backends.android.DefaultAndroidInput$4 -> b.a.a.t.a.x$c:
    boolean val$visible -> a
    com.badlogic.gdx.Input$OnscreenKeyboardType val$type -> b
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> c
com.badlogic.gdx.backends.android.DefaultAndroidInput$5 -> b.a.a.t.a.x$d:
    int[] $SwitchMap$com$badlogic$gdx$Input$OnscreenKeyboardType -> a
com.badlogic.gdx.backends.android.DefaultAndroidInput$KeyEvent -> b.a.a.t.a.x$e:
    long timeStamp -> a
    int type -> b
    char keyChar -> d
    int keyCode -> c
com.badlogic.gdx.backends.android.DefaultAndroidInput$SensorListener -> b.a.a.t.a.x$f:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> a
com.badlogic.gdx.backends.android.DefaultAndroidInput$TouchEvent -> b.a.a.t.a.x$g:
    int pointer -> h
    int scrollAmountY -> f
    long timeStamp -> a
    int button -> g
    int y -> d
    int scrollAmountX -> e
    int type -> b
    int x -> c
com.badlogic.gdx.backends.android.ZipResourceFile -> b.a.a.t.a.y:
    android.content.res.AssetFileDescriptor getAssetFileDescriptor(java.lang.String) -> a
    com.badlogic.gdx.backends.android.ZipResourceFile$ZipEntryRO[] getEntriesAt(java.lang.String) -> b
    java.io.InputStream getInputStream(java.lang.String) -> c
com.badlogic.gdx.backends.android.ZipResourceFile$ZipEntryRO -> b.a.a.t.a.y$a:
com.badlogic.gdx.backends.android.surfaceview.FillResolutionStrategy -> b.a.a.t.a.z.a:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 -> b.a.a.t.a.z.b:
    int targetGLESVersion -> d
    java.lang.String TAG -> c
    com.badlogic.gdx.Input$OnscreenKeyboardType onscreenKeyboardType -> b
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> a
    boolean checkEglError(java.lang.String,javax.microedition.khronos.egl.EGL10) -> a
    void init(boolean,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$1 -> b.a.a.t.a.z.b$a:
    void sendDownUpKeyEventForBackwardCompatibility(int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ConfigChooser -> b.a.a.t.a.z.b$b:
    int[] mValue -> g
    int[] s_configAttribs2 -> i
    int EGL_OPENGL_ES2_BIT -> h
    int mStencilSize -> f
    int mAlphaSize -> d
    int mDepthSize -> e
    int mGreenSize -> b
    int mBlueSize -> c
    int mRedSize -> a
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ContextFactory -> b.a.a.t.a.z.b$c:
    int EGL_CONTEXT_CLIENT_VERSION -> a
com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser -> b.a.a.t.a.z.c:
    int[] mConfigAttribs -> h
    int[] mValue -> i
    int mStencilSize -> f
    int mNumSamples -> g
    int mAlphaSize -> d
    int mDepthSize -> e
    int mGreenSize -> b
    int mBlueSize -> c
    int mRedSize -> a
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy -> b.a.a.t.a.z.d:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension -> b.a.a.t.a.z.d$a:
    int height -> b
    int width -> a
com.badlogic.gdx.controllers.Controller -> b.a.a.u.a:
    boolean getButton(int) -> a
    com.badlogic.gdx.controllers.ControllerMapping getMapping() -> a
    float getAxis(int) -> b
    java.lang.String getName() -> b
com.badlogic.gdx.controllers.ControllerAdapter -> b.a.a.u.b:
    void connected(com.badlogic.gdx.controllers.Controller) -> a
    boolean buttonUp(com.badlogic.gdx.controllers.Controller,int) -> b
    void disconnected(com.badlogic.gdx.controllers.Controller) -> b
com.badlogic.gdx.controllers.ControllerListener -> b.a.a.u.c:
    boolean axisMoved(com.badlogic.gdx.controllers.Controller,int,float) -> a
    boolean buttonDown(com.badlogic.gdx.controllers.Controller,int) -> a
    void connected(com.badlogic.gdx.controllers.Controller) -> a
    boolean buttonUp(com.badlogic.gdx.controllers.Controller,int) -> b
    void disconnected(com.badlogic.gdx.controllers.Controller) -> b
com.badlogic.gdx.controllers.ControllerManager -> b.a.a.u.d:
    void addListener(com.badlogic.gdx.controllers.ControllerListener) -> a
    void removeListener(com.badlogic.gdx.controllers.ControllerListener) -> b
    com.badlogic.gdx.utils.Array getControllers() -> g
    void clearListeners() -> h
com.badlogic.gdx.controllers.ControllerManagerStub -> b.a.a.u.e:
    com.badlogic.gdx.utils.Array controllers -> a
    void addListener(com.badlogic.gdx.controllers.ControllerListener) -> a
    void removeListener(com.badlogic.gdx.controllers.ControllerListener) -> b
    com.badlogic.gdx.utils.Array getControllers() -> g
    void clearListeners() -> h
com.badlogic.gdx.controllers.ControllerMapping -> b.a.a.u.f:
    int buttonDpadRight -> j
    int buttonDpadDown -> h
    int buttonDpadLeft -> i
    int buttonStart -> f
    int buttonDpadUp -> g
    int buttonY -> d
    int buttonBack -> e
    int buttonB -> b
    int buttonX -> c
    int buttonA -> a
com.badlogic.gdx.controllers.Controllers -> b.a.a.u.g:
    com.badlogic.gdx.utils.ObjectMap managers -> a
    java.lang.String preferredManager -> b
    void addListener(com.badlogic.gdx.controllers.ControllerListener) -> a
    void clearListeners() -> a
    com.badlogic.gdx.utils.Array getControllers() -> b
    void removeListener(com.badlogic.gdx.controllers.ControllerListener) -> b
    com.badlogic.gdx.controllers.ControllerManager getManager() -> c
    void initialize() -> d
com.badlogic.gdx.controllers.Controllers$1 -> b.a.a.u.g$a:
    com.badlogic.gdx.Application val$app -> a
    void dispose() -> a
    void pause() -> b
    void resume() -> c
com.badlogic.gdx.controllers.android.AndroidController -> com.badlogic.gdx.controllers.android.a:
    com.badlogic.gdx.utils.IntIntMap buttons -> b
    boolean connected -> i
    int[] axesIds -> d
    float povY -> f
    float povX -> e
    java.lang.String name -> a
    float[] axes -> c
    boolean povAxis -> g
    com.badlogic.gdx.utils.Array listeners -> h
    boolean getButton(int) -> a
    com.badlogic.gdx.controllers.ControllerMapping getMapping() -> a
    float getAxis(int) -> b
    java.lang.String getName() -> b
    com.badlogic.gdx.utils.Array getListeners() -> c
    boolean hasPovAxis() -> d
com.badlogic.gdx.controllers.android.AndroidControllerEvent -> com.badlogic.gdx.controllers.android.b:
    float axisValue -> d
    int type -> b
    int code -> c
    com.badlogic.gdx.controllers.android.AndroidController controller -> a
com.badlogic.gdx.controllers.android.AndroidControllerMapping -> com.badlogic.gdx.controllers.android.c:
    com.badlogic.gdx.controllers.android.AndroidControllerMapping instance -> k
    com.badlogic.gdx.controllers.android.AndroidControllerMapping getInstance() -> a
com.badlogic.gdx.controllers.android.AndroidControllers -> com.badlogic.gdx.controllers.android.AndroidControllers:
    com.badlogic.gdx.utils.IntMap controllerMap -> a
    boolean ignoreNoGamepadButtons -> f
    com.badlogic.gdx.utils.Array eventQueue -> d
    com.badlogic.gdx.utils.Array listeners -> c
    com.badlogic.gdx.utils.Array controllers -> b
    com.badlogic.gdx.utils.Pool eventPool -> e
    com.badlogic.gdx.utils.Array access$000(com.badlogic.gdx.controllers.android.AndroidControllers) -> a
    void addController(int,boolean) -> a
    void addListener(com.badlogic.gdx.controllers.ControllerListener) -> a
    void dispose() -> a
    boolean isController(android.view.InputDevice) -> a
    void removeController(int) -> a
    com.badlogic.gdx.utils.Array access$100(com.badlogic.gdx.controllers.android.AndroidControllers) -> b
    void gatherControllers(boolean) -> b
    void pause() -> b
    void removeListener(com.badlogic.gdx.controllers.ControllerListener) -> b
    com.badlogic.gdx.utils.Array access$200(com.badlogic.gdx.controllers.android.AndroidControllers) -> c
    void resume() -> c
    com.badlogic.gdx.utils.Pool access$300(com.badlogic.gdx.controllers.android.AndroidControllers) -> d
    com.badlogic.gdx.utils.Array getControllers() -> g
    void clearListeners() -> h
    void setupEventQueue() -> i
com.badlogic.gdx.controllers.android.AndroidControllers$1 -> com.badlogic.gdx.controllers.android.AndroidControllers$a:
    com.badlogic.gdx.controllers.android.AndroidControllerEvent newObject() -> a
    java.lang.Object newObject() -> a
com.badlogic.gdx.controllers.android.AndroidControllers$2 -> com.badlogic.gdx.controllers.android.AndroidControllers$b:
    com.badlogic.gdx.controllers.android.AndroidControllers this$0 -> a
com.badlogic.gdx.controllers.android.ControllerLifeCycleListener -> com.badlogic.gdx.controllers.android.d:
    android.hardware.input.InputManager inputManager -> a
    com.badlogic.gdx.controllers.android.AndroidControllers controllers -> b
    void dispose() -> a
    void pause() -> b
    void resume() -> c
com.badlogic.gdx.files.FileHandle -> b.a.a.v.a:
    java.io.File file -> a
    com.badlogic.gdx.Files$FileType type -> b
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    boolean exists() -> a
    java.io.BufferedInputStream read(int) -> a
    java.lang.String extension() -> b
    java.lang.String readString(java.lang.String) -> b
    java.io.BufferedReader reader(int) -> b
    java.io.File file() -> c
    java.io.Reader reader(java.lang.String) -> c
    long length() -> d
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> d
    java.lang.String name() -> e
    java.lang.String nameWithoutExtension() -> f
    com.badlogic.gdx.files.FileHandle parent() -> g
    java.lang.String path() -> h
    java.lang.String pathWithoutExtension() -> i
    java.io.InputStream read() -> j
    byte[] readBytes() -> k
    java.lang.String readString() -> l
    com.badlogic.gdx.Files$FileType type() -> m
    int estimateLength() -> n
com.badlogic.gdx.files.FileHandle$1 -> b.a.a.v.a$a:
    int[] $SwitchMap$com$badlogic$gdx$Files$FileType -> a
com.badlogic.gdx.graphics.Camera -> b.a.a.w.a:
    com.badlogic.gdx.math.Matrix4 projection -> d
    float viewportHeight -> k
    com.badlogic.gdx.math.Frustum frustum -> l
    com.badlogic.gdx.math.Vector3 direction -> b
    float viewportWidth -> j
    com.badlogic.gdx.math.Vector3 up -> c
    float far -> i
    com.badlogic.gdx.math.Matrix4 invProjectionView -> g
    float near -> h
    com.badlogic.gdx.math.Vector3 position -> a
    com.badlogic.gdx.math.Matrix4 view -> e
    com.badlogic.gdx.math.Matrix4 combined -> f
    com.badlogic.gdx.math.Vector3 project(com.badlogic.gdx.math.Vector3,float,float,float,float) -> a
    void rotate(com.badlogic.gdx.math.Vector3,float) -> a
    void update() -> a
    com.badlogic.gdx.math.Vector3 unproject(com.badlogic.gdx.math.Vector3,float,float,float,float) -> b
com.badlogic.gdx.graphics.Color -> b.a.a.w.b:
    com.badlogic.gdx.graphics.Color RED -> E
    com.badlogic.gdx.graphics.Color CORAL -> G
    com.badlogic.gdx.graphics.Color LIGHT_GRAY -> f
    com.badlogic.gdx.graphics.Color PINK -> I
    com.badlogic.gdx.graphics.Color DARK_GRAY -> h
    com.badlogic.gdx.graphics.Color PURPLE -> K
    float b -> c
    float r -> a
    com.badlogic.gdx.graphics.Color ORANGE -> A
    com.badlogic.gdx.graphics.Color TAN -> C
    com.badlogic.gdx.graphics.Color CHARTREUSE -> t
    com.badlogic.gdx.graphics.Color FOREST -> v
    com.badlogic.gdx.graphics.Color YELLOW -> x
    com.badlogic.gdx.graphics.Color GOLDENROD -> z
    com.badlogic.gdx.graphics.Color MAROON -> M
    com.badlogic.gdx.graphics.Color BLUE -> l
    com.badlogic.gdx.graphics.Color ROYAL -> n
    com.badlogic.gdx.graphics.Color SKY -> p
    com.badlogic.gdx.graphics.Color TEAL -> r
    com.badlogic.gdx.graphics.Color WHITE -> e
    com.badlogic.gdx.graphics.Color FIREBRICK -> D
    com.badlogic.gdx.graphics.Color GRAY -> g
    float WHITE_FLOAT_BITS -> j
    com.badlogic.gdx.graphics.Color SCARLET -> F
    com.badlogic.gdx.graphics.Color BLACK -> i
    com.badlogic.gdx.graphics.Color SALMON -> H
    com.badlogic.gdx.graphics.Color CLEAR -> k
    com.badlogic.gdx.graphics.Color MAGENTA -> J
    float a -> d
    float g -> b
    com.badlogic.gdx.graphics.Color BROWN -> B
    com.badlogic.gdx.graphics.Color LIME -> u
    com.badlogic.gdx.graphics.Color OLIVE -> w
    com.badlogic.gdx.graphics.Color GOLD -> y
    com.badlogic.gdx.graphics.Color NAVY -> m
    com.badlogic.gdx.graphics.Color VIOLET -> L
    com.badlogic.gdx.graphics.Color SLATE -> o
    com.badlogic.gdx.graphics.Color CYAN -> q
    com.badlogic.gdx.graphics.Color GREEN -> s
    void abgr8888ToColor(com.badlogic.gdx.graphics.Color,float) -> a
    com.badlogic.gdx.graphics.Color clamp() -> a
    com.badlogic.gdx.graphics.Color mul(com.badlogic.gdx.graphics.Color) -> a
    void rgba8888ToColor(com.badlogic.gdx.graphics.Color,int) -> a
    com.badlogic.gdx.graphics.Color set(float,float,float,float) -> a
    com.badlogic.gdx.graphics.Color set(int) -> a
    com.badlogic.gdx.graphics.Color valueOf(java.lang.String) -> a
    com.badlogic.gdx.graphics.Color valueOf(java.lang.String,com.badlogic.gdx.graphics.Color) -> a
    int rgba8888(float,float,float,float) -> b
    com.badlogic.gdx.graphics.Color set(com.badlogic.gdx.graphics.Color) -> b
    float toFloatBits() -> b
    int rgba8888(com.badlogic.gdx.graphics.Color) -> c
    float toFloatBits(float,float,float,float) -> c
    int toIntBits() -> c
com.badlogic.gdx.graphics.Colors -> b.a.a.w.c:
    com.badlogic.gdx.utils.ObjectMap map -> a
    com.badlogic.gdx.graphics.Color get(java.lang.String) -> a
    void reset() -> a
com.badlogic.gdx.graphics.Cubemap -> b.a.a.w.d:
    com.badlogic.gdx.graphics.CubemapData data -> i
    java.util.Map managedCubemaps -> k
    com.badlogic.gdx.assets.AssetManager assetManager -> j
    com.badlogic.gdx.graphics.CubemapData getCubemapData() -> C
    boolean isManaged() -> D
    void reload() -> E
    java.lang.String getManagedStatus() -> F
    void addManagedCubemap(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Cubemap) -> a
    void clearAllCubemaps(com.badlogic.gdx.Application) -> a
    void dispose() -> a
    void load(com.badlogic.gdx.graphics.CubemapData) -> a
    void invalidateAllCubemaps(com.badlogic.gdx.Application) -> b
com.badlogic.gdx.graphics.Cubemap$1 -> b.a.a.w.d$a:
    int val$refCount -> a
    void finishedLoading(com.badlogic.gdx.assets.AssetManager,java.lang.String,java.lang.Class) -> a
com.badlogic.gdx.graphics.CubemapData -> b.a.a.w.e:
    void prepare() -> d
    boolean isManaged() -> e
    boolean isPrepared() -> f
    void consumeCubemapData() -> k
com.badlogic.gdx.graphics.Cursor -> b.a.a.w.f:
com.badlogic.gdx.graphics.GL20 -> b.a.a.w.g:
    void glAttachShader(int,int) -> a
    void glBlendFuncSeparate(int,int,int,int) -> a
    void glBufferData(int,int,java.nio.Buffer,int) -> a
    void glClearColor(float,float,float,float) -> a
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> a
    void glDepthMask(boolean) -> a
    void glDrawElements(int,int,int,java.nio.Buffer) -> a
    void glFramebufferTexture2D(int,int,int,int,int) -> a
    int glGenRenderbuffer() -> a
    void glGenerateMipmap(int) -> a
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> a
    void glGetFloatv(int,java.nio.FloatBuffer) -> a
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> a
    void glShaderSource(int,java.lang.String) -> a
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> a
    void glTexParameterf(int,int,float) -> a
    void glTexParameteri(int,int,int) -> a
    void glUniformMatrix4fv(int,int,boolean,float[],int) -> a
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> a
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> a
    void glBindRenderbuffer(int,int) -> b
    void glBufferSubData(int,int,int,java.nio.Buffer) -> b
    void glDrawArrays(int,int,int) -> b
    void glFramebufferRenderbuffer(int,int,int,int) -> b
    int glGenBuffer() -> b
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> b
    int glGetAttribLocation(int,java.lang.String) -> b
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> b
    void glLinkProgram(int) -> b
    void glTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> b
    void glBindFramebuffer(int,int) -> c
    int glGetError() -> c
    java.lang.String glGetShaderInfoLog(int) -> c
    int glGetUniformLocation(int,java.lang.String) -> c
    void glScissor(int,int,int,int) -> c
    void glDisable(int) -> d
    int glGenTexture() -> d
    void glGetIntegerv(int,java.nio.IntBuffer) -> d
    void glRenderbufferStorage(int,int,int,int) -> d
    void glUniform1i(int,int) -> d
    void glBindBuffer(int,int) -> e
    int glCreateProgram() -> e
    void glDisableVertexAttribArray(int) -> e
    void glDeleteTexture(int) -> f
    int glGenFramebuffer() -> f
    void glPixelStorei(int,int) -> f
    void glViewport(int,int,int,int) -> f
    void glBindTexture(int,int) -> g
    void glCompileShader(int) -> g
    void glDrawElements(int,int,int,int) -> g
    void glEnable(int) -> h
    int glCheckFramebufferStatus(int) -> i
    void glUseProgram(int) -> j
    void glDeleteRenderbuffer(int) -> k
    java.lang.String glGetProgramInfoLog(int) -> l
    void glEnableVertexAttribArray(int) -> m
    java.lang.String glGetString(int) -> n
    void glClear(int) -> o
    void glDeleteFramebuffer(int) -> p
    int glCreateShader(int) -> q
    void glDeleteShader(int) -> s
    void glDeleteProgram(int) -> t
    void glDeleteBuffer(int) -> u
com.badlogic.gdx.graphics.GL30 -> b.a.a.w.h:
    void glDeleteVertexArrays(int,java.nio.IntBuffer) -> a
    void glTexImage3D(int,int,int,int,int,int,int,int,int,java.nio.Buffer) -> a
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> a
    void glDrawBuffers(int,java.nio.IntBuffer) -> b
    void glDrawElementsInstanced(int,int,int,int,int) -> b
    void glGenVertexArrays(int,java.nio.IntBuffer) -> c
    void glDrawArraysInstanced(int,int,int,int) -> e
    void glBindVertexArray(int) -> r
com.badlogic.gdx.graphics.GLTexture -> b.a.a.w.i:
    float maxAnisotropicFilterLevel -> h
    float anisotropicFilterLevel -> g
    int glHandle -> b
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> f
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> d
    int glTarget -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap getVWrap() -> A
    float getMaxAnisotropicFilterLevel() -> B
    void dispose() -> a
    void setFilter(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter) -> a
    void setWrap(com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap) -> a
    float unsafeSetAnisotropicFilter(float,boolean) -> a
    void unsafeSetFilter(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> a
    void unsafeSetWrap(com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap,boolean) -> a
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData) -> a
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData,int) -> a
    void bind() -> i
    void delete() -> v
    com.badlogic.gdx.graphics.Texture$TextureFilter getMagFilter() -> w
    com.badlogic.gdx.graphics.Texture$TextureFilter getMinFilter() -> x
    int getTextureObjectHandle() -> y
    com.badlogic.gdx.graphics.Texture$TextureWrap getUWrap() -> z
com.badlogic.gdx.graphics.Mesh -> b.a.a.w.j:
    com.badlogic.gdx.graphics.glutils.VertexData vertices -> a
    com.badlogic.gdx.graphics.glutils.IndexData indices -> b
    com.badlogic.gdx.graphics.glutils.InstanceData instances -> e
    boolean isInstanced -> f
    boolean autoBind -> c
    java.util.Map meshes -> h
    boolean isVertexArray -> d
    com.badlogic.gdx.math.Vector3 tmpV -> g
    void addManagedMesh(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Mesh) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    com.badlogic.gdx.math.collision.BoundingBox calculateBoundingBox(com.badlogic.gdx.math.collision.BoundingBox,int,int) -> a
    void clearAllMeshes(com.badlogic.gdx.Application) -> a
    void dispose() -> a
    com.badlogic.gdx.math.collision.BoundingBox extendBoundingBox(com.badlogic.gdx.math.collision.BoundingBox,int,int,com.badlogic.gdx.math.Matrix4) -> a
    com.badlogic.gdx.graphics.VertexAttribute getVertexAttribute(int) -> a
    com.badlogic.gdx.graphics.glutils.VertexData makeVertexBuffer(boolean,int,com.badlogic.gdx.graphics.VertexAttributes) -> a
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int) -> a
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int,int,int) -> a
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int,int,int,boolean) -> a
    com.badlogic.gdx.graphics.Mesh setIndices(short[]) -> a
    com.badlogic.gdx.graphics.Mesh setVertices(float[],int,int) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    com.badlogic.gdx.math.collision.BoundingBox extendBoundingBox(com.badlogic.gdx.math.collision.BoundingBox,int,int) -> b
    void invalidateAllMeshes(com.badlogic.gdx.Application) -> b
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> b
    int getNumVertices() -> f
    int getNumIndices() -> j
    java.nio.ShortBuffer getIndicesBuffer() -> v
    com.badlogic.gdx.graphics.VertexAttributes getVertexAttributes() -> w
    java.nio.FloatBuffer getVerticesBuffer() -> x
    java.lang.String getManagedStatus() -> y
com.badlogic.gdx.graphics.Mesh$1 -> b.a.a.w.j$a:
    int[] $SwitchMap$com$badlogic$gdx$graphics$Mesh$VertexDataType -> a
com.badlogic.gdx.graphics.Mesh$VertexDataType -> b.a.a.w.j$b:
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObject -> b
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObjectSubData -> c
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexArray -> a
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObjectWithVAO -> d
    com.badlogic.gdx.graphics.Mesh$VertexDataType[] $VALUES -> e
com.badlogic.gdx.graphics.OrthographicCamera -> b.a.a.w.k:
    com.badlogic.gdx.math.Vector3 tmp -> n
    float zoom -> m
    void rotate(float) -> a
    void update() -> a
    void update(boolean) -> a
com.badlogic.gdx.graphics.Pixmap -> b.a.a.w.l:
    com.badlogic.gdx.graphics.g2d.Gdx2DPixmap pixmap -> a
    int color -> b
    boolean disposed -> c
    int getHeight() -> A
    java.nio.ByteBuffer getPixels() -> B
    int getWidth() -> C
    void dispose() -> a
    void drawPixel(int,int,int) -> a
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int) -> a
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int) -> a
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int,int,int) -> a
    void setBlending(com.badlogic.gdx.graphics.Pixmap$Blending) -> a
    void setColor(float,float,float,float) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void drawPixel(int,int) -> b
    int getPixel(int,int) -> c
    void fill() -> v
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> w
    int getGLFormat() -> x
    int getGLInternalFormat() -> y
    int getGLType() -> z
com.badlogic.gdx.graphics.Pixmap$Blending -> b.a.a.w.l$a:
    com.badlogic.gdx.graphics.Pixmap$Blending[] $VALUES -> c
    com.badlogic.gdx.graphics.Pixmap$Blending None -> a
    com.badlogic.gdx.graphics.Pixmap$Blending SourceOver -> b
com.badlogic.gdx.graphics.Pixmap$Filter -> b.a.a.w.l$b:
    com.badlogic.gdx.graphics.Pixmap$Filter[] $VALUES -> c
    com.badlogic.gdx.graphics.Pixmap$Filter NearestNeighbour -> a
    com.badlogic.gdx.graphics.Pixmap$Filter BiLinear -> b
com.badlogic.gdx.graphics.Pixmap$Format -> b.a.a.w.l$c:
    com.badlogic.gdx.graphics.Pixmap$Format Alpha -> a
    com.badlogic.gdx.graphics.Pixmap$Format Intensity -> b
    com.badlogic.gdx.graphics.Pixmap$Format LuminanceAlpha -> c
    com.badlogic.gdx.graphics.Pixmap$Format RGB565 -> d
    com.badlogic.gdx.graphics.Pixmap$Format RGBA4444 -> e
    com.badlogic.gdx.graphics.Pixmap$Format RGB888 -> f
    com.badlogic.gdx.graphics.Pixmap$Format RGBA8888 -> g
    com.badlogic.gdx.graphics.Pixmap$Format[] $VALUES -> h
    com.badlogic.gdx.graphics.Pixmap$Format fromGdx2DPixmapFormat(int) -> a
    int toGdx2DPixmapFormat(com.badlogic.gdx.graphics.Pixmap$Format) -> a
com.badlogic.gdx.graphics.PixmapIO -> b.a.a.w.m:
    com.badlogic.gdx.graphics.Pixmap readCIM(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.PixmapIO$CIM -> b.a.a.w.m$a:
    byte[] readBuffer -> a
    com.badlogic.gdx.graphics.Pixmap read(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.Texture -> b.a.a.w.n:
    java.util.Map managedTextures -> k
    com.badlogic.gdx.assets.AssetManager assetManager -> j
    com.badlogic.gdx.graphics.TextureData data -> i
    int getHeight() -> C
    com.badlogic.gdx.graphics.TextureData getTextureData() -> D
    int getWidth() -> E
    boolean isManaged() -> F
    void reload() -> G
    java.lang.String getManagedStatus() -> H
    void addManagedTexture(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Texture) -> a
    void clearAllTextures(com.badlogic.gdx.Application) -> a
    void dispose() -> a
    void load(com.badlogic.gdx.graphics.TextureData) -> a
    void invalidateAllTextures(com.badlogic.gdx.Application) -> b
com.badlogic.gdx.graphics.Texture$1 -> b.a.a.w.n$a:
    int val$refCount -> a
    void finishedLoading(com.badlogic.gdx.assets.AssetManager,java.lang.String,java.lang.Class) -> a
com.badlogic.gdx.graphics.Texture$TextureFilter -> b.a.a.w.n$b:
    com.badlogic.gdx.graphics.Texture$TextureFilter Nearest -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearLinear -> h
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestLinear -> g
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearNearest -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestNearest -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMap -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter[] $VALUES -> i
    com.badlogic.gdx.graphics.Texture$TextureFilter Linear -> c
    int glEnum -> a
    int getGLEnum() -> a
    boolean isMipMap() -> b
com.badlogic.gdx.graphics.Texture$TextureWrap -> b.a.a.w.n$c:
    com.badlogic.gdx.graphics.Texture$TextureWrap MirroredRepeat -> b
    com.badlogic.gdx.graphics.Texture$TextureWrap Repeat -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap ClampToEdge -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap[] $VALUES -> e
    int glEnum -> a
    int getGLEnum() -> a
com.badlogic.gdx.graphics.TextureArray -> b.a.a.w.o:
    com.badlogic.gdx.graphics.TextureArrayData data -> i
    java.util.Map managedTextureArrays -> j
    boolean isManaged() -> C
    void reload() -> D
    void clearAllTextureArrays(com.badlogic.gdx.Application) -> a
    void load(com.badlogic.gdx.graphics.TextureArrayData) -> a
    void invalidateAllTextureArrays(com.badlogic.gdx.Application) -> b
com.badlogic.gdx.graphics.TextureArrayData -> b.a.a.w.p:
    int getDepth() -> a
    int getWidth() -> b
    int getHeight() -> c
    void prepare() -> d
    boolean isManaged() -> e
    boolean isPrepared() -> f
    int getGLType() -> g
    int getInternalFormat() -> h
    void consumeTextureArrayData() -> i
com.badlogic.gdx.graphics.TextureData -> b.a.a.w.q:
    void consumeCustomData(int) -> a
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    int getWidth() -> b
    int getHeight() -> c
    void prepare() -> d
    boolean isManaged() -> e
    boolean isPrepared() -> f
    boolean disposePixmap() -> g
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> h
    boolean useMipMaps() -> i
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> j
com.badlogic.gdx.graphics.TextureData$Factory -> b.a.a.w.q$a:
    com.badlogic.gdx.graphics.TextureData loadFromFile(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.Pixmap$Format,boolean) -> a
com.badlogic.gdx.graphics.TextureData$TextureDataType -> b.a.a.w.q$b:
    com.badlogic.gdx.graphics.TextureData$TextureDataType[] $VALUES -> c
    com.badlogic.gdx.graphics.TextureData$TextureDataType Pixmap -> a
    com.badlogic.gdx.graphics.TextureData$TextureDataType Custom -> b
com.badlogic.gdx.graphics.VertexAttribute -> b.a.a.w.r:
    java.lang.String alias -> f
    int usageIndex -> h
    int unit -> g
    int type -> d
    int offset -> e
    int numComponents -> b
    boolean normalized -> c
    int usage -> a
    com.badlogic.gdx.graphics.VertexAttribute BoneWeight(int) -> a
    boolean equals(com.badlogic.gdx.graphics.VertexAttribute) -> a
    int getKey() -> a
    com.badlogic.gdx.graphics.VertexAttribute TexCoords(int) -> b
    int getSizeInBytes() -> b
    com.badlogic.gdx.graphics.VertexAttribute Binormal() -> c
    com.badlogic.gdx.graphics.VertexAttribute ColorPacked() -> d
    com.badlogic.gdx.graphics.VertexAttribute ColorUnpacked() -> e
    com.badlogic.gdx.graphics.VertexAttribute Normal() -> f
    com.badlogic.gdx.graphics.VertexAttribute Position() -> g
    com.badlogic.gdx.graphics.VertexAttribute Tangent() -> h
com.badlogic.gdx.graphics.VertexAttributes -> b.a.a.w.s:
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterable iterable -> d
    long mask -> c
    int vertexSize -> b
    com.badlogic.gdx.graphics.VertexAttribute[] attributes -> a
    int compareTo(com.badlogic.gdx.graphics.VertexAttributes) -> a
    com.badlogic.gdx.graphics.VertexAttribute get(int) -> a
    long getMask() -> a
    int calculateOffsets() -> b
com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterable -> b.a.a.w.s$a:
    java.lang.Object[] array -> a
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator iterator2 -> c
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator iterator1 -> b
com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator -> b.a.a.w.s$b:
    java.lang.Object[] array -> a
    int index -> b
    boolean valid -> c
com.badlogic.gdx.graphics.g2d.Animation -> com.badlogic.gdx.graphics.g2d.a:
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode playMode -> e
    java.lang.Object[] keyFrames -> a
    float lastStateTime -> d
    float frameDuration -> b
    int lastFrameNumber -> c
    float getFrameDuration() -> a
    java.lang.Object getKeyFrame(float) -> a
    void setKeyFrames(java.lang.Object[]) -> a
    void setPlayMode(com.badlogic.gdx.graphics.g2d.Animation$PlayMode) -> a
    int getKeyFrameIndex(float) -> b
    boolean isAnimationFinished(float) -> c
    void setFrameDuration(float) -> d
com.badlogic.gdx.graphics.g2d.Animation$1 -> com.badlogic.gdx.graphics.g2d.a$a:
    int[] $SwitchMap$com$badlogic$gdx$graphics$g2d$Animation$PlayMode -> a
com.badlogic.gdx.graphics.g2d.Animation$PlayMode -> com.badlogic.gdx.graphics.g2d.a$b:
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode LOOP_RANDOM -> f
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode LOOP_PINGPONG -> e
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode[] $VALUES -> g
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode REVERSED -> b
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode NORMAL -> a
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode LOOP_REVERSED -> d
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode LOOP -> c
com.badlogic.gdx.graphics.g2d.Batch -> com.badlogic.gdx.graphics.g2d.b:
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.Texture,float[],int,int) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float,boolean) -> a
    void setBlendFunction(int,int) -> a
    void setColor(float,float,float,float) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setPackedColor(float) -> a
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> a
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> b
    void end() -> k
    com.badlogic.gdx.graphics.Color getColor() -> n
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> o
    void begin() -> r
    float getPackedColor() -> s
com.badlogic.gdx.graphics.g2d.BitmapFont -> com.badlogic.gdx.graphics.g2d.c:
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData data -> a
    boolean integer -> e
    boolean ownsTexture -> f
    com.badlogic.gdx.utils.Array regions -> b
    boolean flipped -> d
    float getScaleX() -> A
    float getScaleY() -> B
    boolean isFlipped() -> C
    com.badlogic.gdx.graphics.g2d.BitmapFontCache newFontCache() -> D
    boolean usesIntegerPositions() -> E
    void dispose() -> a
    com.badlogic.gdx.graphics.g2d.GlyphLayout draw(com.badlogic.gdx.graphics.g2d.Batch,java.lang.CharSequence,float,float) -> a
    com.badlogic.gdx.graphics.g2d.GlyphLayout draw(com.badlogic.gdx.graphics.g2d.Batch,java.lang.CharSequence,float,float,int,int,float,int,boolean) -> a
    com.badlogic.gdx.graphics.g2d.GlyphLayout draw(com.badlogic.gdx.graphics.g2d.Batch,java.lang.CharSequence,float,float,int,int,float,int,boolean,java.lang.String) -> a
    void load(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> a
    void setColor(float,float,float,float) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.graphics.Color getColor() -> n
    float getCapHeight() -> v
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData getData() -> w
    float getDescent() -> x
    float getLineHeight() -> y
    com.badlogic.gdx.utils.Array getRegions() -> z
com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData -> com.badlogic.gdx.graphics.g2d.c$a:
    float ascent -> k
    float lineHeight -> i
    com.badlogic.gdx.files.FileHandle fontFile -> c
    float padBottom -> g
    float padTop -> e
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph missingGlyph -> t
    char[] capChars -> y
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph[][] glyphs -> s
    boolean markupEnabled -> q
    float spaceXadvance -> u
    char[] xChars -> x
    java.lang.String name -> a
    float scaleX -> o
    boolean flipped -> d
    float down -> m
    float descent -> l
    float capHeight -> j
    float padLeft -> h
    float padRight -> f
    java.lang.String[] imagePaths -> b
    float xHeight -> v
    char[] breakChars -> w
    float cursorX -> r
    float scaleY -> p
    float blankLineScale -> n
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getFirstGlyph() -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getGlyph(char) -> a
    void getGlyphs(com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun,java.lang.CharSequence,int,int,com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph) -> a
    java.lang.String getImagePath(int) -> a
    int getWrapIndex(com.badlogic.gdx.utils.Array,int) -> a
    void load(com.badlogic.gdx.files.FileHandle,boolean) -> a
    void setGlyph(int,com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph) -> a
    void setGlyphRegion(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
    void setScale(float) -> a
    void setScale(float,float) -> a
    java.lang.String[] getImagePaths() -> b
    boolean hasGlyph(char) -> b
    boolean isBreakChar(char) -> c
    boolean isWhitespace(char) -> d
com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph -> com.badlogic.gdx.graphics.g2d.c$b:
    boolean fixedWidth -> n
    int page -> o
    int xadvance -> l
    float v2 -> i
    float u2 -> h
    int xoffset -> j
    float v -> g
    int yoffset -> k
    float u -> f
    int width -> d
    int height -> e
    int srcX -> b
    int srcY -> c
    byte[][] kerning -> m
    int id -> a
    int getKerning(char) -> a
    void setKerning(int,int) -> a
com.badlogic.gdx.graphics.g2d.BitmapFontCache -> com.badlogic.gdx.graphics.g2d.d:
    float currentTint -> i
    float y -> g
    com.badlogic.gdx.graphics.Color color -> h
    float x -> f
    com.badlogic.gdx.utils.IntArray[] pageGlyphIndices -> l
    int glyphCount -> e
    com.badlogic.gdx.utils.Array pooledLayouts -> d
    com.badlogic.gdx.utils.Array layouts -> c
    com.badlogic.gdx.graphics.Color tempColor -> n
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    float[][] pageVertices -> j
    boolean integer -> b
    int[] idx -> k
    int[] tempGlyphCount -> m
    void addGlyph(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,float,float,float) -> a
    com.badlogic.gdx.graphics.g2d.GlyphLayout addText(java.lang.CharSequence,float,float) -> a
    com.badlogic.gdx.graphics.g2d.GlyphLayout addText(java.lang.CharSequence,float,float,int,int,float,int,boolean) -> a
    com.badlogic.gdx.graphics.g2d.GlyphLayout addText(java.lang.CharSequence,float,float,int,int,float,int,boolean,java.lang.String) -> a
    void addText(com.badlogic.gdx.graphics.g2d.GlyphLayout,float,float) -> a
    void clear() -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void requireGlyphs(com.badlogic.gdx.graphics.g2d.GlyphLayout) -> a
    void requirePageGlyphs(int,int) -> a
    void setPosition(float,float) -> a
    void tint(com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.graphics.Color getColor() -> b
    void setText(com.badlogic.gdx.graphics.g2d.GlyphLayout,float,float) -> b
    void translate(float,float) -> b
    void addToCache(com.badlogic.gdx.graphics.g2d.GlyphLayout,float,float) -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont getFont() -> c
com.badlogic.gdx.graphics.g2d.Gdx2DPixmap -> com.badlogic.gdx.graphics.g2d.Gdx2DPixmap:
    long[] nativeData -> f
    long basePtr -> a
    java.nio.ByteBuffer pixelPtr -> e
    int format -> d
    int width -> b
    int height -> c
    java.nio.ByteBuffer getPixels() -> A
    int getWidth() -> B
    void clear(int) -> a
    void dispose() -> a
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int) -> a
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int,int,int) -> a
    void setPixel(int,int,int) -> a
    int getPixel(int,int) -> b
    void setBlend(int) -> b
    void convert(int) -> c
    java.lang.String getFormatString(int) -> d
    int toGlFormat(int) -> e
    int toGlType(int) -> f
    int getFormat() -> v
    int getGLFormat() -> w
    int getGLInternalFormat() -> x
    int getGLType() -> y
    int getHeight() -> z
com.badlogic.gdx.graphics.g2d.GlyphLayout -> com.badlogic.gdx.graphics.g2d.e:
    com.badlogic.gdx.utils.Pool glyphRunPool -> d
    com.badlogic.gdx.utils.Array runs -> a
    float height -> c
    float width -> b
    com.badlogic.gdx.utils.Pool colorPool -> e
    com.badlogic.gdx.utils.Array colorStack -> f
    void adjustLastGlyph(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData,com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun) -> a
    int parseColorMarkup(java.lang.CharSequence,int,int,com.badlogic.gdx.utils.Pool) -> a
    void reset() -> a
    void setText(com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.CharSequence) -> a
    void setText(com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.CharSequence,int,int,com.badlogic.gdx.graphics.Color,float,int,boolean,java.lang.String) -> a
    void setText(com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.CharSequence,com.badlogic.gdx.graphics.Color,float,int,boolean) -> a
    void truncate(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData,com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun,float,java.lang.String,int,com.badlogic.gdx.utils.Pool) -> a
    com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun wrap(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData,com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun,int,int) -> a
com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun -> com.badlogic.gdx.graphics.g2d.e$a:
    com.badlogic.gdx.graphics.Color color -> f
    com.badlogic.gdx.utils.Array glyphs -> a
    float width -> e
    float y -> d
    float x -> c
    com.badlogic.gdx.utils.FloatArray xAdvances -> b
    void reset() -> a
com.badlogic.gdx.graphics.g2d.NinePatch -> com.badlogic.gdx.graphics.g2d.f:
    float rightWidth -> l
    float leftWidth -> k
    int topRight -> j
    int topLeft -> h
    int topCenter -> i
    int middleCenter -> f
    int middleRight -> g
    int bottomRight -> d
    int middleLeft -> e
    int bottomLeft -> b
    int bottomCenter -> c
    com.badlogic.gdx.graphics.Texture texture -> a
    com.badlogic.gdx.graphics.Color tmpDrawColor -> x
    float padBottom -> w
    float padTop -> v
    float padRight -> u
    float padLeft -> t
    float bottomHeight -> p
    float[] vertices -> q
    int idx -> r
    float topHeight -> o
    float middleHeight -> n
    com.badlogic.gdx.graphics.Color color -> s
    float middleWidth -> m
    int add(com.badlogic.gdx.graphics.g2d.TextureRegion,boolean,boolean) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> a
    float getBottomHeight() -> a
    void load(com.badlogic.gdx.graphics.g2d.TextureRegion[]) -> a
    void scale(float,float) -> a
    void set(int,float,float,float,float,float) -> a
    void setPadding(float,float,float,float) -> a
    float getLeftWidth() -> b
    void prepareVertices(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> b
    float getPadBottom() -> c
    float getPadLeft() -> d
    float getPadRight() -> e
    float getPadTop() -> f
    float getRightWidth() -> g
    float getTopHeight() -> h
    float getTotalHeight() -> i
    float getTotalWidth() -> j
com.badlogic.gdx.graphics.g2d.ParticleEffect -> com.badlogic.gdx.graphics.g2d.g:
    com.badlogic.gdx.utils.Array emitters -> a
    float motionScale -> e
    float ySizeScale -> d
    float xSizeScale -> c
    boolean ownsTexture -> b
    void dispose() -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle) -> a
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.TextureAtlas) -> a
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.TextureAtlas,java.lang.String) -> a
    void loadEmitterImages(com.badlogic.gdx.files.FileHandle) -> a
    void loadEmitterImages(com.badlogic.gdx.graphics.g2d.TextureAtlas,java.lang.String) -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter newEmitter(com.badlogic.gdx.graphics.g2d.ParticleEmitter) -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter newEmitter(java.io.BufferedReader) -> a
    void setPosition(float,float) -> a
    void loadEmitters(com.badlogic.gdx.files.FileHandle) -> b
    void reset(boolean) -> b
    void scaleEffect(float,float,float) -> b
    com.badlogic.gdx.graphics.Texture loadTexture(com.badlogic.gdx.files.FileHandle) -> c
    void setEmittersCleanUpBlendFunction(boolean) -> c
    void scaleEffect(float) -> e
    void update(float) -> f
    com.badlogic.gdx.utils.Array getEmitters() -> v
    boolean isComplete() -> w
    void start() -> x
com.badlogic.gdx.graphics.g2d.ParticleEffectPool -> com.badlogic.gdx.graphics.g2d.h:
    com.badlogic.gdx.graphics.g2d.ParticleEffect effect -> d
    void free(com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect) -> a
    com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect newObject() -> a
    java.lang.Object newObject() -> a
    void free(java.lang.Object) -> b
com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect -> com.badlogic.gdx.graphics.g2d.h$a:
    com.badlogic.gdx.graphics.g2d.ParticleEffectPool this$0 -> f
    void free() -> y
com.badlogic.gdx.graphics.g2d.ParticleEmitter -> com.badlogic.gdx.graphics.g2d.i:
    boolean continuous -> d0
    int emissionDiff -> O
    boolean behind -> f0
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue rotationValue -> h
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue gravityValue -> l
    int activeCount -> G
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue[] xSizeValues -> t
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue xOffsetValue -> o
    float durationTimer -> Z
    float accumulator -> w
    float spawnWidthDiff -> V
    int lifeDiff -> T
    float delay -> a0
    int emissionDelta -> P
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue windValue -> k
    boolean allowCompletion -> M
    int updateFlags -> L
    boolean firstUpdate -> I
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue delayValue -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue tintValue -> n
    float x -> C
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpriteMode spriteMode -> y
    float spawnHeight -> W
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue yScaleValue -> g
    boolean premultipliedAlpha -> h0
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$IndependentScaledNumericValue lifeOffsetValue -> b
    int lifeOffset -> Q
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue angleValue -> j
    boolean aligned -> e0
    boolean additive -> g0
    boolean flipX -> J
    boolean attached -> c0
    float y -> D
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue spawnHeightValue -> r
    com.badlogic.gdx.utils.Array sprites -> x
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue[] motionValues -> v
    int minParticleCount -> A
    float spawnHeightDiff -> X
    int lifeOffsetDiff -> R
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue xScaleValue -> f
    float delayTimer -> b0
    int emission -> N
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue velocityValue -> i
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue durationValue -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue transparencyValue -> m
    boolean flipY -> K
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle[] particles -> z
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue spawnWidthValue -> q
    int maxParticleCount -> B
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue[] ySizeValues -> u
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue yOffsetValue -> p
    boolean[] active -> H
    float duration -> Y
    float spawnWidth -> U
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$IndependentScaledNumericValue lifeValue -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShapeValue spawnShapeValue -> s
    int life -> S
    boolean cleansUpBlendFunction -> i0
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue emissionValue -> e
    java.lang.String name -> E
    com.badlogic.gdx.utils.Array imagePaths -> F
    void addParticle() -> a
    void addParticles(int) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void load(java.io.BufferedReader) -> a
    void matchMotion(com.badlogic.gdx.graphics.g2d.ParticleEmitter) -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle newParticle(com.badlogic.gdx.graphics.g2d.Sprite) -> a
    boolean readBoolean(java.io.BufferedReader,java.lang.String) -> a
    boolean readBoolean(java.lang.String) -> a
    void scaleMotion(float) -> a
    void scaleSize(float,float) -> a
    void setCleansUpBlendFunction(boolean) -> a
    void setImagePaths(com.badlogic.gdx.utils.Array) -> a
    boolean updateParticle(com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle,float,int) -> a
    com.badlogic.gdx.utils.Array getImagePaths() -> b
    void matchSize(com.badlogic.gdx.graphics.g2d.ParticleEmitter) -> b
    float readFloat(java.io.BufferedReader,java.lang.String) -> b
    java.lang.String readString(java.lang.String) -> b
    void setContinuous(boolean) -> b
    void setMaxParticleCount(int) -> b
    void setPosition(float,float) -> b
    void setSprites(com.badlogic.gdx.utils.Array) -> b
    void update(float) -> b
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue[] getMotionValues() -> c
    void matchXSize(com.badlogic.gdx.graphics.g2d.ParticleEmitter) -> c
    int readInt(java.io.BufferedReader,java.lang.String) -> c
    void setMinParticleCount(int) -> c
    void activateParticle(int) -> d
    com.badlogic.gdx.utils.Array getSprites() -> d
    void matchYSize(com.badlogic.gdx.graphics.g2d.ParticleEmitter) -> d
    java.lang.String readString(java.io.BufferedReader,java.lang.String) -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue getTint() -> e
    float getX() -> f
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue[] getXSizeValues() -> g
    float getY() -> h
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue[] getYSizeValues() -> i
    boolean isAdditive() -> j
    boolean isComplete() -> k
    void reset() -> l
    void start() -> m
    void generateLifeOffsetValues() -> n
    void generateLifeValues() -> o
    void initialize() -> p
    void restart() -> q
com.badlogic.gdx.graphics.g2d.ParticleEmitter$1 -> com.badlogic.gdx.graphics.g2d.i$a:
    int[] $SwitchMap$com$badlogic$gdx$graphics$g2d$ParticleEmitter$SpawnEllipseSide -> b
    int[] $SwitchMap$com$badlogic$gdx$graphics$g2d$ParticleEmitter$SpawnShape -> c
    int[] $SwitchMap$com$badlogic$gdx$graphics$g2d$ParticleEmitter$SpriteMode -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue -> com.badlogic.gdx.graphics.g2d.i$b:
    float[] temp -> e
    float[] colors -> c
    float[] timeline -> d
    float[] getColor(float) -> a
    float[] getColors() -> a
    void load(com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue) -> a
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$IndependentScaledNumericValue -> com.badlogic.gdx.graphics.g2d.i$c:
    boolean independent -> j
    void load(com.badlogic.gdx.graphics.g2d.ParticleEmitter$IndependentScaledNumericValue) -> a
    void load(java.io.BufferedReader) -> a
    void set(com.badlogic.gdx.graphics.g2d.ParticleEmitter$IndependentScaledNumericValue) -> b
    void set(com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue) -> b
    void set(com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue) -> b
com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle -> com.badlogic.gdx.graphics.g2d.i$d:
    float windDiff -> L
    float wind -> K
    float transparencyDiff -> J
    float transparency -> I
    float angleSin -> H
    float angleCos -> G
    float angleDiff -> F
    float angle -> E
    float velocityDiff -> D
    float velocity -> C
    float rotationDiff -> B
    float rotation -> A
    float yScaleDiff -> z
    float yScale -> y
    float xScaleDiff -> x
    float xScale -> w
    int currentLife -> v
    int life -> u
    float gravityDiff -> N
    float[] tint -> O
    int frame -> P
    float gravity -> M
com.badlogic.gdx.graphics.g2d.ParticleEmitter$ParticleValue -> com.badlogic.gdx.graphics.g2d.i$e:
    boolean active -> a
    boolean alwaysActive -> b
    void load(com.badlogic.gdx.graphics.g2d.ParticleEmitter$ParticleValue) -> a
    void load(java.io.BufferedReader) -> a
    void setActive(boolean) -> a
    void setAlwaysActive(boolean) -> b
com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue -> com.badlogic.gdx.graphics.g2d.i$f:
    float lowMax -> d
    float lowMin -> c
    void load(com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue) -> a
    void load(java.io.BufferedReader) -> a
    float newLowValue() -> a
    void scale(float) -> a
    void set(com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue) -> b
com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue -> com.badlogic.gdx.graphics.g2d.i$g:
    float highMax -> h
    boolean relative -> i
    float highMin -> g
    float[] scaling -> e
    float[] timeline -> f
    void load(com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue) -> a
    void load(java.io.BufferedReader) -> a
    void scale(float) -> a
    float getScale(float) -> b
    boolean isRelative() -> b
    void set(com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue) -> b
    void set(com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue) -> b
    float newHighValue() -> c
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide -> com.badlogic.gdx.graphics.g2d.i$h:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide[] $VALUES -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide both -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide bottom -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide top -> b
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape -> com.badlogic.gdx.graphics.g2d.i$i:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape[] $VALUES -> e
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape ellipse -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape point -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape square -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape line -> b
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShapeValue -> com.badlogic.gdx.graphics.g2d.i$j:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide side -> e
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape shape -> c
    boolean edges -> d
    void load(com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShapeValue) -> a
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpriteMode -> com.badlogic.gdx.graphics.g2d.i$k:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpriteMode random -> b
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpriteMode animated -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpriteMode single -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpriteMode[] $VALUES -> d
com.badlogic.gdx.graphics.g2d.PixmapPacker -> com.badlogic.gdx.graphics.g2d.j:
    boolean stripWhitespaceY -> i
    int alphaThreshold -> j
    com.badlogic.gdx.graphics.Pixmap$Format pageFormat -> e
    com.badlogic.gdx.graphics.Color transparentColor -> k
    java.util.regex.Pattern indexPattern -> o
    int padding -> f
    int pageHeight -> d
    int pageWidth -> c
    com.badlogic.gdx.utils.Array pages -> l
    com.badlogic.gdx.graphics.g2d.PixmapPacker$PackStrategy packStrategy -> m
    boolean duplicateBorder -> g
    boolean stripWhitespaceX -> h
    com.badlogic.gdx.graphics.Color c -> n
    boolean packToTexture -> a
    boolean disposed -> b
    void dispose() -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas generateTextureAtlas(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> a
    int[] getPads(com.badlogic.gdx.graphics.Pixmap,int[]) -> a
    int getPageIndex(java.lang.String) -> a
    int getSplitPoint(com.badlogic.gdx.graphics.Pixmap,int,int,boolean,boolean) -> a
    int[] getSplits(com.badlogic.gdx.graphics.Pixmap) -> a
    com.badlogic.gdx.math.Rectangle pack(java.lang.String,com.badlogic.gdx.graphics.Pixmap) -> a
    void updateTextureAtlas(com.badlogic.gdx.graphics.g2d.TextureAtlas,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> a
    void updateTextureAtlas(com.badlogic.gdx.graphics.g2d.TextureAtlas,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean,boolean) -> a
    com.badlogic.gdx.math.Rectangle getRect(java.lang.String) -> b
    void updatePageTextures(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> b
    com.badlogic.gdx.graphics.Color getTransparentColor() -> v
com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy -> com.badlogic.gdx.graphics.g2d.j$a:
    com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$Node insert(com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$Node,com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.graphics.g2d.PixmapPacker$Page pack(com.badlogic.gdx.graphics.g2d.PixmapPacker,java.lang.String,com.badlogic.gdx.math.Rectangle) -> a
com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$GuillotinePage -> com.badlogic.gdx.graphics.g2d.j$a$a:
    com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$Node root -> f
com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$Node -> com.badlogic.gdx.graphics.g2d.j$a$b:
    com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$Node leftChild -> a
    com.badlogic.gdx.graphics.g2d.PixmapPacker$GuillotineStrategy$Node rightChild -> b
    com.badlogic.gdx.math.Rectangle rect -> c
    boolean full -> d
com.badlogic.gdx.graphics.g2d.PixmapPacker$PackStrategy -> com.badlogic.gdx.graphics.g2d.j$b:
    com.badlogic.gdx.graphics.g2d.PixmapPacker$Page pack(com.badlogic.gdx.graphics.g2d.PixmapPacker,java.lang.String,com.badlogic.gdx.math.Rectangle) -> a
com.badlogic.gdx.graphics.g2d.PixmapPacker$Page -> com.badlogic.gdx.graphics.g2d.j$c:
    com.badlogic.gdx.graphics.Pixmap image -> b
    boolean dirty -> e
    com.badlogic.gdx.utils.OrderedMap rects -> a
    com.badlogic.gdx.utils.Array addedRects -> d
    com.badlogic.gdx.graphics.Texture texture -> c
    boolean updateTexture(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> a
com.badlogic.gdx.graphics.g2d.PixmapPacker$Page$1 -> com.badlogic.gdx.graphics.g2d.j$c$a:
    com.badlogic.gdx.graphics.g2d.PixmapPacker$Page this$0 -> l
    void dispose() -> a
com.badlogic.gdx.graphics.g2d.PixmapPacker$PixmapPackerRectangle -> com.badlogic.gdx.graphics.g2d.j$d:
    int[] splits -> f
    int[] pads -> g
    int originalWidth -> j
    int originalHeight -> k
    int offsetX -> h
    int offsetY -> i
com.badlogic.gdx.graphics.g2d.PolygonRegion -> com.badlogic.gdx.graphics.g2d.k:
com.badlogic.gdx.graphics.g2d.PolygonRegionLoader -> com.badlogic.gdx.graphics.g2d.l:
    com.badlogic.gdx.math.EarClippingTriangulator triangulator -> c
    com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters defaultParameters -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters) -> a
    com.badlogic.gdx.graphics.g2d.PolygonRegion load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters) -> a
    com.badlogic.gdx.graphics.g2d.PolygonRegion load(com.badlogic.gdx.graphics.g2d.TextureRegion,com.badlogic.gdx.files.FileHandle) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters -> com.badlogic.gdx.graphics.g2d.l$a:
    java.lang.String[] textureExtensions -> d
    java.lang.String texturePrefix -> b
    int readerBuffer -> c
com.badlogic.gdx.graphics.g2d.Sprite -> com.badlogic.gdx.graphics.g2d.m:
    float width -> l
    float y -> k
    float x -> j
    com.badlogic.gdx.graphics.Color color -> i
    float[] vertices -> h
    boolean dirty -> s
    float scaleY -> r
    float scaleX -> q
    float rotation -> p
    float originY -> o
    float originX -> n
    com.badlogic.gdx.math.Rectangle bounds -> t
    float height -> m
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void flip(boolean,boolean) -> a
    void rotate90(boolean) -> a
    void set(com.badlogic.gdx.graphics.g2d.Sprite) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setOrigin(float,float) -> a
    void setPackedColor(float) -> a
    void setRegion(float,float,float,float) -> a
    void setBounds(float,float,float,float) -> b
    void setFlip(boolean,boolean) -> b
    void setPosition(float,float) -> b
    void setRotation(float) -> b
    void setColor(float,float,float,float) -> c
    void setScale(float) -> c
    void setScale(float,float) -> c
    void setSize(float,float) -> d
    void setX(float) -> d
    void setY(float) -> e
    void translate(float,float) -> e
    com.badlogic.gdx.math.Rectangle getBoundingRectangle() -> m
    com.badlogic.gdx.graphics.Color getColor() -> n
    float getHeight() -> o
    float getOriginX() -> p
    float getOriginY() -> q
    float[] getVertices() -> r
    float getWidth() -> s
    float getX() -> t
    float getY() -> u
    void setOriginCenter() -> v
com.badlogic.gdx.graphics.g2d.SpriteBatch -> com.badlogic.gdx.graphics.g2d.n:
    int blendSrcFuncAlpha -> l
    int blendDstFuncAlpha -> m
    boolean ownsShader -> p
    com.badlogic.gdx.graphics.Mesh$VertexDataType defaultVertexDataType -> v
    boolean blendingDisabled -> i
    int blendSrcFunc -> j
    int blendDstFunc -> k
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> n
    com.badlogic.gdx.graphics.glutils.ShaderProgram customShader -> o
    float[] vertices -> b
    int idx -> c
    com.badlogic.gdx.graphics.Mesh mesh -> a
    com.badlogic.gdx.graphics.Texture lastTexture -> d
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> g
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> h
    com.badlogic.gdx.math.Matrix4 transformMatrix -> f
    boolean drawing -> e
    float colorPacked -> r
    int totalRenderCalls -> t
    int maxSpritesInBatch -> u
    com.badlogic.gdx.graphics.Color color -> q
    int renderCalls -> s
    void dispose() -> a
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.Texture,float[],int,int) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float,boolean) -> a
    void setBlendFunction(int,int) -> a
    void setBlendFunctionSeparate(int,int,int,int) -> a
    void setColor(float,float,float,float) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setPackedColor(float) -> a
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> a
    void switchTexture(com.badlogic.gdx.graphics.Texture) -> a
    boolean isBlendingEnabled() -> b
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> b
    void setupMatrices() -> c
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader() -> d
    void end() -> k
    com.badlogic.gdx.graphics.Color getColor() -> n
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> o
    void begin() -> r
    float getPackedColor() -> s
com.badlogic.gdx.graphics.g2d.TextureAtlas -> com.badlogic.gdx.graphics.g2d.o:
    com.badlogic.gdx.utils.ObjectSet textures -> a
    com.badlogic.gdx.utils.Array regions -> b
    com.badlogic.gdx.graphics.g2d.Sprite createSprite(java.lang.String) -> a
    void dispose() -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion findRegion(java.lang.String,int) -> a
    void load(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData) -> a
    com.badlogic.gdx.graphics.g2d.Sprite newSprite(com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion) -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion findRegion(java.lang.String) -> b
    com.badlogic.gdx.utils.Array findRegions(java.lang.String) -> c
    com.badlogic.gdx.utils.Array getRegions() -> v
    com.badlogic.gdx.utils.ObjectSet getTextures() -> w
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion -> com.badlogic.gdx.graphics.g2d.o$a:
    int originalWidth -> n
    int[][] values -> s
    float offsetY -> k
    int originalHeight -> o
    java.lang.String name -> i
    float offsetX -> j
    int packedWidth -> l
    int packedHeight -> m
    boolean rotate -> p
    int index -> h
    int degrees -> q
    java.lang.String[] names -> r
    int[] findValue(java.lang.String) -> a
    void flip(boolean,boolean) -> a
    float getRotatedPackedHeight() -> m
    float getRotatedPackedWidth() -> n
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasSprite -> com.badlogic.gdx.graphics.g2d.o$b:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion region -> u
    float originalOffsetY -> w
    float originalOffsetX -> v
    void flip(boolean,boolean) -> a
    void rotate90(boolean) -> a
    void setOrigin(float,float) -> a
    void setBounds(float,float,float,float) -> b
    void setSize(float,float) -> d
    float getHeight() -> o
    float getOriginX() -> p
    float getOriginY() -> q
    float getWidth() -> s
    float getX() -> t
    float getY() -> u
    float getHeightRatio() -> w
    float getWidthRatio() -> x
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData -> com.badlogic.gdx.graphics.g2d.o$c:
    com.badlogic.gdx.utils.Array pages -> a
    com.badlogic.gdx.utils.Array regions -> b
    com.badlogic.gdx.utils.Array getPages() -> a
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle,boolean) -> a
    int readEntry(java.lang.String[],java.lang.String) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$1 -> com.badlogic.gdx.graphics.g2d.o$c$f:
    java.lang.String[] val$entry -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> a
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$10 -> com.badlogic.gdx.graphics.g2d.o$c$a:
    java.lang.String[] val$entry -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$11 -> com.badlogic.gdx.graphics.g2d.o$c$b:
    java.lang.String[] val$entry -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$12 -> com.badlogic.gdx.graphics.g2d.o$c$c:
    java.lang.String[] val$entry -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$13 -> com.badlogic.gdx.graphics.g2d.o$c$d:
    boolean[] val$hasIndexes -> b
    java.lang.String[] val$entry -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$14 -> com.badlogic.gdx.graphics.g2d.o$c$e:
    int compare(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region,com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$2 -> com.badlogic.gdx.graphics.g2d.o$c$g:
    java.lang.String[] val$entry -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> a
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$3 -> com.badlogic.gdx.graphics.g2d.o$c$h:
    java.lang.String[] val$entry -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> a
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$4 -> com.badlogic.gdx.graphics.g2d.o$c$i:
    java.lang.String[] val$entry -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> a
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$5 -> com.badlogic.gdx.graphics.g2d.o$c$j:
    java.lang.String[] val$entry -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> a
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$6 -> com.badlogic.gdx.graphics.g2d.o$c$k:
    java.lang.String[] val$entry -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$7 -> com.badlogic.gdx.graphics.g2d.o$c$l:
    java.lang.String[] val$entry -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$8 -> com.badlogic.gdx.graphics.g2d.o$c$m:
    java.lang.String[] val$entry -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$9 -> com.badlogic.gdx.graphics.g2d.o$c$n:
    java.lang.String[] val$entry -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Field -> com.badlogic.gdx.graphics.g2d.o$c$o:
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page -> com.badlogic.gdx.graphics.g2d.o$c$p:
    com.badlogic.gdx.files.FileHandle textureFile -> a
    boolean pma -> k
    com.badlogic.gdx.graphics.Pixmap$Format format -> f
    float height -> d
    boolean useMipMaps -> e
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> j
    float width -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> i
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> h
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> g
    com.badlogic.gdx.graphics.Texture texture -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region -> com.badlogic.gdx.graphics.g2d.o$c$q:
    int index -> m
    boolean flip -> p
    float offsetY -> h
    int originalHeight -> j
    float offsetX -> g
    int degrees -> k
    int originalWidth -> i
    boolean rotate -> l
    int height -> f
    int top -> d
    int width -> e
    int left -> c
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page page -> a
    java.lang.String[] names -> n
    int[][] values -> o
    java.lang.String name -> b
com.badlogic.gdx.graphics.g2d.TextureRegion -> com.badlogic.gdx.graphics.g2d.p:
    float v2 -> e
    float u2 -> d
    int regionWidth -> f
    float v -> c
    int regionHeight -> g
    float u -> b
    com.badlogic.gdx.graphics.Texture texture -> a
    void flip(boolean,boolean) -> a
    void setRegion(float,float,float,float) -> a
    void setRegion(int,int,int,int) -> a
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion,int,int,int,int) -> a
    void setTexture(com.badlogic.gdx.graphics.Texture) -> a
    int getRegionHeight() -> b
    int getRegionWidth() -> c
    int getRegionX() -> d
    int getRegionY() -> e
    com.badlogic.gdx.graphics.Texture getTexture() -> f
    float getU() -> g
    float getU2() -> h
    float getV() -> i
    float getV2() -> j
    boolean isFlipX() -> k
    boolean isFlipY() -> l
com.badlogic.gdx.graphics.g3d.Attribute -> b.a.a.w.t.a:
    long type -> a
    com.badlogic.gdx.utils.Array types -> c
    int typeBit -> b
    boolean equals(com.badlogic.gdx.graphics.g3d.Attribute) -> a
    java.lang.String getAttributeAlias(long) -> a
    long getAttributeType(java.lang.String) -> a
    long register(java.lang.String) -> b
com.badlogic.gdx.graphics.g3d.Attributes -> b.a.a.w.t.b:
    long mask -> a
    com.badlogic.gdx.utils.Array attributes -> b
    boolean sorted -> c
    int attributesHash() -> a
    int compare(com.badlogic.gdx.graphics.g3d.Attribute,com.badlogic.gdx.graphics.g3d.Attribute) -> a
    int compareTo(com.badlogic.gdx.graphics.g3d.Attributes) -> a
    boolean has(long) -> a
    boolean same(com.badlogic.gdx.graphics.g3d.Attributes,boolean) -> a
    void set(com.badlogic.gdx.graphics.g3d.Attribute) -> a
    int indexOf(long) -> b
    void sort() -> b
    void enable(long) -> c
com.badlogic.gdx.graphics.g3d.Material -> b.a.a.w.t.c:
    int counter -> e
    java.lang.String id -> d
com.badlogic.gdx.graphics.g3d.Model -> b.a.a.w.t.d:
    com.badlogic.gdx.utils.ObjectMap nodePartBones -> g
    com.badlogic.gdx.utils.Array materials -> a
    com.badlogic.gdx.utils.Array meshParts -> e
    com.badlogic.gdx.utils.Array meshes -> d
    com.badlogic.gdx.utils.Array animations -> c
    com.badlogic.gdx.utils.Array nodes -> b
    com.badlogic.gdx.utils.Array disposables -> f
    com.badlogic.gdx.graphics.g3d.Material convertMaterial(com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial,com.badlogic.gdx.graphics.g3d.utils.TextureProvider) -> a
    void convertMesh(com.badlogic.gdx.graphics.g3d.model.data.ModelMesh) -> a
    void dispose() -> a
    com.badlogic.gdx.graphics.g3d.model.Node getNode(java.lang.String) -> a
    com.badlogic.gdx.graphics.g3d.model.Node getNode(java.lang.String,boolean) -> a
    com.badlogic.gdx.graphics.g3d.model.Node getNode(java.lang.String,boolean,boolean) -> a
    void load(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.graphics.g3d.utils.TextureProvider) -> a
    void loadAnimations(java.lang.Iterable) -> a
    void loadMaterials(java.lang.Iterable,com.badlogic.gdx.graphics.g3d.utils.TextureProvider) -> a
    com.badlogic.gdx.graphics.g3d.model.Node loadNode(com.badlogic.gdx.graphics.g3d.model.data.ModelNode) -> a
    void loadMeshes(java.lang.Iterable) -> b
    void loadNodes(java.lang.Iterable) -> c
    void calculateTransforms() -> v
    java.lang.Iterable getManagedDisposables() -> w
com.badlogic.gdx.graphics.g3d.RenderableProvider -> b.a.a.w.t.e:
com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute -> b.a.a.w.t.f.a:
    float opacity -> g
    long Type -> h
    int destFunction -> f
    int sourceFunction -> e
    boolean blended -> d
    int compareTo(com.badlogic.gdx.graphics.g3d.Attribute) -> b
com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute -> b.a.a.w.t.f.b:
    long AmbientLight -> j
    long Reflection -> i
    com.badlogic.gdx.graphics.Color color -> d
    long Mask -> l
    long Fog -> k
    long Specular -> f
    long Diffuse -> e
    long Emissive -> h
    long Ambient -> g
    int compareTo(com.badlogic.gdx.graphics.g3d.Attribute) -> b
    boolean is(long) -> b
com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute -> b.a.a.w.t.f.c:
    long Shininess -> e
    float value -> d
    int compareTo(com.badlogic.gdx.graphics.g3d.Attribute) -> b
com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute -> b.a.a.w.t.f.d:
    long Diffuse -> j
    long Bump -> l
    long Specular -> k
    com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor textureDescription -> d
    float scaleV -> h
    float scaleU -> g
    float offsetV -> f
    float offsetU -> e
    int uvIndex -> i
    long Mask -> q
    long Ambient -> n
    long Normal -> m
    long Reflection -> p
    long Emissive -> o
    int compareTo(com.badlogic.gdx.graphics.g3d.Attribute) -> b
    boolean is(long) -> b
com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader -> b.a.a.w.t.g.a:
    com.badlogic.gdx.utils.BaseJsonReader reader -> d
    com.badlogic.gdx.math.Quaternion tempQ -> e
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
    void parseAnimations(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue) -> a
    com.badlogic.gdx.graphics.VertexAttribute[] parseAttributes(com.badlogic.gdx.utils.JsonValue) -> a
    void parseMaterials(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue,java.lang.String) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelData parseModel(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.math.Vector2 readVector2(com.badlogic.gdx.utils.JsonValue,float,float) -> a
    com.badlogic.gdx.graphics.Color parseColor(com.badlogic.gdx.utils.JsonValue) -> b
    void parseMeshes(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue) -> b
    int parseTextureUsage(java.lang.String) -> b
    com.badlogic.gdx.utils.Array parseNodes(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue) -> c
    com.badlogic.gdx.graphics.g3d.model.data.ModelNode parseNodesRecursively(com.badlogic.gdx.utils.JsonValue) -> c
    int parseType(java.lang.String) -> c
com.badlogic.gdx.graphics.g3d.loader.MtlLoader -> b.a.a.w.t.g.b:
    com.badlogic.gdx.utils.Array materials -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial getMaterial(java.lang.String) -> a
    void load(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.g3d.loader.ObjLoader -> b.a.a.w.t.g.c:
    com.badlogic.gdx.utils.FloatArray uvs -> f
    com.badlogic.gdx.utils.FloatArray verts -> d
    com.badlogic.gdx.utils.FloatArray norms -> e
    boolean logWarning -> h
    com.badlogic.gdx.utils.Array groups -> g
    int getIndex(java.lang.String,int) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.loader.ObjLoader$ObjLoaderParameters) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,boolean) -> a
    com.badlogic.gdx.graphics.g3d.loader.ObjLoader$Group setActiveGroup(java.lang.String) -> b
com.badlogic.gdx.graphics.g3d.loader.ObjLoader$Group -> b.a.a.w.t.g.c$a:
    boolean hasNorms -> e
    boolean hasUVs -> f
    java.lang.String name -> a
    com.badlogic.gdx.utils.Array faces -> c
    int numFaces -> d
    java.lang.String materialName -> b
com.badlogic.gdx.graphics.g3d.loader.ObjLoader$ObjLoaderParameters -> b.a.a.w.t.g.c$b:
    boolean flipV -> c
com.badlogic.gdx.graphics.g3d.model.Animation -> b.a.a.w.t.h.a:
    float duration -> a
    com.badlogic.gdx.utils.Array nodeAnimations -> b
com.badlogic.gdx.graphics.g3d.model.MeshPart -> b.a.a.w.t.h.b:
    com.badlogic.gdx.math.collision.BoundingBox bounds -> h
    com.badlogic.gdx.graphics.Mesh mesh -> e
    java.lang.String id -> a
    int size -> d
    int primitiveType -> b
    int offset -> c
    com.badlogic.gdx.math.Vector3 center -> f
    com.badlogic.gdx.math.Vector3 halfExtents -> g
    boolean equals(com.badlogic.gdx.graphics.g3d.model.MeshPart) -> a
    void update() -> a
com.badlogic.gdx.graphics.g3d.model.Node -> b.a.a.w.t.h.c:
    com.badlogic.gdx.math.Vector3 translation -> d
    com.badlogic.gdx.utils.Array children -> k
    com.badlogic.gdx.math.Matrix4 localTransform -> g
    com.badlogic.gdx.math.Matrix4 globalTransform -> h
    com.badlogic.gdx.math.Quaternion rotation -> e
    com.badlogic.gdx.graphics.g3d.model.Node parent -> j
    java.lang.String id -> a
    com.badlogic.gdx.utils.Array parts -> i
    boolean inheritTransform -> b
    boolean isAnimated -> c
    com.badlogic.gdx.math.Vector3 scale -> f
    int addChild(com.badlogic.gdx.graphics.g3d.model.Node) -> a
    void calculateBoneTransforms(boolean) -> a
    com.badlogic.gdx.math.Matrix4 calculateLocalTransform() -> a
    com.badlogic.gdx.graphics.g3d.model.Node getNode(com.badlogic.gdx.utils.Array,java.lang.String,boolean,boolean) -> a
    int insertChild(int,com.badlogic.gdx.graphics.g3d.model.Node) -> a
    void calculateTransforms(boolean) -> b
    com.badlogic.gdx.math.Matrix4 calculateWorldTransform() -> b
    boolean removeChild(com.badlogic.gdx.graphics.g3d.model.Node) -> b
    com.badlogic.gdx.graphics.g3d.model.Node getParent() -> c
com.badlogic.gdx.graphics.g3d.model.NodeAnimation -> b.a.a.w.t.h.d:
    com.badlogic.gdx.utils.Array translation -> a
    com.badlogic.gdx.utils.Array scaling -> c
    com.badlogic.gdx.utils.Array rotation -> b
com.badlogic.gdx.graphics.g3d.model.NodeKeyframe -> b.a.a.w.t.h.e:
com.badlogic.gdx.graphics.g3d.model.NodePart -> b.a.a.w.t.h.f:
    com.badlogic.gdx.math.Matrix4[] bones -> b
    com.badlogic.gdx.utils.ArrayMap invBoneBindTransforms -> a
com.badlogic.gdx.graphics.g3d.model.data.ModelAnimation -> b.a.a.w.t.h.g.a:
    java.lang.String id -> a
    com.badlogic.gdx.utils.Array nodeAnimations -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelData -> b.a.a.w.t.h.g.b:
    com.badlogic.gdx.utils.Array animations -> e
    com.badlogic.gdx.utils.Array nodes -> d
    com.badlogic.gdx.utils.Array materials -> c
    short[] version -> a
    com.badlogic.gdx.utils.Array meshes -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial -> b.a.a.w.t.h.g.c:
    com.badlogic.gdx.graphics.Color emissive -> e
    com.badlogic.gdx.graphics.Color specular -> d
    com.badlogic.gdx.graphics.Color reflection -> f
    float opacity -> h
    float shininess -> g
    java.lang.String id -> a
    com.badlogic.gdx.utils.Array textures -> i
    com.badlogic.gdx.graphics.Color diffuse -> c
    com.badlogic.gdx.graphics.Color ambient -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelMesh -> b.a.a.w.t.h.g.d:
    com.badlogic.gdx.graphics.g3d.model.data.ModelMeshPart[] parts -> c
    float[] vertices -> b
    com.badlogic.gdx.graphics.VertexAttribute[] attributes -> a
com.badlogic.gdx.graphics.g3d.model.data.ModelMeshPart -> b.a.a.w.t.h.g.e:
    java.lang.String id -> a
    short[] indices -> b
    int primitiveType -> c
com.badlogic.gdx.graphics.g3d.model.data.ModelNode -> b.a.a.w.t.h.g.f:
    com.badlogic.gdx.math.Vector3 scale -> d
    com.badlogic.gdx.math.Vector3 translation -> b
    com.badlogic.gdx.graphics.g3d.model.data.ModelNodePart[] parts -> e
    com.badlogic.gdx.math.Quaternion rotation -> c
    java.lang.String id -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelNode[] children -> f
com.badlogic.gdx.graphics.g3d.model.data.ModelNodeAnimation -> b.a.a.w.t.h.g.g:
    com.badlogic.gdx.utils.Array scaling -> d
    java.lang.String nodeId -> a
    com.badlogic.gdx.utils.Array rotation -> c
    com.badlogic.gdx.utils.Array translation -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelNodeKeyframe -> b.a.a.w.t.h.g.h:
    java.lang.Object value -> b
    float keytime -> a
com.badlogic.gdx.graphics.g3d.model.data.ModelNodePart -> b.a.a.w.t.h.g.i:
    com.badlogic.gdx.utils.ArrayMap bones -> c
    java.lang.String materialId -> a
    java.lang.String meshPartId -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelTexture -> b.a.a.w.t.h.g.j:
    com.badlogic.gdx.math.Vector2 uvScaling -> c
    com.badlogic.gdx.math.Vector2 uvTranslation -> b
    java.lang.String fileName -> a
    int usage -> d
com.badlogic.gdx.graphics.g3d.particles.ParticleController -> b.a.a.w.t.i.a:
    com.badlogic.gdx.graphics.g3d.particles.renderers.ParticleControllerRenderer renderer -> c
    float deltaTime -> d
    com.badlogic.gdx.utils.Array influencers -> b
    com.badlogic.gdx.graphics.g3d.particles.emitters.Emitter emitter -> a
    void dispose() -> a
    void load(com.badlogic.gdx.assets.AssetManager,com.badlogic.gdx.graphics.g3d.particles.ResourceData) -> a
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> a
    void setTimeStep(float) -> a
com.badlogic.gdx.graphics.g3d.particles.ParticleControllerComponent -> b.a.a.w.t.i.b:
    void dispose() -> a
    void load(com.badlogic.gdx.assets.AssetManager,com.badlogic.gdx.graphics.g3d.particles.ResourceData) -> a
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.graphics.g3d.particles.ParticleEffect -> b.a.a.w.t.i.c:
    com.badlogic.gdx.utils.Array controllers -> a
    void dispose() -> a
    void load(com.badlogic.gdx.assets.AssetManager,com.badlogic.gdx.graphics.g3d.particles.ResourceData) -> a
    void setBatch(com.badlogic.gdx.utils.Array) -> a
com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader -> b.a.a.w.t.i.d:
    com.badlogic.gdx.utils.Array items -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader$ParticleEffectLoadParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader$ParticleEffectLoadParameter) -> a
    com.badlogic.gdx.graphics.g3d.particles.ParticleEffect loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader$ParticleEffectLoadParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader$ParticleEffectLoadParameter -> b.a.a.w.t.i.d$a:
    com.badlogic.gdx.utils.Array batches -> b
com.badlogic.gdx.graphics.g3d.particles.ResourceData -> b.a.a.w.t.i.e:
    java.lang.Object resource -> d
    com.badlogic.gdx.utils.ObjectMap uniqueData -> a
    com.badlogic.gdx.utils.Array sharedAssets -> c
    com.badlogic.gdx.utils.Array data -> b
    com.badlogic.gdx.utils.Array getAssets() -> a
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.graphics.g3d.particles.ResourceData$AssetData -> b.a.a.w.t.i.e$a:
    java.lang.String filename -> a
    java.lang.Class type -> b
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.graphics.g3d.particles.ResourceData$Configurable -> b.a.a.w.t.i.e$b:
com.badlogic.gdx.graphics.g3d.particles.ResourceData$SaveData -> b.a.a.w.t.i.e$c:
    com.badlogic.gdx.graphics.g3d.particles.ResourceData resources -> b
    com.badlogic.gdx.utils.IntArray assets -> a
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch -> b.a.a.w.t.i.f.a:
    void load(com.badlogic.gdx.assets.AssetManager,com.badlogic.gdx.graphics.g3d.particles.ResourceData) -> a
com.badlogic.gdx.graphics.g3d.particles.emitters.Emitter -> b.a.a.w.t.i.g.a:
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.graphics.g3d.particles.influencers.Influencer -> b.a.a.w.t.i.h.a:
com.badlogic.gdx.graphics.g3d.particles.renderers.ParticleControllerRenderer -> b.a.a.w.t.i.i.a:
    boolean isCompatible(com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch) -> a
    boolean setBatch(com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch) -> b
com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor -> b.a.a.w.t.j.a:
    com.badlogic.gdx.graphics.GLTexture texture -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> b
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> c
    int compareTo(com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor) -> a
    void set(com.badlogic.gdx.graphics.GLTexture,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap) -> a
    void set(com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor) -> b
com.badlogic.gdx.graphics.g3d.utils.TextureProvider -> b.a.a.w.t.j.b:
    com.badlogic.gdx.graphics.Texture load(java.lang.String) -> a
com.badlogic.gdx.graphics.g3d.utils.TextureProvider$AssetTextureProvider -> b.a.a.w.t.j.b$a:
    com.badlogic.gdx.assets.AssetManager assetManager -> a
    com.badlogic.gdx.graphics.Texture load(java.lang.String) -> a
com.badlogic.gdx.graphics.glutils.ETC1 -> com.badlogic.gdx.graphics.glutils.ETC1:
    int ETC1_RGB8_OES -> b
    int PKM_HEADER_SIZE -> a
    com.badlogic.gdx.graphics.Pixmap decodeImage(com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data,com.badlogic.gdx.graphics.Pixmap$Format) -> a
    int getPixelSize(com.badlogic.gdx.graphics.Pixmap$Format) -> a
com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data -> com.badlogic.gdx.graphics.glutils.ETC1$a:
    int dataOffset -> d
    java.nio.ByteBuffer compressedData -> c
    int height -> b
    int width -> a
    void dispose() -> a
    boolean hasPKMHeader() -> v
    void checkNPOT() -> w
com.badlogic.gdx.graphics.glutils.ETC1TextureData -> com.badlogic.gdx.graphics.glutils.a:
    com.badlogic.gdx.files.FileHandle file -> a
    boolean isPrepared -> f
    int width -> d
    com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data data -> b
    int height -> e
    boolean useMipMaps -> c
    void consumeCustomData(int) -> a
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    int getWidth() -> b
    int getHeight() -> c
    void prepare() -> d
    boolean isManaged() -> e
    boolean isPrepared() -> f
    boolean disposePixmap() -> g
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> h
    boolean useMipMaps() -> i
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> j
com.badlogic.gdx.graphics.glutils.FileTextureData -> com.badlogic.gdx.graphics.glutils.b:
    com.badlogic.gdx.graphics.Pixmap pixmap -> e
    com.badlogic.gdx.files.FileHandle file -> a
    com.badlogic.gdx.graphics.Pixmap$Format format -> d
    boolean useMipMaps -> f
    boolean isPrepared -> g
    int width -> b
    int height -> c
    void consumeCustomData(int) -> a
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    int getWidth() -> b
    int getHeight() -> c
    void prepare() -> d
    boolean isManaged() -> e
    boolean isPrepared() -> f
    boolean disposePixmap() -> g
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> h
    boolean useMipMaps() -> i
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> j
com.badlogic.gdx.graphics.glutils.GLFrameBuffer -> com.badlogic.gdx.graphics.glutils.c:
    int defaultFramebufferHandle -> j
    com.badlogic.gdx.utils.Array textureAttachments -> a
    boolean defaultFramebufferHandleInitialized -> k
    java.util.Map buffers -> i
    boolean hasDepthStencilPackedBuffer -> f
    int stencilbufferHandle -> d
    boolean isMRT -> g
    int depthStencilPackedBufferHandle -> e
    int framebufferHandle -> b
    int depthbufferHandle -> c
    com.badlogic.gdx.graphics.glutils.GLFrameBuffer$GLFrameBufferBuilder bufferBuilder -> h
    void addManagedFrameBuffer(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.glutils.GLFrameBuffer) -> a
    void attachFrameBufferColorTexture(com.badlogic.gdx.graphics.GLTexture) -> a
    void clearAllFrameBuffers(com.badlogic.gdx.Application) -> a
    com.badlogic.gdx.graphics.GLTexture createTexture(com.badlogic.gdx.graphics.glutils.GLFrameBuffer$FrameBufferTextureAttachmentSpec) -> a
    void dispose() -> a
    java.lang.StringBuilder getManagedStatus(java.lang.StringBuilder) -> a
    void disposeColorTexture(com.badlogic.gdx.graphics.GLTexture) -> b
    void invalidateAllFrameBuffers(com.badlogic.gdx.Application) -> b
    void build() -> v
    void checkValidBuilder() -> w
    java.lang.String getManagedStatus() -> x
com.badlogic.gdx.graphics.glutils.GLFrameBuffer$FrameBufferRenderBufferAttachmentSpec -> com.badlogic.gdx.graphics.glutils.c$a:
    int internalFormat -> a
com.badlogic.gdx.graphics.glutils.GLFrameBuffer$FrameBufferTextureAttachmentSpec -> com.badlogic.gdx.graphics.glutils.c$b:
    boolean isFloat -> a
    boolean isDepth -> b
    boolean isStencil -> c
    boolean isColorTexture() -> a
com.badlogic.gdx.graphics.glutils.GLFrameBuffer$GLFrameBufferBuilder -> com.badlogic.gdx.graphics.glutils.c$c:
    com.badlogic.gdx.graphics.glutils.GLFrameBuffer$FrameBufferRenderBufferAttachmentSpec packedStencilDepthRenderBufferSpec -> f
    com.badlogic.gdx.graphics.glutils.GLFrameBuffer$FrameBufferRenderBufferAttachmentSpec depthRenderBufferSpec -> e
    com.badlogic.gdx.graphics.glutils.GLFrameBuffer$FrameBufferRenderBufferAttachmentSpec stencilRenderBufferSpec -> d
    boolean hasPackedStencilDepthRenderBuffer -> i
    com.badlogic.gdx.utils.Array textureAttachmentSpecs -> c
    boolean hasStencilRenderBuffer -> g
    boolean hasDepthRenderBuffer -> h
    int height -> b
    int width -> a
com.badlogic.gdx.graphics.glutils.GLVersion -> com.badlogic.gdx.graphics.glutils.d:
    com.badlogic.gdx.graphics.glutils.GLVersion$Type type -> b
    int majorVersion -> a
    void extractVersion(java.lang.String,java.lang.String) -> a
    int getMajorVersion() -> a
    int parseInt(java.lang.String,int) -> a
com.badlogic.gdx.graphics.glutils.GLVersion$Type -> com.badlogic.gdx.graphics.glutils.d$a:
    com.badlogic.gdx.graphics.glutils.GLVersion$Type WebGL -> c
    com.badlogic.gdx.graphics.glutils.GLVersion$Type GLES -> b
    com.badlogic.gdx.graphics.glutils.GLVersion$Type NONE -> d
    com.badlogic.gdx.graphics.glutils.GLVersion$Type OpenGL -> a
    com.badlogic.gdx.graphics.glutils.GLVersion$Type[] $VALUES -> e
com.badlogic.gdx.graphics.glutils.HdpiMode -> com.badlogic.gdx.graphics.glutils.e:
    com.badlogic.gdx.graphics.glutils.HdpiMode Pixels -> b
    com.badlogic.gdx.graphics.glutils.HdpiMode Logical -> a
    com.badlogic.gdx.graphics.glutils.HdpiMode[] $VALUES -> c
com.badlogic.gdx.graphics.glutils.HdpiUtils -> com.badlogic.gdx.graphics.glutils.f:
    com.badlogic.gdx.graphics.glutils.HdpiMode mode -> a
    void glScissor(int,int,int,int) -> a
    int toBackBufferX(int) -> a
    void glViewport(int,int,int,int) -> b
    int toBackBufferY(int) -> b
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer -> com.badlogic.gdx.graphics.glutils.h:
    void begin(com.badlogic.gdx.math.Matrix4,int) -> a
    void color(float) -> a
    void color(float,float,float,float) -> a
    void dispose() -> a
    void vertex(float,float,float) -> a
    int getNumVertices() -> f
    int getMaxVertices() -> g
    void end() -> k
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20 -> com.badlogic.gdx.graphics.glutils.g:
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> f
    float[] vertices -> l
    int colorOffset -> j
    int numTexCoords -> h
    int vertexSize -> i
    com.badlogic.gdx.math.Matrix4 projModelView -> k
    int numVertices -> d
    int vertexIdx -> b
    int maxVertices -> c
    int primitiveType -> a
    java.lang.String[] shaderUniformNames -> m
    com.badlogic.gdx.graphics.Mesh mesh -> e
    boolean ownsShader -> g
    void begin(com.badlogic.gdx.math.Matrix4,int) -> a
    com.badlogic.gdx.graphics.VertexAttribute[] buildVertexAttributes(boolean,boolean,int) -> a
    void color(float) -> a
    void color(float,float,float,float) -> a
    void dispose() -> a
    void vertex(float,float,float) -> a
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader(boolean,boolean,int) -> b
    void flush() -> b
    java.lang.String createFragmentShader(boolean,boolean,int) -> c
    java.lang.String createVertexShader(boolean,boolean,int) -> d
    int getNumVertices() -> f
    int getMaxVertices() -> g
    void end() -> k
com.badlogic.gdx.graphics.glutils.IndexArray -> com.badlogic.gdx.graphics.glutils.i:
    java.nio.ShortBuffer buffer -> a
    java.nio.ByteBuffer byteBuffer -> b
    boolean empty -> c
    void dispose() -> a
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> d
    void invalidate() -> e
    int getNumMaxIndices() -> h
    void bind() -> i
    int getNumIndices() -> j
    void unbind() -> l
com.badlogic.gdx.graphics.glutils.IndexBufferObject -> com.badlogic.gdx.graphics.glutils.j:
    boolean isDirty -> e
    boolean isBound -> f
    int usage -> g
    java.nio.ShortBuffer buffer -> a
    int bufferHandle -> d
    boolean empty -> h
    java.nio.ByteBuffer byteBuffer -> b
    boolean ownsBuffer -> c
    void dispose() -> a
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> d
    void invalidate() -> e
    int getNumMaxIndices() -> h
    void bind() -> i
    int getNumIndices() -> j
    void unbind() -> l
com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData -> com.badlogic.gdx.graphics.glutils.k:
    boolean isBound -> e
    int usage -> f
    java.nio.ShortBuffer buffer -> a
    java.nio.ByteBuffer byteBuffer -> b
    int bufferHandle -> c
    boolean isDirty -> d
    void dispose() -> a
    void setIndices(short[],int,int) -> a
    int createBufferObject() -> b
    java.nio.ShortBuffer getBuffer() -> d
    void invalidate() -> e
    int getNumMaxIndices() -> h
    void bind() -> i
    int getNumIndices() -> j
    void unbind() -> l
com.badlogic.gdx.graphics.glutils.IndexData -> com.badlogic.gdx.graphics.glutils.l:
    void dispose() -> a
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> d
    void invalidate() -> e
    int getNumMaxIndices() -> h
    void bind() -> i
    int getNumIndices() -> j
    void unbind() -> l
com.badlogic.gdx.graphics.glutils.InstanceData -> com.badlogic.gdx.graphics.glutils.m:
    void dispose() -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    int getNumInstances() -> u
com.badlogic.gdx.graphics.glutils.KTXTextureData -> com.badlogic.gdx.graphics.glutils.n:
    boolean useMipMaps -> m
    com.badlogic.gdx.files.FileHandle file -> a
    java.nio.ByteBuffer compressedData -> l
    int numberOfMipmapLevels -> j
    int imagePos -> k
    int numberOfArrayElements -> h
    int numberOfFaces -> i
    int pixelHeight -> f
    int pixelDepth -> g
    int glInternalFormat -> d
    int pixelWidth -> e
    int glType -> b
    int glFormat -> c
    void consumeCustomData(int) -> a
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    int getWidth() -> b
    int getHeight() -> c
    void prepare() -> d
    boolean isManaged() -> e
    boolean isPrepared() -> f
    boolean disposePixmap() -> g
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> h
    boolean useMipMaps() -> i
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> j
    void consumeCubemapData() -> k
    void disposePreparedData() -> l
com.badlogic.gdx.graphics.glutils.MipMapGenerator -> com.badlogic.gdx.graphics.glutils.o:
    boolean useHWMipMap -> a
    void generateMipMap(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> a
    void generateMipMapGLES20(int,com.badlogic.gdx.graphics.Pixmap) -> a
    void generateMipMapCPU(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> b
    void generateMipMapDesktop(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> c
com.badlogic.gdx.graphics.glutils.PixmapTextureData -> com.badlogic.gdx.graphics.glutils.p:
    com.badlogic.gdx.graphics.Pixmap$Format format -> b
    com.badlogic.gdx.graphics.Pixmap pixmap -> a
    boolean managed -> e
    boolean useMipMaps -> c
    boolean disposePixmap -> d
    void consumeCustomData(int) -> a
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    int getWidth() -> b
    int getHeight() -> c
    void prepare() -> d
    boolean isManaged() -> e
    boolean isPrepared() -> f
    boolean disposePixmap() -> g
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> h
    boolean useMipMaps() -> i
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> j
com.badlogic.gdx.graphics.glutils.ShaderProgram -> com.badlogic.gdx.graphics.glutils.q:
    com.badlogic.gdx.utils.ObjectIntMap attributeSizes -> i
    int vertexShaderHandle -> l
    int fragmentShaderHandle -> m
    boolean invalidated -> p
    com.badlogic.gdx.utils.ObjectIntMap attributes -> g
    java.nio.IntBuffer params -> q
    com.badlogic.gdx.utils.ObjectIntMap attributeTypes -> h
    int program -> k
    com.badlogic.gdx.utils.ObjectIntMap uniformSizes -> e
    java.lang.String fragmentShaderSource -> o
    java.lang.String vertexShaderSource -> n
    java.lang.String[] uniformNames -> f
    java.nio.IntBuffer type -> r
    boolean pedantic -> s
    java.lang.String prependFragmentCode -> u
    java.lang.String prependVertexCode -> t
    com.badlogic.gdx.utils.ObjectMap shaders -> v
    java.lang.String[] attributeNames -> j
    com.badlogic.gdx.utils.ObjectIntMap uniforms -> c
    com.badlogic.gdx.utils.ObjectIntMap uniformTypes -> d
    java.lang.String log -> a
    boolean isCompiled -> b
    void fetchUniforms() -> A
    java.lang.String getManagedStatus() -> B
    void addManagedShader(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void clearAllShaderPrograms(com.badlogic.gdx.Application) -> a
    void compileShaders(java.lang.String,java.lang.String) -> a
    void disableVertexAttribute(int) -> a
    void disableVertexAttribute(java.lang.String) -> a
    void dispose() -> a
    int fetchUniformLocation(java.lang.String,boolean) -> a
    int loadShader(int,java.lang.String) -> a
    void setUniformMatrix(int,com.badlogic.gdx.math.Matrix4,boolean) -> a
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4) -> a
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4,boolean) -> a
    void setUniformi(java.lang.String,int) -> a
    void setVertexAttribute(int,int,int,boolean,int,int) -> a
    void setVertexAttribute(int,int,int,boolean,int,java.nio.Buffer) -> a
    void enableVertexAttribute(int) -> b
    int getAttributeLocation(java.lang.String) -> b
    void invalidateAllShaderPrograms(com.badlogic.gdx.Application) -> b
    int fetchAttributeLocation(java.lang.String) -> c
    int linkProgram(int) -> c
    int fetchUniformLocation(java.lang.String) -> d
    void bind() -> i
    int createProgram() -> v
    java.lang.String getLog() -> w
    boolean isCompiled() -> x
    void checkManaged() -> y
    void fetchAttributes() -> z
com.badlogic.gdx.graphics.glutils.ShapeRenderer -> com.badlogic.gdx.graphics.glutils.r:
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> c
    com.badlogic.gdx.math.Matrix4 transformMatrix -> d
    com.badlogic.gdx.graphics.Color color -> f
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> e
    com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer renderer -> a
    boolean autoShapeType -> h
    boolean matrixDirty -> b
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType shapeType -> g
    void begin(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType) -> a
    void check(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType,com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType,int) -> a
    void dispose() -> a
    void rect(float,float,float,float,float,float,float,float,float) -> a
    void rect(float,float,float,float,float,float,float,float,float,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> a
    void rect(float,float,float,float) -> b
    void set(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType) -> b
    void setAutoShapeType(boolean) -> b
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> b
    void end() -> k
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> o
    void begin() -> r
    boolean isDrawing() -> v
com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType -> com.badlogic.gdx.graphics.glutils.r$a:
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType[] $VALUES -> e
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Filled -> d
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Line -> c
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Point -> b
    int glType -> a
    int getGlType() -> a
com.badlogic.gdx.graphics.glutils.VertexArray -> com.badlogic.gdx.graphics.glutils.s:
    java.nio.FloatBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    void dispose() -> a
    void setVertices(float[],int,int) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    java.nio.FloatBuffer getBuffer() -> d
    void invalidate() -> e
    int getNumVertices() -> f
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> g
com.badlogic.gdx.graphics.glutils.VertexBufferObject -> com.badlogic.gdx.graphics.glutils.t:
    java.nio.FloatBuffer buffer -> b
    int usage -> f
    boolean isDirty -> g
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> e
    boolean isBound -> h
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    boolean ownsBuffer -> d
    void dispose() -> a
    void setBuffer(java.nio.Buffer,boolean,com.badlogic.gdx.graphics.VertexAttributes) -> a
    void setUsage(int) -> a
    void setVertices(float[],int,int) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    void bufferChanged() -> b
    java.nio.FloatBuffer getBuffer() -> d
    void invalidate() -> e
    int getNumVertices() -> f
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> g
com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData -> com.badlogic.gdx.graphics.glutils.u:
    java.nio.FloatBuffer buffer -> b
    boolean isDirect -> e
    int usage -> f
    int bufferHandle -> d
    boolean isDirty -> g
    java.nio.ByteBuffer byteBuffer -> c
    boolean isBound -> h
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    void dispose() -> a
    void setVertices(float[],int,int) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    void bufferChanged() -> b
    int createBufferObject() -> c
    java.nio.FloatBuffer getBuffer() -> d
    void invalidate() -> e
    int getNumVertices() -> f
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> g
com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO -> com.badlogic.gdx.graphics.glutils.v:
    java.nio.FloatBuffer buffer -> b
    java.nio.IntBuffer tmpHandle -> k
    int vaoHandle -> i
    int usage -> f
    boolean isDirty -> g
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> e
    boolean isBound -> h
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    com.badlogic.gdx.utils.IntArray cachedLocations -> j
    boolean ownsBuffer -> d
    void bindData(com.badlogic.gdx.graphics.GL20) -> a
    void dispose() -> a
    void setVertices(float[],int,int) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void unbindAttributes(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    void bufferChanged() -> b
    void bindAttributes(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> c
    void createVAO() -> c
    java.nio.FloatBuffer getBuffer() -> d
    void invalidate() -> e
    int getNumVertices() -> f
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> g
    void deleteVAO() -> h
com.badlogic.gdx.graphics.glutils.VertexData -> com.badlogic.gdx.graphics.glutils.w:
    void dispose() -> a
    void setVertices(float[],int,int) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    java.nio.FloatBuffer getBuffer() -> d
    void invalidate() -> e
    int getNumVertices() -> f
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> g
com.badlogic.gdx.graphics.profiling.GL20Interceptor -> b.a.a.w.u.a:
    com.badlogic.gdx.graphics.GL20 gl20 -> g
    void glAttachShader(int,int) -> a
    void glBlendFuncSeparate(int,int,int,int) -> a
    void glBufferData(int,int,java.nio.Buffer,int) -> a
    void glClearColor(float,float,float,float) -> a
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> a
    void glDepthMask(boolean) -> a
    void glDrawElements(int,int,int,java.nio.Buffer) -> a
    void glFramebufferTexture2D(int,int,int,int,int) -> a
    int glGenRenderbuffer() -> a
    void glGenerateMipmap(int) -> a
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> a
    void glGetFloatv(int,java.nio.FloatBuffer) -> a
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> a
    void glShaderSource(int,java.lang.String) -> a
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> a
    void glTexParameterf(int,int,float) -> a
    void glTexParameteri(int,int,int) -> a
    void glUniformMatrix4fv(int,int,boolean,float[],int) -> a
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> a
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> a
    void glBindRenderbuffer(int,int) -> b
    void glBufferSubData(int,int,int,java.nio.Buffer) -> b
    void glDrawArrays(int,int,int) -> b
    void glFramebufferRenderbuffer(int,int,int,int) -> b
    int glGenBuffer() -> b
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> b
    int glGetAttribLocation(int,java.lang.String) -> b
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> b
    void glLinkProgram(int) -> b
    void glTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> b
    void glBindFramebuffer(int,int) -> c
    int glGetError() -> c
    java.lang.String glGetShaderInfoLog(int) -> c
    int glGetUniformLocation(int,java.lang.String) -> c
    void glScissor(int,int,int,int) -> c
    void glDisable(int) -> d
    int glGenTexture() -> d
    void glGetIntegerv(int,java.nio.IntBuffer) -> d
    void glRenderbufferStorage(int,int,int,int) -> d
    void glUniform1i(int,int) -> d
    void glBindBuffer(int,int) -> e
    int glCreateProgram() -> e
    void glDisableVertexAttribArray(int) -> e
    void glDeleteTexture(int) -> f
    int glGenFramebuffer() -> f
    void glPixelStorei(int,int) -> f
    void glViewport(int,int,int,int) -> f
    void glBindTexture(int,int) -> g
    void glCompileShader(int) -> g
    void glDrawElements(int,int,int,int) -> g
    void check() -> h
    void glEnable(int) -> h
    int glCheckFramebufferStatus(int) -> i
    void glUseProgram(int) -> j
    void glDeleteRenderbuffer(int) -> k
    java.lang.String glGetProgramInfoLog(int) -> l
    void glEnableVertexAttribArray(int) -> m
    java.lang.String glGetString(int) -> n
    void glClear(int) -> o
    void glDeleteFramebuffer(int) -> p
    int glCreateShader(int) -> q
    void glDeleteShader(int) -> s
    void glDeleteProgram(int) -> t
    void glDeleteBuffer(int) -> u
com.badlogic.gdx.graphics.profiling.GL30Interceptor -> b.a.a.w.u.b:
    com.badlogic.gdx.graphics.GL30 gl30 -> g
    void glAttachShader(int,int) -> a
    void glBlendFuncSeparate(int,int,int,int) -> a
    void glBufferData(int,int,java.nio.Buffer,int) -> a
    void glClearColor(float,float,float,float) -> a
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> a
    void glDeleteVertexArrays(int,java.nio.IntBuffer) -> a
    void glDepthMask(boolean) -> a
    void glDrawElements(int,int,int,java.nio.Buffer) -> a
    void glFramebufferTexture2D(int,int,int,int,int) -> a
    int glGenRenderbuffer() -> a
    void glGenerateMipmap(int) -> a
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> a
    void glGetFloatv(int,java.nio.FloatBuffer) -> a
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> a
    void glShaderSource(int,java.lang.String) -> a
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> a
    void glTexImage3D(int,int,int,int,int,int,int,int,int,java.nio.Buffer) -> a
    void glTexParameterf(int,int,float) -> a
    void glTexParameteri(int,int,int) -> a
    void glUniformMatrix4fv(int,int,boolean,float[],int) -> a
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> a
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> a
    void glBindRenderbuffer(int,int) -> b
    void glBufferSubData(int,int,int,java.nio.Buffer) -> b
    void glDrawArrays(int,int,int) -> b
    void glDrawBuffers(int,java.nio.IntBuffer) -> b
    void glDrawElementsInstanced(int,int,int,int,int) -> b
    void glFramebufferRenderbuffer(int,int,int,int) -> b
    int glGenBuffer() -> b
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> b
    int glGetAttribLocation(int,java.lang.String) -> b
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> b
    void glLinkProgram(int) -> b
    void glTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> b
    void glBindFramebuffer(int,int) -> c
    void glGenVertexArrays(int,java.nio.IntBuffer) -> c
    int glGetError() -> c
    java.lang.String glGetShaderInfoLog(int) -> c
    int glGetUniformLocation(int,java.lang.String) -> c
    void glScissor(int,int,int,int) -> c
    void glDisable(int) -> d
    int glGenTexture() -> d
    void glGetIntegerv(int,java.nio.IntBuffer) -> d
    void glRenderbufferStorage(int,int,int,int) -> d
    void glUniform1i(int,int) -> d
    void glBindBuffer(int,int) -> e
    int glCreateProgram() -> e
    void glDisableVertexAttribArray(int) -> e
    void glDrawArraysInstanced(int,int,int,int) -> e
    void glDeleteTexture(int) -> f
    int glGenFramebuffer() -> f
    void glPixelStorei(int,int) -> f
    void glViewport(int,int,int,int) -> f
    void glBindTexture(int,int) -> g
    void glCompileShader(int) -> g
    void glDrawElements(int,int,int,int) -> g
    void check() -> h
    void glEnable(int) -> h
    int glCheckFramebufferStatus(int) -> i
    void glUseProgram(int) -> j
    void glDeleteRenderbuffer(int) -> k
    java.lang.String glGetProgramInfoLog(int) -> l
    void glEnableVertexAttribArray(int) -> m
    java.lang.String glGetString(int) -> n
    void glClear(int) -> o
    void glDeleteFramebuffer(int) -> p
    int glCreateShader(int) -> q
    void glBindVertexArray(int) -> r
    void glDeleteShader(int) -> s
    void glDeleteProgram(int) -> t
    void glDeleteBuffer(int) -> u
com.badlogic.gdx.graphics.profiling.GLErrorListener -> b.a.a.w.u.c:
    com.badlogic.gdx.graphics.profiling.GLErrorListener LOGGING_LISTENER -> a
    void onError(int) -> a
com.badlogic.gdx.graphics.profiling.GLErrorListener$1 -> b.a.a.w.u.c$a:
    void onError(int) -> a
com.badlogic.gdx.graphics.profiling.GLErrorListener$2 -> b.a.a.w.u.c$b:
    void onError(int) -> a
com.badlogic.gdx.graphics.profiling.GLInterceptor -> b.a.a.w.u.d:
    int shaderSwitches -> d
    com.badlogic.gdx.math.FloatCounter vertexCount -> e
    int textureBindings -> b
    int drawCalls -> c
    com.badlogic.gdx.graphics.profiling.GLProfiler glProfiler -> f
    int calls -> a
    void reset() -> g
    java.lang.String resolveErrorNumber(int) -> v
com.badlogic.gdx.graphics.profiling.GLProfiler -> b.a.a.w.u.e:
    com.badlogic.gdx.Graphics graphics -> a
    com.badlogic.gdx.graphics.profiling.GLInterceptor glInterceptor -> b
    com.badlogic.gdx.graphics.profiling.GLErrorListener listener -> c
    boolean enabled -> d
    void enable() -> a
    com.badlogic.gdx.graphics.profiling.GLErrorListener getListener() -> b
    void reset() -> c
com.badlogic.gdx.input.GestureDetector -> b.a.a.x.a:
    long lastTapTime -> i
    float lastTapY -> k
    int lastTapButton -> l
    boolean pinching -> o
    int tapCount -> h
    float longPressSeconds -> e
    float tapRectangleHeight -> c
    com.badlogic.gdx.utils.Timer$Task longPressTask -> y
    float tapRectangleCenterY -> s
    com.badlogic.gdx.math.Vector2 initialPointer2 -> x
    com.badlogic.gdx.math.Vector2 pointer2 -> v
    boolean longPressFired -> n
    float lastTapX -> j
    int lastTapPointer -> m
    boolean panning -> p
    long maxFlingDelay -> f
    float tapRectangleWidth -> b
    long tapCountInterval -> d
    boolean inTapRectangle -> g
    float tapRectangleCenterX -> r
    long touchDownTime -> t
    com.badlogic.gdx.input.GestureDetector$GestureListener listener -> a
    com.badlogic.gdx.input.GestureDetector$VelocityTracker tracker -> q
    com.badlogic.gdx.math.Vector2 initialPointer1 -> w
    com.badlogic.gdx.math.Vector2 pointer1 -> u
    boolean touchDown(float,float,int,int) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchDragged(float,float,int) -> a
    boolean touchDragged(int,int,int) -> a
    boolean isWithinTapRectangle(float,float,float,float) -> b
    boolean touchUp(float,float,int,int) -> b
    boolean touchUp(int,int,int,int) -> b
    void cancel() -> v
    boolean isPanning() -> w
    void reset() -> x
com.badlogic.gdx.input.GestureDetector$1 -> b.a.a.x.a$a:
    com.badlogic.gdx.input.GestureDetector this$0 -> f
com.badlogic.gdx.input.GestureDetector$GestureAdapter -> b.a.a.x.a$b:
    void pinchStop() -> a
    boolean touchDown(float,float,int,int) -> a
com.badlogic.gdx.input.GestureDetector$GestureListener -> b.a.a.x.a$c:
    boolean fling(float,float,int) -> a
    boolean pan(float,float,float,float) -> a
    boolean pinch(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
    void pinchStop() -> a
    boolean touchDown(float,float,int,int) -> a
    boolean zoom(float,float) -> a
    boolean longPress(float,float) -> b
    boolean panStop(float,float,int,int) -> b
    boolean tap(float,float,int,int) -> c
com.badlogic.gdx.input.GestureDetector$VelocityTracker -> b.a.a.x.a$d:
    long lastTime -> f
    float[] meanY -> i
    float deltaY -> e
    float[] meanX -> h
    float deltaX -> d
    float lastY -> c
    int numSamples -> g
    float lastX -> b
    int sampleSize -> a
    long[] meanTime -> j
    float getAverage(float[],int) -> a
    long getAverage(long[],int) -> a
    float getVelocityX() -> a
    void start(float,float,long) -> a
    float getVelocityY() -> b
    void update(float,float,long) -> b
com.badlogic.gdx.math.Affine2 -> com.badlogic.gdx.math.a:
    float m12 -> f
    float m11 -> e
    float m10 -> d
    float m02 -> c
    float m01 -> b
    float m00 -> a
    com.badlogic.gdx.math.Affine2 preMul(com.badlogic.gdx.math.Affine2) -> a
    com.badlogic.gdx.math.Affine2 setToTrnRotScl(float,float,float,float,float) -> a
    com.badlogic.gdx.math.Affine2 translate(float,float) -> a
com.badlogic.gdx.math.Circle -> com.badlogic.gdx.math.b:
    float radius -> c
    float y -> b
    float x -> a
    boolean contains(float,float) -> a
    void set(float,float,float) -> a
com.badlogic.gdx.math.EarClippingTriangulator -> com.badlogic.gdx.math.c:
    com.badlogic.gdx.utils.ShortArray triangles -> f
    com.badlogic.gdx.utils.ShortArray indicesArray -> a
    com.badlogic.gdx.utils.IntArray vertexTypes -> e
    short[] indices -> b
    float[] vertices -> c
    int vertexCount -> d
    int classifyVertex(int) -> a
    int computeSpannedAreaSign(float,float,float,float,float,float) -> a
    com.badlogic.gdx.utils.ShortArray computeTriangles(float[]) -> a
    com.badlogic.gdx.utils.ShortArray computeTriangles(float[],int,int) -> a
    int findEarTip() -> a
    void cutEarTip(int) -> b
    void triangulate() -> b
    boolean isEarTip(int) -> c
    int nextIndex(int) -> d
    int previousIndex(int) -> e
com.badlogic.gdx.math.FloatCounter -> com.badlogic.gdx.math.d:
    float value -> g
    float latest -> f
    float average -> e
    float max -> d
    float min -> c
    float total -> b
    com.badlogic.gdx.math.WindowedMean mean -> h
    int count -> a
    void put(float) -> a
    void reset() -> a
com.badlogic.gdx.math.Frustum -> com.badlogic.gdx.math.e:
    com.badlogic.gdx.math.Vector3[] planePoints -> b
    com.badlogic.gdx.math.Vector3[] clipSpacePlanePoints -> d
    float[] clipSpacePlanePointsArray -> e
    float[] planePointsArray -> c
    com.badlogic.gdx.math.Plane[] planes -> a
    void update(com.badlogic.gdx.math.Matrix4) -> a
com.badlogic.gdx.math.GeometryUtils -> com.badlogic.gdx.math.f:
    boolean isClockwise(float[],int,int) -> a
com.badlogic.gdx.math.Interpolation -> com.badlogic.gdx.math.g:
    com.badlogic.gdx.math.Interpolation smoother -> b
    com.badlogic.gdx.math.Interpolation fade -> c
    com.badlogic.gdx.math.Interpolation$PowIn pow2In -> d
    com.badlogic.gdx.math.Interpolation linear -> a
    com.badlogic.gdx.math.Interpolation$PowOut pow2Out -> e
    float apply(float) -> a
    float apply(float,float,float) -> a
com.badlogic.gdx.math.Interpolation$1 -> com.badlogic.gdx.math.g$f:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$10 -> com.badlogic.gdx.math.g$a:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$11 -> com.badlogic.gdx.math.g$b:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$12 -> com.badlogic.gdx.math.g$c:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$13 -> com.badlogic.gdx.math.g$d:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$14 -> com.badlogic.gdx.math.g$e:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$2 -> com.badlogic.gdx.math.g$g:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$3 -> com.badlogic.gdx.math.g$h:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$4 -> com.badlogic.gdx.math.g$i:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$5 -> com.badlogic.gdx.math.g$j:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$6 -> com.badlogic.gdx.math.g$k:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$7 -> com.badlogic.gdx.math.g$l:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$8 -> com.badlogic.gdx.math.g$m:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$9 -> com.badlogic.gdx.math.g$n:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Bounce -> com.badlogic.gdx.math.g$o:
    float apply(float) -> a
    float out(float) -> b
com.badlogic.gdx.math.Interpolation$BounceIn -> com.badlogic.gdx.math.g$p:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$BounceOut -> com.badlogic.gdx.math.g$q:
    float[] heights -> g
    float[] widths -> f
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Elastic -> com.badlogic.gdx.math.g$r:
    float bounces -> i
    float scale -> h
    float power -> g
    float value -> f
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ElasticIn -> com.badlogic.gdx.math.g$s:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ElasticOut -> com.badlogic.gdx.math.g$t:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Exp -> com.badlogic.gdx.math.g$u:
    float scale -> i
    float min -> h
    float power -> g
    float value -> f
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ExpIn -> com.badlogic.gdx.math.g$v:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ExpOut -> com.badlogic.gdx.math.g$w:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Pow -> com.badlogic.gdx.math.g$x:
    int power -> f
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$PowIn -> com.badlogic.gdx.math.g$y:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$PowOut -> com.badlogic.gdx.math.g$z:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Swing -> com.badlogic.gdx.math.g$a0:
    float scale -> f
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$SwingIn -> com.badlogic.gdx.math.g$b0:
    float scale -> f
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$SwingOut -> com.badlogic.gdx.math.g$c0:
    float scale -> f
    float apply(float) -> a
com.badlogic.gdx.math.MathUtils -> com.badlogic.gdx.math.h:
    java.util.Random random -> a
    float clamp(float,float,float) -> a
    int clamp(int,int,int) -> a
    float cos(float) -> a
    boolean isEqual(float,float) -> a
    boolean isPowerOfTwo(int) -> a
    float random() -> a
    int random(int,int) -> a
    float cosDeg(float) -> b
    boolean isEqual(float,float,float) -> b
    int nextPowerOfTwo(int) -> b
    float random(float) -> c
    int random(int) -> c
    float sin(float) -> d
    float sinDeg(float) -> e
com.badlogic.gdx.math.MathUtils$Sin -> com.badlogic.gdx.math.h$a:
    float[] table -> a
com.badlogic.gdx.math.Matrix3 -> com.badlogic.gdx.math.i:
    float[] val -> a
    com.badlogic.gdx.math.Matrix3 idt() -> a
com.badlogic.gdx.math.Matrix4 -> com.badlogic.gdx.math.Matrix4:
    com.badlogic.gdx.math.Vector3 l_vex -> d
    com.badlogic.gdx.math.Vector3 l_vey -> e
    com.badlogic.gdx.math.Vector3 l_vez -> c
    com.badlogic.gdx.math.Matrix4 tmpMat -> g
    com.badlogic.gdx.math.Quaternion quat -> b
    float[] val -> a
    com.badlogic.gdx.math.Vector3 tmpVec -> f
    com.badlogic.gdx.math.Matrix4 idt() -> a
    com.badlogic.gdx.math.Matrix4 mul(com.badlogic.gdx.math.Matrix4) -> a
    void mul(float[],float[]) -> a
    com.badlogic.gdx.math.Matrix4 rotate(com.badlogic.gdx.math.Quaternion) -> a
    com.badlogic.gdx.math.Matrix4 scale(float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 set(float,float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 set(float,float,float,float,float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 set(float,float,float,float,float,float,float,float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Affine2) -> a
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Quaternion,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Matrix4 set(float[]) -> a
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Matrix4 setToOrtho(float,float,float,float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 setToRotation(com.badlogic.gdx.math.Vector3,float) -> a
    float det(float[]) -> b
    com.badlogic.gdx.math.Matrix4 inv() -> b
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Matrix4) -> b
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Quaternion) -> b
    com.badlogic.gdx.math.Matrix4 setToOrtho2D(float,float,float,float) -> b
    com.badlogic.gdx.math.Matrix4 setToTranslation(float,float,float) -> b
    boolean inv(float[]) -> c
    com.badlogic.gdx.math.Matrix4 translate(float,float,float) -> c
com.badlogic.gdx.math.Plane -> com.badlogic.gdx.math.j:
    com.badlogic.gdx.math.Vector3 normal -> a
    float d -> b
    void set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
com.badlogic.gdx.math.Quaternion -> com.badlogic.gdx.math.k:
    float w -> d
    float z -> c
    float y -> b
    float x -> a
    com.badlogic.gdx.math.Quaternion idt() -> a
    com.badlogic.gdx.math.Quaternion set(float,float,float,float) -> a
    com.badlogic.gdx.math.Quaternion set(com.badlogic.gdx.math.Quaternion) -> a
    com.badlogic.gdx.math.Quaternion set(com.badlogic.gdx.math.Vector3,float) -> a
    float len2() -> b
    com.badlogic.gdx.math.Quaternion setFromAxis(float,float,float,float) -> b
    com.badlogic.gdx.math.Quaternion nor() -> c
    com.badlogic.gdx.math.Quaternion setFromAxisRad(float,float,float,float) -> c
com.badlogic.gdx.math.RandomXS128 -> com.badlogic.gdx.math.l:
    long seed1 -> b
    long seed0 -> a
    long nextLong(long) -> a
    void setState(long,long) -> a
    long murmurHash3(long) -> b
com.badlogic.gdx.math.Rectangle -> com.badlogic.gdx.math.m:
    com.badlogic.gdx.math.Rectangle tmp -> e
    float height -> d
    float width -> c
    float y -> b
    float x -> a
    boolean contains(float,float) -> a
    boolean contains(com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.math.Vector2 getCenter(com.badlogic.gdx.math.Vector2) -> a
    float getHeight() -> a
    com.badlogic.gdx.math.Rectangle set(float,float,float,float) -> a
    com.badlogic.gdx.math.Vector2 getPosition(com.badlogic.gdx.math.Vector2) -> b
    float getWidth() -> b
    boolean overlaps(com.badlogic.gdx.math.Rectangle) -> b
    com.badlogic.gdx.math.Rectangle setPosition(float,float) -> b
    float getX() -> c
    com.badlogic.gdx.math.Rectangle set(com.badlogic.gdx.math.Rectangle) -> c
    com.badlogic.gdx.math.Rectangle setPosition(com.badlogic.gdx.math.Vector2) -> c
    float getY() -> d
com.badlogic.gdx.math.Shape2D -> com.badlogic.gdx.math.n:
com.badlogic.gdx.math.Vector -> com.badlogic.gdx.math.q:
com.badlogic.gdx.math.Vector2 -> com.badlogic.gdx.math.o:
    float y -> b
    float x -> a
    com.badlogic.gdx.math.Vector2 add(float,float) -> a
    com.badlogic.gdx.math.Vector2 add(com.badlogic.gdx.math.Vector2) -> a
    float angle() -> a
    boolean isZero(float) -> a
    com.badlogic.gdx.math.Vector2 rotate90(int) -> a
    float dst(com.badlogic.gdx.math.Vector2) -> b
    float dst2(float,float) -> b
    boolean isZero() -> b
    com.badlogic.gdx.math.Vector2 limit(float) -> b
    float len() -> c
    com.badlogic.gdx.math.Vector2 limit2(float) -> c
    com.badlogic.gdx.math.Vector2 set(float,float) -> c
    com.badlogic.gdx.math.Vector2 set(com.badlogic.gdx.math.Vector2) -> c
    float len2() -> d
    com.badlogic.gdx.math.Vector2 rotateRad(float) -> d
    com.badlogic.gdx.math.Vector2 sub(float,float) -> d
    com.badlogic.gdx.math.Vector2 sub(com.badlogic.gdx.math.Vector2) -> d
    com.badlogic.gdx.math.Vector2 nor() -> e
    com.badlogic.gdx.math.Vector2 scl(float) -> e
    com.badlogic.gdx.math.Vector2 setAngle(float) -> f
    com.badlogic.gdx.math.Vector2 setZero() -> f
    com.badlogic.gdx.math.Vector2 setAngleRad(float) -> g
    com.badlogic.gdx.math.Vector2 setLength(float) -> h
    com.badlogic.gdx.math.Vector2 setLength2(float) -> i
com.badlogic.gdx.math.Vector3 -> com.badlogic.gdx.math.p:
    com.badlogic.gdx.math.Matrix4 tmpMat -> d
    float z -> c
    float y -> b
    float x -> a
    com.badlogic.gdx.math.Vector3 add(float,float,float) -> a
    com.badlogic.gdx.math.Vector3 add(com.badlogic.gdx.math.Vector3) -> a
    float len() -> a
    com.badlogic.gdx.math.Vector3 mul(com.badlogic.gdx.math.Matrix4) -> a
    com.badlogic.gdx.math.Vector3 rotate(com.badlogic.gdx.math.Vector3,float) -> a
    com.badlogic.gdx.math.Vector3 scl(float) -> a
    com.badlogic.gdx.math.Vector3 crs(float,float,float) -> b
    com.badlogic.gdx.math.Vector3 crs(com.badlogic.gdx.math.Vector3) -> b
    float len2() -> b
    com.badlogic.gdx.math.Vector3 prj(com.badlogic.gdx.math.Matrix4) -> b
    float dot(com.badlogic.gdx.math.Vector3) -> c
    com.badlogic.gdx.math.Vector3 nor() -> c
    com.badlogic.gdx.math.Vector3 set(float,float,float) -> c
    com.badlogic.gdx.math.Vector3 set(com.badlogic.gdx.math.Vector3) -> d
    com.badlogic.gdx.math.Vector3 sub(float,float,float) -> d
    float len(float,float,float) -> e
    com.badlogic.gdx.math.Vector3 sub(com.badlogic.gdx.math.Vector3) -> e
com.badlogic.gdx.math.WindowedMean -> com.badlogic.gdx.math.r:
    float mean -> d
    boolean dirty -> e
    float[] values -> a
    int added_values -> b
    int last_value -> c
    void addValue(float) -> a
    void clear() -> a
    float getMean() -> b
    boolean hasEnoughData() -> c
com.badlogic.gdx.math.collision.BoundingBox -> com.badlogic.gdx.math.s.a:
    com.badlogic.gdx.math.Vector3 dim -> d
    com.badlogic.gdx.math.Vector3 max -> b
    com.badlogic.gdx.math.Vector3 cnt -> c
    com.badlogic.gdx.math.Vector3 min -> a
    com.badlogic.gdx.math.collision.BoundingBox clr() -> a
    com.badlogic.gdx.math.collision.BoundingBox ext(com.badlogic.gdx.math.Vector3) -> a
    float min(float,float) -> a
    com.badlogic.gdx.math.collision.BoundingBox set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Vector3 getCenter(com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.math.collision.BoundingBox inf() -> b
    com.badlogic.gdx.math.Vector3 getDimensions(com.badlogic.gdx.math.Vector3) -> c
com.badlogic.gdx.math.collision.Ray -> com.badlogic.gdx.math.s.b:
    com.badlogic.gdx.math.Vector3 direction -> b
    com.badlogic.gdx.math.Vector3 origin -> a
com.badlogic.gdx.net.NetJavaImpl -> b.a.a.y.a:
    java.util.concurrent.ThreadPoolExecutor executorService -> a
com.badlogic.gdx.net.NetJavaImpl$1 -> b.a.a.y.a$a:
    java.util.concurrent.atomic.AtomicInteger threadID -> a
com.badlogic.gdx.scenes.scene2d.Action -> b.a.a.z.a.a:
    com.badlogic.gdx.utils.Pool pool -> c
    com.badlogic.gdx.scenes.scene2d.Actor target -> b
    com.badlogic.gdx.scenes.scene2d.Actor actor -> a
    boolean act(float) -> a
    void reset() -> a
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void setPool(com.badlogic.gdx.utils.Pool) -> a
    com.badlogic.gdx.utils.Pool getPool() -> b
    void setTarget(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void restart() -> c
com.badlogic.gdx.scenes.scene2d.Actor -> b.a.a.z.a.b:
    float width -> l
    java.lang.String name -> f
    float y -> k
    float x -> j
    boolean debug -> i
    com.badlogic.gdx.scenes.scene2d.Touchable touchable -> g
    com.badlogic.gdx.scenes.scene2d.Group parent -> b
    com.badlogic.gdx.utils.DelayedRemovalArray listeners -> c
    com.badlogic.gdx.utils.DelayedRemovalArray captureListeners -> d
    com.badlogic.gdx.scenes.scene2d.Stage stage -> a
    com.badlogic.gdx.utils.Array actions -> e
    float rotation -> r
    boolean visible -> h
    float scaleY -> q
    float scaleX -> p
    float originY -> o
    float originX -> n
    com.badlogic.gdx.graphics.Color color -> s
    float height -> m
    com.badlogic.gdx.scenes.scene2d.Touchable getTouchable() -> A
    float getWidth() -> B
    float getX() -> C
    float getY() -> D
    boolean hasActions() -> E
    boolean hasKeyboardFocus() -> F
    boolean hasParent() -> G
    boolean isTouchable() -> H
    boolean isVisible() -> I
    void positionChanged() -> J
    boolean remove() -> K
    void scaleChanged() -> L
    void sizeChanged() -> M
    void toFront() -> N
    void act(float) -> a
    void addAction(com.badlogic.gdx.scenes.scene2d.Action) -> a
    boolean addCaptureListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> a
    boolean clipBegin(float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> a
    boolean fire(com.badlogic.gdx.scenes.scene2d.Event) -> a
    float getX(int) -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    boolean isAscendantOf(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.math.Vector2 localToAscendantCoordinates(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.math.Vector2 localToParentCoordinates(com.badlogic.gdx.math.Vector2) -> a
    void moveBy(float,float) -> a
    boolean notify(com.badlogic.gdx.scenes.scene2d.Event,boolean) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setName(java.lang.String) -> a
    void setParent(com.badlogic.gdx.scenes.scene2d.Group) -> a
    void setPosition(float,float,int) -> a
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    void setTouchable(com.badlogic.gdx.scenes.scene2d.Touchable) -> a
    boolean addListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> b
    void drawDebugBounds(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> b
    float getY(int) -> b
    boolean isDescendantOf(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    com.badlogic.gdx.math.Vector2 localToStageCoordinates(com.badlogic.gdx.math.Vector2) -> b
    void setBounds(float,float,float,float) -> b
    void setDebug(boolean) -> b
    void setHeight(float) -> b
    void setPosition(float,float) -> b
    com.badlogic.gdx.math.Vector2 parentToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> c
    boolean removeCaptureListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> c
    void setScale(float) -> c
    void setSize(float,float) -> c
    void setVisible(boolean) -> c
    boolean setZIndex(int) -> c
    boolean removeListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> d
    void setWidth(float) -> d
    com.badlogic.gdx.math.Vector2 stageToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> d
    void setX(float) -> e
    void setY(float) -> f
    boolean ascendantsVisible() -> i
    void clear() -> j
    void clearActions() -> k
    void clearListeners() -> l
    void clipEnd() -> m
    com.badlogic.gdx.graphics.Color getColor() -> n
    boolean getDebug() -> o
    float getHeight() -> p
    java.lang.String getName() -> q
    float getOriginX() -> r
    float getOriginY() -> s
    com.badlogic.gdx.scenes.scene2d.Group getParent() -> t
    float getRight() -> u
    float getRotation() -> v
    float getScaleX() -> w
    float getScaleY() -> x
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> y
    float getTop() -> z
com.badlogic.gdx.scenes.scene2d.Event -> b.a.a.z.a.c:
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> c
    com.badlogic.gdx.scenes.scene2d.Actor targetActor -> b
    com.badlogic.gdx.scenes.scene2d.Stage stage -> a
    boolean handled -> e
    boolean stopped -> f
    boolean cancelled -> g
    boolean bubbles -> d
    void reset() -> a
    void setCapture(boolean) -> a
    void setListenerActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    void cancel() -> b
    void setTarget(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean getBubbles() -> c
    com.badlogic.gdx.scenes.scene2d.Actor getListenerActor() -> d
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> e
    com.badlogic.gdx.scenes.scene2d.Actor getTarget() -> f
    void handle() -> g
    boolean isCancelled() -> h
    boolean isHandled() -> i
    boolean isStopped() -> j
    void stop() -> k
com.badlogic.gdx.scenes.scene2d.EventListener -> b.a.a.z.a.d:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
com.badlogic.gdx.scenes.scene2d.Group -> b.a.a.z.a.e:
    com.badlogic.gdx.utils.SnapshotArray children -> t
    com.badlogic.gdx.math.Matrix4 oldTransform -> w
    com.badlogic.gdx.math.Rectangle cullingArea -> y
    com.badlogic.gdx.math.Matrix4 computedTransform -> v
    com.badlogic.gdx.math.Affine2 worldTransform -> u
    com.badlogic.gdx.math.Vector2 tmp -> z
    boolean transform -> x
    void childrenChanged() -> O
    void clearChildren() -> P
    com.badlogic.gdx.math.Matrix4 computeTransform() -> Q
    com.badlogic.gdx.scenes.scene2d.Group debugAll() -> R
    com.badlogic.gdx.utils.SnapshotArray getChildren() -> S
    boolean isTransform() -> T
    void act(float) -> a
    void applyTransform(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.math.Matrix4) -> a
    void applyTransform(com.badlogic.gdx.graphics.glutils.ShapeRenderer,com.badlogic.gdx.math.Matrix4) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.Actor removeActorAt(int,boolean) -> a
    void resetTransform(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void setCullingArea(com.badlogic.gdx.math.Rectangle) -> a
    void setDebug(boolean,boolean) -> a
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    void toString(java.lang.StringBuilder,int) -> a
    void drawChildren(com.badlogic.gdx.graphics.g2d.Batch,float) -> b
    com.badlogic.gdx.scenes.scene2d.Actor findActor(java.lang.String) -> b
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    void drawDebugChildren(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> c
    void clearChildren(boolean) -> d
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor) -> d
    void resetTransform(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> d
    void setTransform(boolean) -> e
    void clear() -> j
com.badlogic.gdx.scenes.scene2d.InputEvent -> b.a.a.z.a.f:
    float scrollAmountY -> l
    int button -> n
    float scrollAmountX -> k
    int keyCode -> o
    float stageY -> j
    float stageX -> i
    int pointer -> m
    char character -> p
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type type -> h
    com.badlogic.gdx.scenes.scene2d.Actor relatedActor -> q
    boolean touchFocus -> r
    void reset() -> a
    void setButton(int) -> a
    void setCharacter(char) -> a
    void setScrollAmountX(float) -> a
    void setType(com.badlogic.gdx.scenes.scene2d.InputEvent$Type) -> a
    com.badlogic.gdx.math.Vector2 toCoordinates(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.math.Vector2) -> a
    void setKeyCode(int) -> b
    void setScrollAmountY(float) -> b
    void setPointer(int) -> c
    void setRelatedActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    void setStageX(float) -> c
    void setStageY(float) -> d
    int getButton() -> l
    char getCharacter() -> m
    int getKeyCode() -> n
    int getPointer() -> o
    com.badlogic.gdx.scenes.scene2d.Actor getRelatedActor() -> p
    float getScrollAmountX() -> q
    float getScrollAmountY() -> r
    float getStageX() -> s
    float getStageY() -> t
    boolean getTouchFocus() -> u
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type getType() -> v
    boolean isTouchFocusCancel() -> w
com.badlogic.gdx.scenes.scene2d.InputEvent$Type -> b.a.a.z.a.f$a:
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDown -> a
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchUp -> b
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type scrolled -> g
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyDown -> h
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyUp -> i
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyTyped -> j
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDragged -> c
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type mouseMoved -> d
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type enter -> e
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type[] $VALUES -> k
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type exit -> f
com.badlogic.gdx.scenes.scene2d.InputListener -> b.a.a.z.a.g:
    com.badlogic.gdx.math.Vector2 tmpCoords -> a
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> a
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
    boolean scrolled(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> b
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
com.badlogic.gdx.scenes.scene2d.InputListener$1 -> b.a.a.z.a.g$a:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$InputEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.Stage -> b.a.a.z.a.h:
    boolean actionsRequestRendering -> p
    int mouseScreenX -> j
    int mouseScreenY -> k
    com.badlogic.gdx.graphics.glutils.ShapeRenderer debugShapes -> q
    com.badlogic.gdx.graphics.g2d.Batch batch -> b
    boolean debug -> w
    boolean debugAll -> r
    com.badlogic.gdx.math.Vector2 tempCoords -> e
    boolean debugUnderMouse -> s
    boolean debugParentUnderMouse -> t
    com.badlogic.gdx.scenes.scene2d.Group root -> d
    com.badlogic.gdx.scenes.scene2d.Actor[] pointerOverActors -> f
    boolean[] pointerTouched -> g
    int[] pointerScreenX -> h
    int[] pointerScreenY -> i
    com.badlogic.gdx.graphics.Color debugColor -> v
    com.badlogic.gdx.utils.viewport.Viewport viewport -> a
    com.badlogic.gdx.utils.SnapshotArray touchFocuses -> o
    com.badlogic.gdx.scenes.scene2d.Actor keyboardFocus -> m
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug debugTableUnderMouse -> u
    com.badlogic.gdx.scenes.scene2d.Actor mouseOverActor -> l
    boolean ownsBatch -> c
    com.badlogic.gdx.scenes.scene2d.Actor scrollFocus -> n
    com.badlogic.gdx.graphics.g2d.Batch getBatch() -> A
    com.badlogic.gdx.graphics.Camera getCamera() -> B
    com.badlogic.gdx.graphics.Color getDebugColor() -> C
    float getHeight() -> D
    com.badlogic.gdx.scenes.scene2d.Actor getKeyboardFocus() -> E
    com.badlogic.gdx.scenes.scene2d.Group getRoot() -> F
    com.badlogic.gdx.scenes.scene2d.Actor getScrollFocus() -> G
    com.badlogic.gdx.utils.viewport.Viewport getViewport() -> H
    float getWidth() -> I
    void unfocusAll() -> J
    void drawDebug() -> K
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    boolean addCaptureListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> a
    void addTouchFocus(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor,int,int) -> a
    void calculateScissors(com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
    void cancelTouchFocusExcept(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void disableDebug(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void dispose() -> a
    com.badlogic.gdx.scenes.scene2d.Actor fireEnterAndExit(com.badlogic.gdx.scenes.scene2d.Actor,int,int,int) -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    boolean keyDown(int) -> a
    boolean keyTyped(char) -> a
    com.badlogic.gdx.math.Vector2 screenToStageCoordinates(com.badlogic.gdx.math.Vector2) -> a
    boolean scrolled(float,float) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchDragged(int,int,int) -> a
    boolean addListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> b
    void cancelTouchFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean keyUp(int) -> b
    boolean mouseMoved(int,int) -> b
    boolean touchUp(int,int,int,int) -> b
    boolean isInsideViewport(int,int) -> c
    boolean removeCaptureListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> c
    boolean setKeyboardFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    boolean removeListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> d
    boolean setScrollFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> d
    void act(float) -> e
    void unfocus(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    void cancelTouchFocus() -> v
    void clear() -> w
    void draw() -> x
    boolean getActionsRequestRendering() -> y
    com.badlogic.gdx.utils.Array getActors() -> z
com.badlogic.gdx.scenes.scene2d.Stage$TouchFocus -> b.a.a.z.a.h$a:
    com.badlogic.gdx.scenes.scene2d.Actor target -> c
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> b
    int pointer -> d
    int button -> e
    com.badlogic.gdx.scenes.scene2d.EventListener listener -> a
    void reset() -> a
com.badlogic.gdx.scenes.scene2d.Touchable -> b.a.a.z.a.i:
    com.badlogic.gdx.scenes.scene2d.Touchable[] $VALUES -> d
    com.badlogic.gdx.scenes.scene2d.Touchable disabled -> b
    com.badlogic.gdx.scenes.scene2d.Touchable childrenOnly -> c
    com.badlogic.gdx.scenes.scene2d.Touchable enabled -> a
com.badlogic.gdx.scenes.scene2d.actions.Actions -> b.a.a.z.a.j.a:
    com.badlogic.gdx.scenes.scene2d.Action action(java.lang.Class) -> a
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction alpha(float) -> a
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction alpha(float,float,com.badlogic.gdx.math.Interpolation) -> a
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction fadeIn(float,com.badlogic.gdx.math.Interpolation) -> a
    com.badlogic.gdx.scenes.scene2d.actions.RepeatAction forever(com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.scenes.scene2d.actions.MoveByAction moveBy(float,float,float) -> a
    com.badlogic.gdx.scenes.scene2d.actions.MoveByAction moveBy(float,float,float,com.badlogic.gdx.math.Interpolation) -> a
    com.badlogic.gdx.scenes.scene2d.actions.RemoveActorAction removeActor() -> a
    com.badlogic.gdx.scenes.scene2d.actions.RemoveListenerAction removeListener(com.badlogic.gdx.scenes.scene2d.EventListener,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.actions.SequenceAction sequence(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.scenes.scene2d.actions.SequenceAction sequence(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction fadeIn(float) -> b
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction fadeOut(float,com.badlogic.gdx.math.Interpolation) -> b
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction fadeOut(float) -> c
com.badlogic.gdx.scenes.scene2d.actions.AlphaAction -> b.a.a.z.a.j.b:
    float end -> k
    float start -> j
    com.badlogic.gdx.graphics.Color color -> l
    void reset() -> a
    void update(float) -> c
    void begin() -> d
    void setAlpha(float) -> d
com.badlogic.gdx.scenes.scene2d.actions.DelegateAction -> b.a.a.z.a.j.c:
    com.badlogic.gdx.scenes.scene2d.Action action -> d
    boolean act(float) -> a
    void reset() -> a
    void setAction(com.badlogic.gdx.scenes.scene2d.Action) -> a
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    boolean delegate(float) -> b
    void setTarget(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void restart() -> c
com.badlogic.gdx.scenes.scene2d.actions.MoveByAction -> b.a.a.z.a.j.d:
    float amountY -> l
    float amountX -> k
    void setAmount(float,float) -> a
    void updateRelative(float) -> d
com.badlogic.gdx.scenes.scene2d.actions.ParallelAction -> b.a.a.z.a.j.e:
    com.badlogic.gdx.utils.Array actions -> d
    void addAction(com.badlogic.gdx.scenes.scene2d.Action) -> a
    void reset() -> a
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void restart() -> c
com.badlogic.gdx.scenes.scene2d.actions.RelativeTemporalAction -> b.a.a.z.a.j.f:
    float lastPercent -> j
    void update(float) -> c
    void begin() -> d
    void updateRelative(float) -> d
com.badlogic.gdx.scenes.scene2d.actions.RemoveActorAction -> b.a.a.z.a.j.g:
    boolean removed -> d
    boolean act(float) -> a
    void restart() -> c
com.badlogic.gdx.scenes.scene2d.actions.RemoveListenerAction -> b.a.a.z.a.j.h:
    com.badlogic.gdx.scenes.scene2d.EventListener listener -> d
    boolean capture -> e
    boolean act(float) -> a
    void reset() -> a
    void setCapture(boolean) -> a
    void setListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> a
com.badlogic.gdx.scenes.scene2d.actions.RepeatAction -> b.a.a.z.a.j.i:
    int executedCount -> f
    boolean finished -> g
    int repeatCount -> e
    void setCount(int) -> a
    boolean delegate(float) -> b
    void restart() -> c
com.badlogic.gdx.scenes.scene2d.actions.SequenceAction -> b.a.a.z.a.j.j:
    int index -> e
    boolean act(float) -> a
    void restart() -> c
com.badlogic.gdx.scenes.scene2d.actions.TemporalAction -> b.a.a.z.a.j.k:
    boolean complete -> i
    com.badlogic.gdx.math.Interpolation interpolation -> f
    float time -> e
    float duration -> d
    boolean reverse -> g
    boolean began -> h
    boolean act(float) -> a
    void reset() -> a
    void setInterpolation(com.badlogic.gdx.math.Interpolation) -> a
    void setDuration(float) -> b
    void restart() -> c
    void update(float) -> c
    void begin() -> d
    void end() -> e
com.badlogic.gdx.scenes.scene2d.ui.Button -> b.a.a.z.a.k.a:
    boolean isDisabled -> u0
    boolean isChecked -> t0
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener clickListener -> w0
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle style -> s0
    boolean programmaticChangeEvents -> x0
    com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup buttonGroup -> v0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    float getMinHeight() -> a
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a
    float getMinWidth() -> b
    void setChecked(boolean,boolean) -> b
    float getPrefWidth() -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getBackgroundDrawable() -> f0
    void setChecked(boolean) -> g
    boolean isChecked() -> g0
    float getPrefHeight() -> h
    void setDisabled(boolean) -> h
    boolean isDisabled() -> h0
    boolean isOver() -> i0
    boolean isPressed() -> j0
    void toggle() -> k0
    void initialize() -> l0
com.badlogic.gdx.scenes.scene2d.ui.Button$1 -> b.a.a.z.a.k.a$a:
    com.badlogic.gdx.scenes.scene2d.ui.Button this$0 -> o
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle -> b.a.a.z.a.k.a$b:
    float unpressedOffsetX -> l
    float pressedOffsetY -> k
    float pressedOffsetX -> j
    com.badlogic.gdx.scenes.scene2d.utils.Drawable up -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable down -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable over -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable focused -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabled -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checked -> f
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedOver -> g
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedDown -> h
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedFocused -> i
    float checkedOffsetY -> o
    float checkedOffsetX -> n
    float unpressedOffsetY -> m
com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup -> b.a.a.z.a.k.b:
    boolean canCheck(com.badlogic.gdx.scenes.scene2d.ui.Button,boolean) -> a
com.badlogic.gdx.scenes.scene2d.ui.Cell -> b.a.a.z.a.k.c:
    com.badlogic.gdx.scenes.scene2d.ui.Value minWidth -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value prefWidth -> c
    float computedPadRight -> J
    float computedPadLeft -> H
    int row -> E
    java.lang.Float fillY -> p
    java.lang.Integer colspan -> t
    java.lang.Boolean uniformY -> v
    float actorY -> y
    java.lang.Float zerof -> K
    com.badlogic.gdx.scenes.scene2d.ui.Value padBottom -> m
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceBottom -> i
    com.badlogic.gdx.scenes.scene2d.ui.Table table -> B
    java.lang.Integer zeroi -> M
    com.badlogic.gdx.scenes.scene2d.ui.Value padTop -> k
    java.lang.Integer centeri -> O
    com.badlogic.gdx.scenes.scene2d.ui.Value maxWidth -> e
    java.lang.Integer lefti -> Q
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceTop -> g
    boolean endRow -> C
    java.lang.Integer expandX -> r
    com.badlogic.gdx.scenes.scene2d.ui.Value minHeight -> b
    float computedPadBottom -> I
    float computedPadTop -> G
    int cellAboveIndex -> F
    int column -> D
    float actorHeight -> A
    com.badlogic.gdx.Files files -> S
    java.lang.Float fillX -> o
    java.lang.Integer expandY -> s
    java.lang.Boolean uniformX -> u
    float actorWidth -> z
    float actorX -> x
    java.lang.Float onef -> L
    com.badlogic.gdx.scenes.scene2d.ui.Value padLeft -> l
    com.badlogic.gdx.scenes.scene2d.Actor actor -> w
    com.badlogic.gdx.scenes.scene2d.ui.Value padRight -> n
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceLeft -> h
    java.lang.Integer onei -> N
    com.badlogic.gdx.scenes.scene2d.ui.Cell defaults -> T
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceRight -> j
    java.lang.Integer bottomi -> P
    com.badlogic.gdx.scenes.scene2d.ui.Value prefHeight -> d
    java.lang.Integer align -> q
    java.lang.Integer righti -> R
    com.badlogic.gdx.scenes.scene2d.ui.Value maxHeight -> f
    com.badlogic.gdx.scenes.scene2d.ui.Cell colspan(int) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell height(float) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell height(com.badlogic.gdx.scenes.scene2d.ui.Value) -> a
    void merge(com.badlogic.gdx.scenes.scene2d.ui.Cell) -> a
    void reset() -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void setTable(com.badlogic.gdx.scenes.scene2d.ui.Table) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell bottom() -> b
    com.badlogic.gdx.scenes.scene2d.ui.Cell minWidth(float) -> b
    com.badlogic.gdx.scenes.scene2d.ui.Cell pad(com.badlogic.gdx.scenes.scene2d.ui.Value) -> b
    void set(com.badlogic.gdx.scenes.scene2d.ui.Cell) -> b
    com.badlogic.gdx.scenes.scene2d.ui.Cell center() -> c
    com.badlogic.gdx.scenes.scene2d.ui.Cell pad(float) -> c
    com.badlogic.gdx.scenes.scene2d.ui.Cell size(com.badlogic.gdx.scenes.scene2d.ui.Value) -> c
    void clear() -> d
    com.badlogic.gdx.scenes.scene2d.ui.Cell padTop(float) -> d
    com.badlogic.gdx.scenes.scene2d.ui.Cell space(com.badlogic.gdx.scenes.scene2d.ui.Value) -> d
    com.badlogic.gdx.scenes.scene2d.ui.Cell expand() -> e
    com.badlogic.gdx.scenes.scene2d.ui.Cell size(float) -> e
    com.badlogic.gdx.scenes.scene2d.ui.Cell width(com.badlogic.gdx.scenes.scene2d.ui.Value) -> e
    com.badlogic.gdx.scenes.scene2d.ui.Cell expandX() -> f
    com.badlogic.gdx.scenes.scene2d.ui.Cell space(float) -> f
    com.badlogic.gdx.scenes.scene2d.ui.Cell expandY() -> g
    com.badlogic.gdx.scenes.scene2d.ui.Cell width(float) -> g
    com.badlogic.gdx.scenes.scene2d.ui.Cell fill() -> h
    com.badlogic.gdx.scenes.scene2d.ui.Cell fillX() -> i
    com.badlogic.gdx.scenes.scene2d.Actor getActor() -> j
    com.badlogic.gdx.scenes.scene2d.ui.Cell left() -> k
    com.badlogic.gdx.scenes.scene2d.ui.Cell right() -> l
    void row() -> m
    com.badlogic.gdx.scenes.scene2d.ui.Cell defaults() -> n
com.badlogic.gdx.scenes.scene2d.ui.CheckBox -> b.a.a.z.a.k.d:
    com.badlogic.gdx.scenes.scene2d.ui.Image image -> A0
    com.badlogic.gdx.scenes.scene2d.ui.CheckBox$CheckBoxStyle style -> B0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a
com.badlogic.gdx.scenes.scene2d.ui.CheckBox$CheckBoxStyle -> b.a.a.z.a.k.d$a:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOn -> z
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOff -> A
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOnOver -> B
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOver -> C
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOnDisabled -> D
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOffDisabled -> E
com.badlogic.gdx.scenes.scene2d.ui.Dialog -> b.a.a.z.a.k.e:
    com.badlogic.gdx.scenes.scene2d.ui.Table buttonTable -> G0
    com.badlogic.gdx.scenes.scene2d.Actor previousScrollFocus -> L0
    com.badlogic.gdx.scenes.scene2d.ui.Table contentTable -> F0
    com.badlogic.gdx.scenes.scene2d.Actor previousKeyboardFocus -> K0
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener focusListener -> M0
    com.badlogic.gdx.utils.ObjectMap values -> I0
    com.badlogic.gdx.scenes.scene2d.InputListener ignoreTouchDown -> N0
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> H0
    boolean cancelHide -> J0
    com.badlogic.gdx.scenes.scene2d.ui.Dialog button(com.badlogic.gdx.scenes.scene2d.ui.Button,java.lang.Object) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Dialog button(java.lang.String,java.lang.Object) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Dialog button(java.lang.String,java.lang.Object,com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle) -> a
    void result(java.lang.Object) -> a
    void setObject(com.badlogic.gdx.scenes.scene2d.Actor,java.lang.Object) -> a
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Dialog show(com.badlogic.gdx.scenes.scene2d.Stage,com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Dialog text(com.badlogic.gdx.scenes.scene2d.ui.Label) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Dialog text(java.lang.String,com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle) -> a
    void hide(com.badlogic.gdx.scenes.scene2d.Action) -> b
    com.badlogic.gdx.scenes.scene2d.ui.Dialog show(com.badlogic.gdx.scenes.scene2d.Stage) -> b
    com.badlogic.gdx.scenes.scene2d.ui.Dialog text(java.lang.String) -> c
    void hide() -> g0
    void initialize() -> h0
com.badlogic.gdx.scenes.scene2d.ui.Dialog$1 -> b.a.a.z.a.k.e$a:
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
com.badlogic.gdx.scenes.scene2d.ui.Dialog$2 -> b.a.a.z.a.k.e$b:
    com.badlogic.gdx.scenes.scene2d.ui.Dialog this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Dialog$3 -> b.a.a.z.a.k.e$c:
    com.badlogic.gdx.scenes.scene2d.ui.Dialog this$0 -> a
    void focusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent) -> a
    void keyboardFocusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent,com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> a
    void scrollFocusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent,com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> b
com.badlogic.gdx.scenes.scene2d.ui.Image -> b.a.a.z.a.k.f:
    com.badlogic.gdx.utils.Scaling scaling -> w
    float imageY -> z
    float imageX -> y
    int align -> x
    float imageHeight -> B
    float imageWidth -> A
    com.badlogic.gdx.scenes.scene2d.utils.Drawable drawable -> C
    void layout() -> P
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getDrawable() -> Q
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    float getMinHeight() -> a
    void setDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> a
    void setScaling(com.badlogic.gdx.utils.Scaling) -> a
    float getMinWidth() -> b
    float getPrefWidth() -> e
    float getPrefHeight() -> h
com.badlogic.gdx.scenes.scene2d.ui.ImageButton -> b.a.a.z.a.k.g:
    com.badlogic.gdx.scenes.scene2d.ui.Image image -> y0
    com.badlogic.gdx.scenes.scene2d.ui.ImageButton$ImageButtonStyle style -> z0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getImageDrawable() -> l0
    void updateImage() -> m0
com.badlogic.gdx.scenes.scene2d.ui.ImageButton$ImageButtonStyle -> b.a.a.z.a.k.g$a:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageUp -> p
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageDown -> q
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageOver -> r
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageDisabled -> s
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageChecked -> t
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageCheckedDown -> u
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageCheckedOver -> v
com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton$ImageTextButtonStyle -> b.a.a.z.a.k.h:
com.badlogic.gdx.scenes.scene2d.ui.Label -> b.a.a.z.a.k.i:
    float fontScaleY -> H
    boolean fontScaleChanged -> I
    float fontScaleX -> G
    java.lang.String ellipsis -> J
    com.badlogic.gdx.graphics.Color tempColor -> K
    float lastPrefHeight -> E
    com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle style -> w
    int labelAlign -> B
    int lineAlign -> C
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> A
    com.badlogic.gdx.graphics.g2d.GlyphLayout layout -> x
    boolean prefSizeInvalid -> F
    com.badlogic.gdx.math.Vector2 prefSize -> y
    com.badlogic.gdx.utils.StringBuilder text -> z
    com.badlogic.gdx.graphics.g2d.GlyphLayout prefSizeLayout -> L
    boolean wrap -> D
    void invalidate() -> O
    void layout() -> P
    com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle getStyle() -> Q
    com.badlogic.gdx.utils.StringBuilder getText() -> R
    void computePrefSize() -> S
    void scaleAndComputePrefSize() -> T
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void setAlignment(int,int) -> a
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle) -> a
    void setText(java.lang.CharSequence) -> a
    boolean textEquals(java.lang.CharSequence) -> b
    void setAlignment(int) -> d
    void setEllipsis(boolean) -> d
    float getPrefWidth() -> e
    float getPrefHeight() -> h
com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle -> b.a.a.z.a.k.i$a:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.graphics.Color fontColor -> b
com.badlogic.gdx.scenes.scene2d.ui.List -> b.a.a.z.a.k.j:
    com.badlogic.gdx.math.Rectangle cullingArea -> z
    com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle style -> w
    int overIndex -> F
    float itemHeight -> C
    com.badlogic.gdx.scenes.scene2d.InputListener keyListener -> G
    float prefHeight -> B
    int alignment -> D
    com.badlogic.gdx.scenes.scene2d.utils.ArraySelection selection -> y
    float prefWidth -> A
    int pressedIndex -> E
    boolean typeToSelect -> H
    com.badlogic.gdx.utils.Array items -> x
    void layout() -> P
    float getItemHeight() -> Q
    com.badlogic.gdx.scenes.scene2d.InputListener getKeyListener() -> R
    java.lang.Object getSelected() -> S
    com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle getStyle() -> T
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    com.badlogic.gdx.graphics.g2d.GlyphLayout drawItem(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,int,java.lang.Object,float,float,float) -> a
    void setCullingArea(com.badlogic.gdx.math.Rectangle) -> a
    void setItems(com.badlogic.gdx.utils.Array) -> a
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle) -> a
    java.lang.String toString(java.lang.Object) -> a
    void drawBackground(com.badlogic.gdx.graphics.g2d.Batch,float) -> b
    void setSelectedIndex(int) -> d
    void setTypeToSelect(boolean) -> d
    float getPrefWidth() -> e
    int getItemIndexAt(float) -> g
    float getPrefHeight() -> h
com.badlogic.gdx.scenes.scene2d.ui.List$1 -> b.a.a.z.a.k.j$a:
    com.badlogic.gdx.scenes.scene2d.ui.List this$0 -> d
    long typeTimeout -> b
    java.lang.String prefix -> c
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.List$2 -> b.a.a.z.a.k.j$b:
    com.badlogic.gdx.scenes.scene2d.ui.List this$0 -> b
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle -> b.a.a.z.a.k.j$c:
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable selection -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable down -> e
    com.badlogic.gdx.graphics.Color fontColorUnselected -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable over -> f
    com.badlogic.gdx.graphics.Color fontColorSelected -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> g
com.badlogic.gdx.scenes.scene2d.ui.ProgressBar -> b.a.a.z.a.k.k:
    boolean disabled -> I
    boolean round -> J
    float animateTime -> F
    boolean programmaticChangeEvents -> K
    float animateDuration -> E
    float position -> C
    float animateFromValue -> B
    float value -> A
    float stepSize -> z
    float max -> y
    float min -> x
    com.badlogic.gdx.math.Interpolation visualInterpolation -> H
    com.badlogic.gdx.math.Interpolation animateInterpolation -> G
    com.badlogic.gdx.scenes.scene2d.ui.ProgressBar$ProgressBarStyle style -> w
    boolean vertical -> D
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getBackgroundDrawable() -> Q
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getKnobAfterDrawable() -> R
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getKnobBeforeDrawable() -> S
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getKnobDrawable() -> T
    float getMaxValue() -> U
    float getMinValue() -> V
    com.badlogic.gdx.scenes.scene2d.ui.ProgressBar$ProgressBarStyle getStyle() -> W
    float getValue() -> X
    float getVisualPercent() -> Y
    float getVisualValue() -> Z
    void act(float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.ProgressBar$ProgressBarStyle) -> a
    float getPrefWidth() -> e
    float clamp(float) -> g
    float getPrefHeight() -> h
    float round(float) -> h
    boolean setValue(float) -> i
com.badlogic.gdx.scenes.scene2d.ui.ProgressBar$ProgressBarStyle -> b.a.a.z.a.k.k$a:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabledKnobAfter -> h
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabledBackground -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knob -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabledKnob -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knobBefore -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabledKnobBefore -> f
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knobAfter -> g
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane -> b.a.a.z.a.k.l:
    com.badlogic.gdx.scenes.scene2d.Actor widget -> E
    float fadeDelay -> e0
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle style -> D
    boolean scrollY -> N
    float fadeAlphaSeconds -> d0
    com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener flickScrollListener -> L
    boolean hScrollOnBottom -> P
    float fadeDelaySeconds -> f0
    boolean cancelTouchFocus -> g0
    float flingTime -> i0
    boolean smoothScrolling -> a0
    boolean scrollBarTouch -> b0
    float velocityX -> k0
    float flingTimer -> j0
    float velocityY -> l0
    float overscrollDistance -> o0
    boolean touchScrollV -> X
    float overscrollSpeedMax -> q0
    float overscrollSpeedMin -> p0
    com.badlogic.gdx.math.Rectangle hScrollBounds -> G
    com.badlogic.gdx.math.Rectangle vScrollBounds -> I
    boolean fadeScrollBars -> Z
    float maxY -> V
    com.badlogic.gdx.math.Rectangle widgetCullingArea -> K
    float visualAmountY -> T
    float amountY -> R
    com.badlogic.gdx.math.Vector2 lastPoint -> Y
    float fadeAlpha -> c0
    boolean scrollX -> M
    boolean vScrollOnRight -> O
    boolean touchScrollH -> W
    boolean variableSizeKnobs -> x0
    com.badlogic.gdx.math.Rectangle widgetArea -> F
    boolean disableY -> u0
    boolean disableX -> t0
    com.badlogic.gdx.math.Rectangle hKnobBounds -> H
    boolean scrollbarsOnTop -> w0
    boolean clamp -> v0
    com.badlogic.gdx.math.Rectangle vKnobBounds -> J
    boolean forceScrollY -> s0
    float maxX -> U
    boolean forceScrollX -> r0
    boolean overscrollX -> m0
    float visualAmountX -> S
    float amountX -> Q
    boolean overscrollY -> n0
    int draggingPointer -> y0
    boolean flickScroll -> h0
    void layout() -> V
    void addCaptureListener() -> X
    void addScrollListener() -> Y
    void cancel() -> Z
    void act(float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> a
    void drawScrollBars(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    float getMinHeight() -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.Actor removeActorAt(int,boolean) -> a
    void scrollTo(float,float,float,float,boolean,boolean) -> a
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle) -> a
    void cancelTouchFocus() -> a0
    float getMinWidth() -> b
    void setOverscroll(boolean,boolean) -> b
    void clamp() -> b0
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    void setScrollingDisabled(boolean,boolean) -> c
    com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener getFlickScrollListener() -> c0
    float getMouseWheelX() -> d0
    float getPrefWidth() -> e
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    float getMouseWheelY() -> e0
    void setFadeScrollBars(boolean) -> f
    float getScrollBarWidth() -> f0
    void scrollX(float) -> g
    void setScrollbarsVisible(boolean) -> g
    float getScrollPercentX() -> g0
    float getPrefHeight() -> h
    void scrollY(float) -> h
    float getScrollPercentY() -> h0
    void setScrollPercentX(float) -> i
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle getStyle() -> i0
    void setScrollPercentY(float) -> j
    float getVisualScrollPercentX() -> j0
    void setScrollX(float) -> k
    float getVisualScrollPercentY() -> k0
    void setScrollY(float) -> l
    void updateVisualScroll() -> l0
    void visualScrollX(float) -> m
    void updateWidgetPosition() -> m0
    void visualScrollY(float) -> n
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$1 -> b.a.a.z.a.k.l$a:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane this$0 -> c
    float handlePosition -> b
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$2 -> b.a.a.z.a.k.l$b:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane this$0 -> f
    void fling(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void pan(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> a
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$3 -> b.a.a.z.a.k.l$c:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane this$0 -> b
    boolean scrolled(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> a
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle -> b.a.a.z.a.k.l$d:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable corner -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable hScroll -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable hScrollKnob -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable vScroll -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable vScrollKnob -> f
com.badlogic.gdx.scenes.scene2d.ui.SelectBox -> b.a.a.z.a.k.m:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxStyle style -> w
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener clickListener -> B
    float prefWidth -> z
    boolean selectedPrefWidth -> E
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxList selectBoxList -> y
    int alignment -> D
    float prefHeight -> A
    com.badlogic.gdx.math.Vector2 temp -> G
    com.badlogic.gdx.utils.Array items -> x
    boolean disabled -> C
    com.badlogic.gdx.scenes.scene2d.utils.ArraySelection selection -> F
    void layout() -> P
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getBackgroundDrawable() -> Q
    com.badlogic.gdx.graphics.Color getFontColor() -> R
    java.lang.Object getSelected() -> S
    int getSelectedIndex() -> T
    void hideList() -> U
    boolean isDisabled() -> V
    boolean isOver() -> W
    void showList() -> X
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    com.badlogic.gdx.graphics.g2d.GlyphLayout drawItem(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.Object,float,float,float) -> a
    void onShow(com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> a
    void setItems(com.badlogic.gdx.utils.Array) -> a
    void setSelected(java.lang.Object) -> a
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxStyle) -> a
    java.lang.String toString(java.lang.Object) -> b
    void onHide(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    float getPrefWidth() -> e
    float getPrefHeight() -> h
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$1 -> b.a.a.z.a.k.m$a:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox this$0 -> l
    boolean fireChangeEvent() -> c
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$2 -> b.a.a.z.a.k.m$b:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox this$0 -> o
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxList -> b.a.a.z.a.k.m$c:
    int maxListCount -> A0
    com.badlogic.gdx.scenes.scene2d.ui.List list -> C0
    com.badlogic.gdx.math.Vector2 stagePosition -> B0
    com.badlogic.gdx.scenes.scene2d.InputListener hideListener -> D0
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox selectBox -> z0
    com.badlogic.gdx.scenes.scene2d.Actor previousScrollFocus -> E0
    void act(float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    void show(com.badlogic.gdx.scenes.scene2d.Stage) -> b
    void hide() -> m0
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxList$1 -> b.a.a.z.a.k.m$c$a:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox val$selectBox -> I
    java.lang.String toString(java.lang.Object) -> a
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxList$2 -> b.a.a.z.a.k.m$c$b:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox val$selectBox -> o
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxList this$0 -> p
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxList$3 -> b.a.a.z.a.k.m$c$c:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxList this$0 -> c
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox val$selectBox -> b
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxList$4 -> b.a.a.z.a.k.m$c$d:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxList this$0 -> c
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox val$selectBox -> b
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxStyle -> b.a.a.z.a.k.m$d:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable backgroundOver -> h
    com.badlogic.gdx.graphics.Color disabledFontColor -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable backgroundOpen -> i
    com.badlogic.gdx.scenes.scene2d.utils.Drawable backgroundDisabled -> j
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle scrollStyle -> f
    com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle listStyle -> g
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> e
    com.badlogic.gdx.graphics.Color overFontColor -> c
    com.badlogic.gdx.graphics.Color fontColor -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin -> b.a.a.z.a.k.n:
    java.lang.Class[] defaultTagClasses -> e
    com.badlogic.gdx.utils.ObjectMap resources -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas atlas -> b
    float scale -> c
    com.badlogic.gdx.utils.ObjectMap jsonClassTags -> d
    void add(java.lang.String,java.lang.Object) -> a
    void add(java.lang.String,java.lang.Object,java.lang.Class) -> a
    void addRegions(com.badlogic.gdx.graphics.g2d.TextureAtlas) -> a
    void dispose() -> a
    java.lang.Object get(java.lang.Class) -> a
    java.lang.Object get(java.lang.String,java.lang.Class) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getDrawable(java.lang.String) -> a
    com.badlogic.gdx.utils.Json getJsonLoader(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable,com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(java.lang.String,com.badlogic.gdx.graphics.Color) -> a
    void scale(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont getFont(java.lang.String) -> b
    void load(com.badlogic.gdx.files.FileHandle) -> b
    java.lang.Object optional(java.lang.String,java.lang.Class) -> b
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch(java.lang.String) -> c
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion(java.lang.String) -> d
    com.badlogic.gdx.utils.Array getRegions(java.lang.String) -> e
    com.badlogic.gdx.graphics.g2d.Sprite getSprite(java.lang.String) -> f
com.badlogic.gdx.scenes.scene2d.ui.Skin$1 -> b.a.a.z.a.k.n$a:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> l
    boolean ignoreUnknownField(java.lang.Class,java.lang.String) -> a
    void readFields(java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin$2 -> b.a.a.z.a.k.n$b:
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> b
    com.badlogic.gdx.scenes.scene2d.ui.Skin read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    void readNamedObjects(com.badlogic.gdx.utils.Json,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin$3 -> b.a.a.z.a.k.n$c:
    com.badlogic.gdx.files.FileHandle val$skinFile -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin$4 -> b.a.a.z.a.k.n$d:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    com.badlogic.gdx.graphics.Color read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin$5 -> b.a.a.z.a.k.n$e:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin$TintedDrawable -> b.a.a.z.a.k.n$f:
com.badlogic.gdx.scenes.scene2d.ui.Slider -> b.a.a.z.a.k.o:
    boolean mouseOver -> N
    int button -> L
    int draggingPointer -> M
    float threshold -> Q
    com.badlogic.gdx.math.Interpolation visualInterpolationInverse -> O
    float[] snapValues -> P
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getBackgroundDrawable() -> Q
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getKnobAfterDrawable() -> R
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getKnobBeforeDrawable() -> S
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getKnobDrawable() -> T
    com.badlogic.gdx.scenes.scene2d.ui.Slider$SliderStyle getStyle() -> W
    boolean isDragging() -> a0
    boolean calculatePositionAndValue(float,float) -> d
    float snap(float) -> j
com.badlogic.gdx.scenes.scene2d.ui.Slider$1 -> b.a.a.z.a.k.o$a:
    com.badlogic.gdx.scenes.scene2d.ui.Slider this$0 -> b
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
com.badlogic.gdx.scenes.scene2d.ui.Slider$SliderStyle -> b.a.a.z.a.k.o$b:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable backgroundOver -> i
    com.badlogic.gdx.scenes.scene2d.utils.Drawable backgroundDown -> j
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knobOver -> k
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knobDown -> l
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knobBeforeOver -> m
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knobBeforeDown -> n
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knobAfterOver -> o
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knobAfterDown -> p
com.badlogic.gdx.scenes.scene2d.ui.SplitPane$SplitPaneStyle -> b.a.a.z.a.k.p:
com.badlogic.gdx.scenes.scene2d.ui.Table -> b.a.a.z.a.k.q:
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundLeft -> p0
    float[] rowMinHeight -> M
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundTop -> o0
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundRight -> r0
    boolean clip -> f0
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundBottom -> q0
    com.badlogic.gdx.scenes.scene2d.ui.Value padLeft -> Y
    int rows -> E
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> g0
    float[] expandHeight -> W
    com.badlogic.gdx.scenes.scene2d.ui.Value padRight -> a0
    float[] rowHeight -> U
    float tablePrefWidth -> R
    com.badlogic.gdx.utils.Array columnDefaults -> I
    float tableMinWidth -> P
    com.badlogic.gdx.utils.Array cells -> G
    float[] rowPrefHeight -> O
    com.badlogic.gdx.scenes.scene2d.ui.Cell rowDefaults -> J
    float[] columnPrefWidth -> N
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug debug -> c0
    int align -> b0
    float[] columnMinWidth -> L
    com.badlogic.gdx.utils.Pool cellPool -> l0
    boolean sizeInvalid -> K
    float[] columnWeightedWidth -> m0
    com.badlogic.gdx.scenes.scene2d.ui.Value padTop -> X
    int columns -> D
    com.badlogic.gdx.scenes.scene2d.ui.Value padBottom -> Z
    com.badlogic.gdx.graphics.Color debugTableColor -> i0
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> e0
    com.badlogic.gdx.graphics.Color debugCellColor -> j0
    com.badlogic.gdx.graphics.Color debugActorColor -> k0
    float[] rowWeightedHeight -> n0
    com.badlogic.gdx.scenes.scene2d.ui.Cell cellDefaults -> H
    com.badlogic.gdx.utils.Array debugRects -> d0
    boolean implicitEndRow -> F
    float tablePrefHeight -> S
    float[] expandWidth -> V
    float tableMinHeight -> Q
    float[] columnWidth -> T
    boolean round -> h0
    com.badlogic.gdx.scenes.scene2d.Group debugAll() -> R
    com.badlogic.gdx.scenes.scene2d.ui.Table debugAll() -> R
    void invalidate() -> U
    void layout() -> V
    com.badlogic.gdx.scenes.scene2d.ui.Cell add() -> X
    com.badlogic.gdx.scenes.scene2d.ui.Cell defaults() -> Y
    com.badlogic.gdx.utils.Array getCells() -> Z
    com.badlogic.gdx.scenes.scene2d.ui.Cell add(java.lang.CharSequence) -> a
    void addDebugRect(float,float,float,float,com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table debug(com.badlogic.gdx.scenes.scene2d.ui.Table$Debug) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void drawBackground(com.badlogic.gdx.graphics.g2d.Batch,float,float,float) -> a
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> a
    float[] ensureSize(float[],int) -> a
    float getMinHeight() -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table pad(com.badlogic.gdx.scenes.scene2d.ui.Value) -> a
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.Actor removeActorAt(int,boolean) -> a
    void setBackground(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> a
    void setSkin(com.badlogic.gdx.scenes.scene2d.ui.Skin) -> a
    float getPadBottom() -> a0
    void drawDebugBounds(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> b
    float getMinWidth() -> b
    void setDebug(boolean) -> b
    float getPadLeft() -> b0
    void addDebugRects(float,float,float,float) -> c
    float getPadRight() -> c0
    void clearChildren(boolean) -> d
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor) -> d
    float getPadTop() -> d0
    com.badlogic.gdx.scenes.scene2d.ui.Cell add(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    void drawDebugRects(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> e
    float getPrefWidth() -> e
    com.badlogic.gdx.scenes.scene2d.ui.Cell row() -> e0
    com.badlogic.gdx.scenes.scene2d.ui.Cell getCell(com.badlogic.gdx.scenes.scene2d.Actor) -> f
    void setClip(boolean) -> f
    void clearDebugRects() -> f0
    com.badlogic.gdx.scenes.scene2d.ui.Table pad(float) -> g
    void computeSize() -> g0
    float getPrefHeight() -> h
    com.badlogic.gdx.scenes.scene2d.ui.Table padBottom(float) -> h
    void endRow() -> h0
    com.badlogic.gdx.scenes.scene2d.ui.Table padLeft(float) -> i
    com.badlogic.gdx.scenes.scene2d.ui.Cell obtainCell() -> i0
    com.badlogic.gdx.scenes.scene2d.ui.Table padRight(float) -> j
com.badlogic.gdx.scenes.scene2d.ui.Table$1 -> b.a.a.z.a.k.q$a:
    com.badlogic.gdx.scenes.scene2d.ui.Cell newObject() -> a
    java.lang.Object newObject() -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$2 -> b.a.a.z.a.k.q$b:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$3 -> b.a.a.z.a.k.q$c:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$4 -> b.a.a.z.a.k.q$d:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$5 -> b.a.a.z.a.k.q$e:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$Debug -> b.a.a.z.a.k.q$f:
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug[] $VALUES -> f
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug actor -> e
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug cell -> d
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug none -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug table -> c
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug all -> b
com.badlogic.gdx.scenes.scene2d.ui.Table$DebugRect -> b.a.a.z.a.k.q$g:
    com.badlogic.gdx.graphics.Color color -> f
    com.badlogic.gdx.utils.Pool pool -> g
com.badlogic.gdx.scenes.scene2d.ui.TextButton -> b.a.a.z.a.k.r:
    com.badlogic.gdx.scenes.scene2d.ui.Label label -> y0
    com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle style -> z0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a
    void setText(java.lang.String) -> c
    com.badlogic.gdx.graphics.Color getFontColor() -> l0
    com.badlogic.gdx.scenes.scene2d.ui.Label getLabel() -> m0
com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle -> b.a.a.z.a.k.r$a:
    com.badlogic.gdx.graphics.Color disabledFontColor -> u
    com.badlogic.gdx.graphics.Color focusedFontColor -> t
    com.badlogic.gdx.graphics.Color checkedDownFontColor -> w
    com.badlogic.gdx.graphics.Color checkedFontColor -> v
    com.badlogic.gdx.graphics.Color checkedFocusedFontColor -> y
    com.badlogic.gdx.graphics.Color checkedOverFontColor -> x
    com.badlogic.gdx.graphics.Color fontColor -> q
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> p
    com.badlogic.gdx.graphics.Color overFontColor -> s
    com.badlogic.gdx.graphics.Color downFontColor -> r
com.badlogic.gdx.scenes.scene2d.ui.TextField -> b.a.a.z.a.k.s:
    boolean focused -> d0
    boolean disabled -> N
    int textHAlign -> O
    boolean cursorOn -> e0
    float blinkTime -> f0
    boolean focusTraversal -> L
    float keyRepeatInitialTime -> m0
    float keyRepeatTime -> n0
    com.badlogic.gdx.utils.Timer$Task blinkTask -> g0
    java.lang.StringBuilder passwordBuffer -> U
    boolean passwordMode -> T
    com.badlogic.gdx.scenes.scene2d.ui.TextField$OnscreenKeyboard keyboard -> K
    float renderOffset -> Z
    com.badlogic.gdx.math.Vector2 tmp3 -> l0
    float textHeight -> X
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldListener listener -> I
    int selectionStart -> y
    boolean writeEnters -> A
    float selectionX -> P
    boolean onlyFontChars -> M
    int maxLength -> c0
    int visibleTextEnd -> b0
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter filter -> J
    int visibleTextStart -> a0
    com.badlogic.gdx.scenes.scene2d.ui.TextField$KeyRepeatTask keyRepeatTask -> h0
    com.badlogic.gdx.graphics.g2d.GlyphLayout layout -> B
    java.lang.CharSequence displayText -> F
    com.badlogic.gdx.utils.FloatArray glyphPositions -> C
    com.badlogic.gdx.math.Vector2 tmp2 -> k0
    com.badlogic.gdx.math.Vector2 tmp1 -> j0
    java.lang.String undoText -> R
    char passwordCharacter -> V
    java.lang.String text -> w
    float textOffset -> Y
    boolean hasSelection -> z
    float fontOffset -> W
    int cursor -> x
    com.badlogic.gdx.utils.Clipboard clipboard -> G
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle style -> D
    com.badlogic.gdx.scenes.scene2d.InputListener inputListener -> H
    float selectionWidth -> Q
    long lastChangeTime -> S
    boolean programmaticChangeEvents -> i0
    java.lang.String messageText -> E
    void calculateOffsets() -> Q
    void clearSelection() -> R
    void copy() -> S
    com.badlogic.gdx.scenes.scene2d.InputListener createInputListener() -> T
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getBackgroundDrawable() -> U
    java.lang.String getText() -> V
    void initialize() -> W
    boolean isDisabled() -> X
    void selectAll() -> Y
    void updateDisplayText() -> Z
    boolean changeText(java.lang.String,java.lang.String) -> a
    boolean continueCursor(int,int) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void drawCursor(com.badlogic.gdx.scenes.scene2d.utils.Drawable,com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,float,float) -> a
    void drawMessageText(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,float,float,float) -> a
    void drawText(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,float,float) -> a
    com.badlogic.gdx.scenes.scene2d.ui.TextField findNextTextField(com.badlogic.gdx.utils.Array,com.badlogic.gdx.scenes.scene2d.ui.TextField,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,boolean) -> a
    float getTextY(com.badlogic.gdx.graphics.g2d.BitmapFont,com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> a
    java.lang.String insert(int,java.lang.CharSequence,java.lang.String) -> a
    boolean isWordCharacter(char) -> a
    void moveCursor(boolean,boolean) -> a
    void paste(java.lang.String,boolean) -> a
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle) -> a
    void setTextFieldFilter(com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter) -> a
    void drawSelection(com.badlogic.gdx.scenes.scene2d.utils.Drawable,com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,float,float) -> b
    void setSelection(int,int) -> b
    void setText(java.lang.String) -> b
    void cut(boolean) -> d
    boolean withinMaxLength(int) -> d
    int delete(boolean) -> e
    float getPrefWidth() -> e
    int[] wordUnderCursor(int) -> e
    void next(boolean) -> f
    int letterUnderCursor(float) -> g
    float getPrefHeight() -> h
    int[] wordUnderCursor(float) -> h
com.badlogic.gdx.scenes.scene2d.ui.TextField$1 -> b.a.a.z.a.k.s$a:
    com.badlogic.gdx.scenes.scene2d.ui.TextField this$0 -> f
com.badlogic.gdx.scenes.scene2d.ui.TextField$DefaultOnscreenKeyboard -> b.a.a.z.a.k.s$b:
    void show(boolean) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$KeyRepeatTask -> b.a.a.z.a.k.s$c:
    com.badlogic.gdx.scenes.scene2d.ui.TextField this$0 -> g
    int keycode -> f
com.badlogic.gdx.scenes.scene2d.ui.TextField$OnscreenKeyboard -> b.a.a.z.a.k.s$d:
    void show(boolean) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldClickListener -> b.a.a.z.a.k.s$e:
    com.badlogic.gdx.scenes.scene2d.ui.TextField this$0 -> o
    boolean checkFocusTraversal(char) -> a
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> a
    void scheduleKeyRepeatTask(int) -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
    void goEnd(boolean) -> b
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> b
    void setCursorPosition(float,float) -> b
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void goHome(boolean) -> c
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter -> b.a.a.z.a.k.s$f:
    boolean acceptChar(com.badlogic.gdx.scenes.scene2d.ui.TextField,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter$DigitsOnlyFilter -> b.a.a.z.a.k.s$f$a:
    boolean acceptChar(com.badlogic.gdx.scenes.scene2d.ui.TextField,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldListener -> b.a.a.z.a.k.s$g:
    void keyTyped(com.badlogic.gdx.scenes.scene2d.ui.TextField,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle -> b.a.a.z.a.k.s$h:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable cursor -> h
    com.badlogic.gdx.graphics.Color disabledFontColor -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable selection -> i
    com.badlogic.gdx.graphics.Color messageFontColor -> k
    com.badlogic.gdx.graphics.g2d.BitmapFont messageFont -> j
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> e
    com.badlogic.gdx.graphics.Color focusedFontColor -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable focusedBackground -> f
    com.badlogic.gdx.graphics.Color fontColor -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabledBackground -> g
com.badlogic.gdx.scenes.scene2d.ui.TextTooltip$TextTooltipStyle -> b.a.a.z.a.k.t:
com.badlogic.gdx.scenes.scene2d.ui.Touchpad -> b.a.a.z.a.k.u:
    com.badlogic.gdx.math.Vector2 knobPosition -> D
    float deadzoneRadius -> z
    boolean resetOnTouchUp -> y
    com.badlogic.gdx.math.Circle knobBounds -> A
    com.badlogic.gdx.math.Circle deadzoneBounds -> C
    boolean touched -> x
    com.badlogic.gdx.math.Circle touchBounds -> B
    com.badlogic.gdx.math.Vector2 knobPercent -> E
    com.badlogic.gdx.scenes.scene2d.ui.Touchpad$TouchpadStyle style -> w
    void layout() -> P
    float getKnobPercentX() -> Q
    float getKnobPercentY() -> R
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Touchpad$TouchpadStyle) -> a
    void calculatePositionAndValue(float,float,boolean) -> b
    float getPrefWidth() -> e
    float getPrefHeight() -> h
com.badlogic.gdx.scenes.scene2d.ui.Touchpad$1 -> b.a.a.z.a.k.u$a:
    com.badlogic.gdx.scenes.scene2d.ui.Touchpad this$0 -> b
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
com.badlogic.gdx.scenes.scene2d.ui.Touchpad$TouchpadStyle -> b.a.a.z.a.k.u$b:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knob -> b
com.badlogic.gdx.scenes.scene2d.ui.Tree$TreeStyle -> b.a.a.z.a.k.v:
com.badlogic.gdx.scenes.scene2d.ui.Value -> b.a.a.z.a.k.w:
    com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed zero -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value minHeight -> c
    com.badlogic.gdx.scenes.scene2d.ui.Value minWidth -> b
    com.badlogic.gdx.scenes.scene2d.ui.Value prefHeight -> e
    com.badlogic.gdx.scenes.scene2d.ui.Value prefWidth -> d
    com.badlogic.gdx.scenes.scene2d.ui.Value maxHeight -> g
    com.badlogic.gdx.scenes.scene2d.ui.Value maxWidth -> f
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$1 -> b.a.a.z.a.k.w$a:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$2 -> b.a.a.z.a.k.w$b:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$3 -> b.a.a.z.a.k.w$c:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$4 -> b.a.a.z.a.k.w$d:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$5 -> b.a.a.z.a.k.w$e:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$6 -> b.a.a.z.a.k.w$f:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed -> b.a.a.z.a.k.w$g:
    float value -> h
    com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed[] cache -> i
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed valueOf(float) -> a
com.badlogic.gdx.scenes.scene2d.ui.Widget -> b.a.a.z.a.k.x:
    boolean fillParent -> u
    boolean layoutEnabled -> v
    boolean needsLayout -> t
    void sizeChanged() -> M
    void invalidate() -> O
    void layout() -> P
    float getMinHeight() -> a
    void setLayoutEnabled(boolean) -> a
    float getMinWidth() -> b
    float getMaxHeight() -> c
    void invalidateHierarchy() -> d
    float getPrefWidth() -> e
    float getMaxWidth() -> f
    void validate() -> g
    float getPrefHeight() -> h
com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup -> b.a.a.z.a.k.y:
    boolean needsLayout -> A
    boolean fillParent -> B
    boolean layoutEnabled -> C
    void sizeChanged() -> M
    void childrenChanged() -> O
    void invalidate() -> U
    void layout() -> V
    void pack() -> W
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void setLayoutEnabled(com.badlogic.gdx.scenes.scene2d.Group,boolean) -> a
    void setLayoutEnabled(boolean) -> a
    float getMaxHeight() -> c
    void invalidateHierarchy() -> d
    float getPrefWidth() -> e
    float getMaxWidth() -> f
    void validate() -> g
    float getPrefHeight() -> h
com.badlogic.gdx.scenes.scene2d.ui.Window -> b.a.a.z.a.k.z:
    int edge -> B0
    boolean drawTitleTable -> A0
    boolean dragging -> C0
    com.badlogic.gdx.math.Vector2 tmpPosition -> D0
    com.badlogic.gdx.math.Vector2 tmpSize -> E0
    boolean keepWithinStage -> x0
    com.badlogic.gdx.scenes.scene2d.ui.Table titleTable -> z0
    boolean isModal -> u0
    boolean isMovable -> t0
    com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle style -> s0
    boolean isResizable -> v0
    int resizeBorder -> w0
    com.badlogic.gdx.scenes.scene2d.ui.Label titleLabel -> y0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void drawBackground(com.badlogic.gdx.graphics.g2d.Batch,float,float,float) -> a
    void drawStageBackground(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float) -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle) -> a
    float getPrefWidth() -> e
    void keepWithinStage() -> f0
    void setModal(boolean) -> g
com.badlogic.gdx.scenes.scene2d.ui.Window$1 -> b.a.a.z.a.k.z$a:
    com.badlogic.gdx.scenes.scene2d.ui.Window this$0 -> s0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
com.badlogic.gdx.scenes.scene2d.ui.Window$2 -> b.a.a.z.a.k.z$b:
    com.badlogic.gdx.scenes.scene2d.ui.Window this$0 -> b
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
com.badlogic.gdx.scenes.scene2d.ui.Window$3 -> b.a.a.z.a.k.z$c:
    com.badlogic.gdx.scenes.scene2d.ui.Window this$0 -> f
    float lastY -> e
    float lastX -> d
    float startY -> c
    float startX -> b
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> a
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void updateEdge(float,float) -> a
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> b
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle -> b.a.a.z.a.k.z$d:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable stageBackground -> d
    com.badlogic.gdx.graphics.Color titleFontColor -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont titleFont -> b
com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener -> b.a.a.z.a.l.a:
    com.badlogic.gdx.math.Vector2 tmpCoords -> d
    com.badlogic.gdx.scenes.scene2d.Actor actor -> c
    com.badlogic.gdx.scenes.scene2d.InputEvent event -> b
    com.badlogic.gdx.input.GestureDetector detector -> a
    com.badlogic.gdx.math.Vector2 tmpCoords2 -> e
    void fling(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    com.badlogic.gdx.input.GestureDetector getGestureDetector() -> a
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    boolean longPress(com.badlogic.gdx.scenes.scene2d.Actor,float,float) -> a
    void pan(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> a
    void panStop(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void pinch(com.badlogic.gdx.scenes.scene2d.InputEvent,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
    void zoom(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
    void tap(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> c
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> d
com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener$1 -> b.a.a.z.a.l.a$a:
    com.badlogic.gdx.math.Vector2 pointer1 -> c
    com.badlogic.gdx.math.Vector2 pointer2 -> d
    com.badlogic.gdx.math.Vector2 initialPointer1 -> a
    com.badlogic.gdx.math.Vector2 initialPointer2 -> b
    com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener this$0 -> e
    boolean fling(float,float,int) -> a
    boolean pan(float,float,float,float) -> a
    boolean pinch(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
    void stageToLocalAmount(com.badlogic.gdx.math.Vector2) -> a
    boolean zoom(float,float) -> a
    boolean longPress(float,float) -> b
    boolean panStop(float,float,int,int) -> b
    boolean tap(float,float,int,int) -> c
com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener$2 -> b.a.a.z.a.l.a$b:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$InputEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.utils.ArraySelection -> b.a.a.z.a.l.b:
    java.lang.Object rangeStart -> k
    boolean rangeSelect -> j
    com.badlogic.gdx.utils.Array array -> i
    void changed() -> a
    void choose(java.lang.Object) -> a
    void validate() -> j
com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable -> b.a.a.z.a.l.c:
    float minHeight -> g
    float minWidth -> f
    float bottomHeight -> e
    float topHeight -> d
    float rightWidth -> c
    java.lang.String name -> a
    float leftWidth -> b
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    float getMinHeight() -> a
    void setName(java.lang.String) -> a
    void setTopHeight(float) -> a
    float getMinWidth() -> b
    void setMinHeight(float) -> b
    float getLeftWidth() -> c
    void setMinWidth(float) -> c
    float getRightWidth() -> d
    void setLeftWidth(float) -> d
    float getBottomHeight() -> e
    void setRightWidth(float) -> e
    float getTopHeight() -> f
    void setBottomHeight(float) -> f
    java.lang.String getName() -> g
com.badlogic.gdx.scenes.scene2d.utils.ChangeListener -> b.a.a.z.a.l.d:
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent -> b.a.a.z.a.l.d$a:
com.badlogic.gdx.scenes.scene2d.utils.ClickListener -> b.a.a.z.a.l.e:
    long visualPressedTime -> j
    int tapCount -> l
    long tapCountInterval -> k
    boolean cancelled -> i
    float touchDownY -> d
    int button -> f
    float touchDownX -> c
    float tapSquareSize -> b
    int pressedPointer -> e
    boolean pressed -> g
    boolean over -> h
    long lastTapTime -> m
    float visualPressedDuration -> n
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    int getTapCount() -> a
    boolean inTapSquare(float,float) -> a
    boolean isOver(com.badlogic.gdx.scenes.scene2d.Actor,float,float) -> a
    void setVisualPressed(boolean) -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void invalidateTapSquare() -> b
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    boolean isOver() -> c
    boolean isPressed() -> d
    boolean isVisualPressed() -> e
com.badlogic.gdx.scenes.scene2d.utils.Cullable -> b.a.a.z.a.l.f:
    void setCullingArea(com.badlogic.gdx.math.Rectangle) -> a
com.badlogic.gdx.scenes.scene2d.utils.Disableable -> b.a.a.z.a.l.g:
com.badlogic.gdx.scenes.scene2d.utils.Drawable -> b.a.a.z.a.l.h:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    float getMinHeight() -> a
    void setTopHeight(float) -> a
    float getMinWidth() -> b
    void setMinHeight(float) -> b
    float getLeftWidth() -> c
    void setMinWidth(float) -> c
    float getRightWidth() -> d
    void setLeftWidth(float) -> d
    float getBottomHeight() -> e
    void setRightWidth(float) -> e
    float getTopHeight() -> f
    void setBottomHeight(float) -> f
com.badlogic.gdx.scenes.scene2d.utils.FocusListener -> b.a.a.z.a.l.i:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void keyboardFocusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent,com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> a
    void scrollFocusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent,com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> b
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$1 -> b.a.a.z.a.l.i$a:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$utils$FocusListener$FocusEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent -> b.a.a.z.a.l.i$b:
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type type -> i
    boolean focused -> h
    com.badlogic.gdx.scenes.scene2d.Actor relatedActor -> j
    void reset() -> a
    void setType(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type) -> a
    void setFocused(boolean) -> b
    void setRelatedActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    com.badlogic.gdx.scenes.scene2d.Actor getRelatedActor() -> l
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type getType() -> m
    boolean isFocused() -> n
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type -> b.a.a.z.a.l.i$b$a:
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type keyboard -> a
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type scroll -> b
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type[] $VALUES -> c
com.badlogic.gdx.scenes.scene2d.utils.Layout -> b.a.a.z.a.l.j:
    float getMinHeight() -> a
    void setLayoutEnabled(boolean) -> a
    float getMinWidth() -> b
    float getMaxHeight() -> c
    void invalidateHierarchy() -> d
    float getPrefWidth() -> e
    float getMaxWidth() -> f
    void validate() -> g
    float getPrefHeight() -> h
com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable -> b.a.a.z.a.l.k:
    com.badlogic.gdx.graphics.g2d.NinePatch patch -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> a
    void setPatch(com.badlogic.gdx.graphics.g2d.NinePatch) -> a
    com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable tint(com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch() -> h
com.badlogic.gdx.scenes.scene2d.utils.ScissorStack -> b.a.a.z.a.l.l:
    com.badlogic.gdx.math.Vector3 tmp -> b
    com.badlogic.gdx.utils.Array scissors -> a
    void calculateScissors(com.badlogic.gdx.graphics.Camera,float,float,float,float,com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
    void fix(com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.math.Rectangle popScissors() -> a
    boolean pushScissors(com.badlogic.gdx.math.Rectangle) -> b
com.badlogic.gdx.scenes.scene2d.utils.Selection -> b.a.a.z.a.l.m:
    com.badlogic.gdx.utils.OrderedSet selected -> b
    com.badlogic.gdx.utils.OrderedSet old -> c
    boolean toggle -> e
    boolean multiple -> f
    boolean required -> g
    boolean programmaticChangeEvents -> h
    com.badlogic.gdx.scenes.scene2d.Actor actor -> a
    boolean isDisabled -> d
    void addAll(com.badlogic.gdx.utils.Array) -> a
    void changed() -> a
    void choose(java.lang.Object) -> a
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void setRequired(boolean) -> a
    void cleanup() -> b
    void set(java.lang.Object) -> b
    boolean fireChangeEvent() -> c
    java.lang.Object first() -> d
    boolean getMultiple() -> e
    boolean isDisabled() -> f
    com.badlogic.gdx.utils.OrderedSet items() -> g
    void revert() -> h
    void snapshot() -> i
com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable -> b.a.a.z.a.l.n:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> a
    void setSprite(com.badlogic.gdx.graphics.g2d.Sprite) -> a
    com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable tint(com.badlogic.gdx.graphics.Color) -> a
com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable -> b.a.a.z.a.l.o:
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> a
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable tint(com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion() -> h
com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable -> b.a.a.z.a.l.p:
    float scale -> j
    com.badlogic.gdx.graphics.Color color -> i
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable tint(com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable tint(com.badlogic.gdx.graphics.Color) -> a
com.badlogic.gdx.scenes.scene2d.utils.TransformDrawable -> b.a.a.z.a.l.q:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> a
com.badlogic.gdx.scenes.scene2d.utils.UIUtils -> b.a.a.z.a.l.r:
    boolean isIos -> e
    boolean isAndroid -> a
    boolean isMac -> b
    boolean isWindows -> c
    boolean isLinux -> d
    boolean ctrl() -> a
    boolean shift() -> b
com.badlogic.gdx.utils.Array -> com.badlogic.gdx.utils.a:
    com.badlogic.gdx.utils.Array$ArrayIterable iterable -> d
    java.lang.Object[] items -> a
    int size -> b
    boolean ordered -> c
    void addAll(com.badlogic.gdx.utils.Array) -> a
    void addAll(com.badlogic.gdx.utils.Array,int,int) -> a
    void addAll(java.lang.Object[]) -> a
    void addAll(java.lang.Object[],int,int) -> a
    boolean contains(java.lang.Object,boolean) -> a
    java.lang.Object[] ensureCapacity(int) -> a
    java.lang.Object first() -> a
    void insert(int,java.lang.Object) -> a
    void removeRange(int,int) -> a
    void sort(java.util.Comparator) -> a
    java.lang.Object[] toArray(java.lang.Class) -> a
    java.lang.String toString(java.lang.String) -> a
    java.lang.Object get(int) -> b
    int indexOf(java.lang.Object,boolean) -> b
    java.lang.Object peek() -> b
    void set(int,java.lang.Object) -> b
    com.badlogic.gdx.utils.Array with(java.lang.Object[]) -> b
    java.lang.Object pop() -> c
    java.lang.Object removeIndex(int) -> c
    boolean removeValue(java.lang.Object,boolean) -> c
    java.lang.Object random() -> d
    java.lang.Object[] resize(int) -> d
    void sort() -> e
    void truncate(int) -> e
com.badlogic.gdx.utils.Array$ArrayIterable -> com.badlogic.gdx.utils.a$a:
    com.badlogic.gdx.utils.Array array -> a
    com.badlogic.gdx.utils.Array$ArrayIterator iterator2 -> d
    com.badlogic.gdx.utils.Array$ArrayIterator iterator1 -> c
    boolean allowRemove -> b
com.badlogic.gdx.utils.Array$ArrayIterator -> com.badlogic.gdx.utils.a$b:
    com.badlogic.gdx.utils.Array array -> a
    boolean allowRemove -> b
    int index -> c
    boolean valid -> d
com.badlogic.gdx.utils.ArrayMap -> com.badlogic.gdx.utils.b:
    java.lang.Object[] values -> b
    java.lang.Object[] keys -> a
    com.badlogic.gdx.utils.ArrayMap$Entries entries2 -> f
    int size -> c
    boolean ordered -> d
    com.badlogic.gdx.utils.ArrayMap$Entries entries1 -> e
    com.badlogic.gdx.utils.ArrayMap$Entries entries() -> a
    java.lang.Object get(java.lang.Object) -> a
    java.lang.Object get(java.lang.Object,java.lang.Object) -> a
    void removeIndex(int) -> a
    int indexOfKey(java.lang.Object) -> b
    int put(java.lang.Object,java.lang.Object) -> b
    void resize(int) -> b
com.badlogic.gdx.utils.ArrayMap$Entries -> com.badlogic.gdx.utils.b$a:
    com.badlogic.gdx.utils.ArrayMap map -> a
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> b
    int index -> c
    boolean valid -> d
com.badlogic.gdx.utils.BaseJsonReader -> com.badlogic.gdx.utils.c:
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.utils.BufferUtils -> com.badlogic.gdx.utils.BufferUtils:
    com.badlogic.gdx.utils.Array unsafeBuffers -> a
    int allocatedUnsafe -> b
    void copy(float[],java.nio.Buffer,int,int) -> a
    void disposeUnsafeByteBuffer(java.nio.ByteBuffer) -> a
    java.nio.ByteBuffer newByteBuffer(int) -> a
    java.nio.FloatBuffer newFloatBuffer(int) -> b
    java.nio.IntBuffer newIntBuffer(int) -> c
    java.nio.ByteBuffer newUnsafeByteBuffer(int) -> d
com.badlogic.gdx.utils.Clipboard -> com.badlogic.gdx.utils.d:
    java.lang.String getContents() -> a
    void setContents(java.lang.String) -> a
com.badlogic.gdx.utils.Collections -> com.badlogic.gdx.utils.e:
    boolean allocateIterators -> a
com.badlogic.gdx.utils.ComparableTimSort -> com.badlogic.gdx.utils.f:
    int[] runBase -> f
    int[] runLen -> g
    java.lang.Object[] tmp -> c
    int tmpCount -> d
    int stackSize -> e
    int minGallop -> b
    void binarySort(java.lang.Object[],int,int,int) -> a
    void doSort(java.lang.Object[],int,int) -> a
    java.lang.Object[] ensureCapacity(int) -> a
    int gallopLeft(java.lang.Comparable,java.lang.Object[],int,int,int) -> a
    void mergeCollapse() -> a
    void mergeHi(int,int,int,int) -> a
    void pushRun(int,int) -> a
    void rangeCheck(int,int,int) -> a
    int countRunAndMakeAscending(java.lang.Object[],int,int) -> b
    int gallopRight(java.lang.Comparable,java.lang.Object[],int,int,int) -> b
    void mergeAt(int) -> b
    void mergeForceCollapse() -> b
    void mergeLo(int,int,int,int) -> b
    int minRunLength(int) -> c
    void reverseRange(java.lang.Object[],int,int) -> c
com.badlogic.gdx.utils.DelayedRemovalArray -> com.badlogic.gdx.utils.g:
    com.badlogic.gdx.utils.IntArray remove -> f
    int clear -> g
    int iterating -> e
    void insert(int,java.lang.Object) -> a
    void removeRange(int,int) -> a
    void sort(java.util.Comparator) -> a
    void set(int,java.lang.Object) -> b
    java.lang.Object pop() -> c
    java.lang.Object removeIndex(int) -> c
    boolean removeValue(java.lang.Object,boolean) -> c
    void sort() -> e
    void truncate(int) -> e
    void begin() -> f
    void remove(int) -> f
    void end() -> g
com.badlogic.gdx.utils.Disposable -> com.badlogic.gdx.utils.h:
    void dispose() -> a
com.badlogic.gdx.utils.FloatArray -> com.badlogic.gdx.utils.i:
    float[] items -> a
    int size -> b
    boolean ordered -> c
    void add(float) -> a
    void addAll(com.badlogic.gdx.utils.FloatArray) -> a
    void addAll(com.badlogic.gdx.utils.FloatArray,int,int) -> a
    void addAll(float[],int,int) -> a
    void clear() -> a
    float[] ensureCapacity(int) -> a
    void removeRange(int,int) -> a
    float first() -> b
    float get(int) -> b
    float[] resize(int) -> c
    void truncate(int) -> d
com.badlogic.gdx.utils.GdxNativesLoader -> com.badlogic.gdx.utils.j:
    boolean disableNativesLoading -> a
    boolean nativesLoaded -> b
    void load() -> a
com.badlogic.gdx.utils.GdxRuntimeException -> com.badlogic.gdx.utils.k:
com.badlogic.gdx.utils.I18NBundle -> com.badlogic.gdx.utils.l:
    java.util.Locale locale -> b
    com.badlogic.gdx.utils.I18NBundle parent -> a
    boolean simpleFormatter -> e
    java.util.Locale ROOT_LOCALE -> d
    com.badlogic.gdx.utils.ObjectMap properties -> c
    boolean checkFileExistence(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.utils.I18NBundle createBundle(com.badlogic.gdx.files.FileHandle,java.util.Locale) -> a
    com.badlogic.gdx.utils.I18NBundle createBundle(com.badlogic.gdx.files.FileHandle,java.util.Locale,java.lang.String) -> a
    java.util.List getCandidateLocales(java.util.Locale) -> a
    java.util.Locale getLocale() -> a
    void load(java.io.Reader) -> a
    com.badlogic.gdx.utils.I18NBundle loadBundle(com.badlogic.gdx.files.FileHandle,java.lang.String,java.util.Locale) -> a
    com.badlogic.gdx.utils.I18NBundle loadBundleChain(com.badlogic.gdx.files.FileHandle,java.lang.String,java.util.List,int,com.badlogic.gdx.utils.I18NBundle) -> a
    com.badlogic.gdx.utils.I18NBundle createBundleImpl(com.badlogic.gdx.files.FileHandle,java.util.Locale,java.lang.String) -> b
    java.util.Locale getFallbackLocale(java.util.Locale) -> b
    com.badlogic.gdx.files.FileHandle toFileHandle(com.badlogic.gdx.files.FileHandle,java.util.Locale) -> b
    void setLocale(java.util.Locale) -> c
com.badlogic.gdx.utils.IntArray -> com.badlogic.gdx.utils.m:
    int[] items -> a
    int size -> b
    boolean ordered -> c
    void add(int) -> a
    void addAll(int[]) -> a
    void addAll(int[],int,int) -> a
    void clear() -> a
    void insert(int,int) -> a
    int[] ensureCapacity(int) -> b
    int pop() -> b
    int get(int) -> c
    int removeIndex(int) -> d
    int[] resize(int) -> e
com.badlogic.gdx.utils.IntIntMap -> com.badlogic.gdx.utils.n:
    int[] keyTable -> b
    int[] valueTable -> c
    float loadFactor -> f
    int shift -> h
    int mask -> i
    boolean hasZeroValue -> e
    int threshold -> g
    com.badlogic.gdx.utils.IntIntMap$Entries entries2 -> k
    int zeroValue -> d
    com.badlogic.gdx.utils.IntIntMap$Entries entries1 -> j
    int size -> a
    boolean containsKey(int) -> a
    com.badlogic.gdx.utils.IntIntMap$Entries entries() -> a
    int get(int,int) -> a
    int place(int) -> b
    void put(int,int) -> b
    int locateKey(int) -> c
    int remove(int,int) -> c
    void putResize(int,int) -> d
    void resize(int) -> d
com.badlogic.gdx.utils.IntIntMap$Entries -> com.badlogic.gdx.utils.n$a:
    com.badlogic.gdx.utils.IntIntMap$Entry entry -> f
    void reset() -> b
com.badlogic.gdx.utils.IntIntMap$Entry -> com.badlogic.gdx.utils.n$b:
    int value -> b
    int key -> a
com.badlogic.gdx.utils.IntIntMap$MapIterator -> com.badlogic.gdx.utils.n$c:
    com.badlogic.gdx.utils.IntIntMap map -> b
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    int nextIndex -> c
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.IntMap -> com.badlogic.gdx.utils.o:
    java.lang.Object[] valueTable -> c
    int[] keyTable -> b
    com.badlogic.gdx.utils.IntMap$Entries entries1 -> j
    com.badlogic.gdx.utils.IntMap$Entries entries2 -> k
    java.lang.Object zeroValue -> d
    float loadFactor -> f
    int shift -> h
    int mask -> i
    boolean hasZeroValue -> e
    int threshold -> g
    int size -> a
    void ensureCapacity(int) -> a
    com.badlogic.gdx.utils.IntMap$Entries entries() -> a
    java.lang.Object get(int,java.lang.Object) -> a
    void putAll(com.badlogic.gdx.utils.IntMap) -> a
    java.lang.Object get(int) -> b
    java.lang.Object put(int,java.lang.Object) -> b
    int place(int) -> c
    void putResize(int,java.lang.Object) -> c
    java.lang.Object remove(int) -> d
    int locateKey(int) -> e
    void resize(int) -> f
com.badlogic.gdx.utils.IntMap$Entries -> com.badlogic.gdx.utils.o$a:
    com.badlogic.gdx.utils.IntMap$Entry entry -> f
    void reset() -> b
com.badlogic.gdx.utils.IntMap$Entry -> com.badlogic.gdx.utils.o$b:
    java.lang.Object value -> b
    int key -> a
com.badlogic.gdx.utils.IntMap$MapIterator -> com.badlogic.gdx.utils.o$c:
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    int nextIndex -> c
    com.badlogic.gdx.utils.IntMap map -> b
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.IntSet -> com.badlogic.gdx.utils.p:
    int[] keyTable -> b
    float loadFactor -> d
    int shift -> f
    int mask -> g
    int threshold -> e
    boolean hasZeroValue -> c
    int size -> a
    boolean add(int) -> a
    boolean contains(int) -> b
    int place(int) -> c
    boolean remove(int) -> d
    void addResize(int) -> e
    int locateKey(int) -> f
    void resize(int) -> g
com.badlogic.gdx.utils.Json -> com.badlogic.gdx.utils.q:
    com.badlogic.gdx.utils.ObjectMap tagToClass -> i
    com.badlogic.gdx.utils.ObjectMap typeToFields -> h
    com.badlogic.gdx.utils.Json$Serializer defaultSerializer -> g
    com.badlogic.gdx.utils.ObjectMap classToSerializer -> k
    com.badlogic.gdx.utils.ObjectMap classToTag -> j
    boolean enumNames -> e
    boolean sortFields -> f
    java.lang.String typeName -> a
    boolean ignoreUnknownFields -> b
    boolean ignoreDeprecated -> c
    boolean readDeprecated -> d
    void addClassTag(java.lang.String,java.lang.Class) -> a
    java.lang.String convertToString(java.lang.Enum) -> a
    void copyFields(java.lang.Object,java.lang.Object) -> a
    java.lang.Object fromJson(java.lang.Class,com.badlogic.gdx.files.FileHandle) -> a
    java.lang.Class getClass(java.lang.String) -> a
    boolean ignoreUnknownField(java.lang.Class,java.lang.String) -> a
    java.lang.Object newInstance(java.lang.Class) -> a
    void readFields(java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.String,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.String,java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.String,java.lang.Class,java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> a
    void setSerializer(java.lang.Class,com.badlogic.gdx.utils.Json$Serializer) -> a
    void setUsePrototypes(boolean) -> a
    com.badlogic.gdx.utils.OrderedMap getFields(java.lang.Class) -> b
    void setTypeName(java.lang.String) -> b
com.badlogic.gdx.utils.Json$FieldMetadata -> com.badlogic.gdx.utils.q$a:
    com.badlogic.gdx.utils.reflect.Field field -> a
    java.lang.Class elementType -> b
    boolean deprecated -> c
com.badlogic.gdx.utils.Json$ReadOnlySerializer -> com.badlogic.gdx.utils.q$b:
com.badlogic.gdx.utils.Json$Serializable -> com.badlogic.gdx.utils.q$c:
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.utils.Json$Serializer -> com.badlogic.gdx.utils.q$d:
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
com.badlogic.gdx.utils.JsonReader -> com.badlogic.gdx.utils.r:
    short[] _json_index_offsets -> j
    byte[] _json_trans_targs -> l
    com.badlogic.gdx.utils.Array elements -> a
    byte[] _json_indicies -> k
    char[] _json_trans_keys -> g
    byte[] _json_eof_actions -> n
    byte[] _json_trans_actions -> m
    short[] _json_key_offsets -> f
    byte[] _json_single_lengths -> h
    com.badlogic.gdx.utils.JsonValue current -> d
    byte[] _json_range_lengths -> i
    com.badlogic.gdx.utils.Array lastChild -> b
    com.badlogic.gdx.utils.JsonValue root -> c
    byte[] _json_actions -> e
    void addChild(java.lang.String,com.badlogic.gdx.utils.JsonValue) -> a
    void bool(java.lang.String,boolean) -> a
    void number(java.lang.String,double,java.lang.String) -> a
    void number(java.lang.String,long,java.lang.String) -> a
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.Reader) -> a
    com.badlogic.gdx.utils.JsonValue parse(char[],int,int) -> a
    void pop() -> a
    void startArray(java.lang.String) -> a
    void string(java.lang.String,java.lang.String) -> a
    byte[] init__json_actions_0() -> b
    void startObject(java.lang.String) -> b
    byte[] init__json_eof_actions_0() -> c
    java.lang.String unescape(java.lang.String) -> c
    short[] init__json_index_offsets_0() -> d
    byte[] init__json_indicies_0() -> e
    short[] init__json_key_offsets_0() -> f
    byte[] init__json_range_lengths_0() -> g
    byte[] init__json_single_lengths_0() -> h
    byte[] init__json_trans_actions_0() -> i
    char[] init__json_trans_keys_0() -> j
    byte[] init__json_trans_targs_0() -> k
com.badlogic.gdx.utils.JsonValue -> com.badlogic.gdx.utils.s:
    com.badlogic.gdx.utils.JsonValue$ValueType type -> a
    int size -> j
    double doubleValue -> c
    long longValue -> d
    com.badlogic.gdx.utils.JsonValue next -> h
    java.lang.String stringValue -> b
    com.badlogic.gdx.utils.JsonValue prev -> i
    java.lang.String name -> e
    com.badlogic.gdx.utils.JsonValue child -> f
    com.badlogic.gdx.utils.JsonValue parent -> g
    boolean asBoolean() -> a
    com.badlogic.gdx.utils.JsonValue get(int) -> a
    com.badlogic.gdx.utils.JsonValue get(java.lang.String) -> a
    float getFloat(java.lang.String,float) -> a
    java.lang.String getString(java.lang.String,java.lang.String) -> a
    void indent(int,com.badlogic.gdx.utils.StringBuilder) -> a
    boolean isFlat(com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.String prettyPrint(com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings) -> a
    java.lang.String prettyPrint(com.badlogic.gdx.utils.JsonWriter$OutputType,int) -> a
    void prettyPrint(com.badlogic.gdx.utils.JsonValue,com.badlogic.gdx.utils.StringBuilder,int,com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings) -> a
    void set(double,java.lang.String) -> a
    void set(long,java.lang.String) -> a
    void set(boolean) -> a
    byte asByte() -> b
    com.badlogic.gdx.utils.JsonValue getChild(java.lang.String) -> b
    float getFloat(int) -> b
    boolean isNumeric(com.badlogic.gdx.utils.JsonValue) -> b
    double asDouble() -> c
    short getShort(int) -> c
    java.lang.String getString(java.lang.String) -> c
    float asFloat() -> d
    boolean has(java.lang.String) -> d
    float[] asFloatArray() -> e
    com.badlogic.gdx.utils.JsonValue require(java.lang.String) -> e
    int asInt() -> f
    void set(java.lang.String) -> f
    long asLong() -> g
    void setName(java.lang.String) -> g
    short asShort() -> h
    short[] asShortArray() -> i
    java.lang.String asString() -> j
    boolean isArray() -> k
    boolean isBoolean() -> l
    boolean isDouble() -> m
    boolean isLong() -> n
    boolean isNull() -> o
    boolean isNumber() -> p
    boolean isObject() -> q
    boolean isString() -> r
    boolean isValue() -> s
    java.lang.String name() -> t
    java.lang.String trace() -> u
com.badlogic.gdx.utils.JsonValue$1 -> com.badlogic.gdx.utils.s$a:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonValue$ValueType -> a
com.badlogic.gdx.utils.JsonValue$JsonIterator -> com.badlogic.gdx.utils.s$b:
    com.badlogic.gdx.utils.JsonValue entry -> a
    com.badlogic.gdx.utils.JsonValue current -> b
    com.badlogic.gdx.utils.JsonValue this$0 -> c
com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings -> com.badlogic.gdx.utils.s$c:
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> a
    int singleLineColumns -> b
    boolean wrapNumericArrays -> c
com.badlogic.gdx.utils.JsonValue$ValueType -> com.badlogic.gdx.utils.s$d:
    com.badlogic.gdx.utils.JsonValue$ValueType doubleValue -> d
    com.badlogic.gdx.utils.JsonValue$ValueType stringValue -> c
    com.badlogic.gdx.utils.JsonValue$ValueType array -> b
    com.badlogic.gdx.utils.JsonValue$ValueType[] $VALUES -> h
    com.badlogic.gdx.utils.JsonValue$ValueType object -> a
    com.badlogic.gdx.utils.JsonValue$ValueType nullValue -> g
    com.badlogic.gdx.utils.JsonValue$ValueType booleanValue -> f
    com.badlogic.gdx.utils.JsonValue$ValueType longValue -> e
com.badlogic.gdx.utils.JsonWriter$1 -> com.badlogic.gdx.utils.t:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonWriter$OutputType -> a
com.badlogic.gdx.utils.JsonWriter$OutputType -> com.badlogic.gdx.utils.u:
    java.util.regex.Pattern minimalValuePattern -> f
    com.badlogic.gdx.utils.JsonWriter$OutputType javascript -> b
    com.badlogic.gdx.utils.JsonWriter$OutputType json -> a
    java.util.regex.Pattern minimalNamePattern -> e
    com.badlogic.gdx.utils.JsonWriter$OutputType minimal -> c
    java.util.regex.Pattern javascriptPattern -> d
    com.badlogic.gdx.utils.JsonWriter$OutputType[] $VALUES -> g
    java.lang.String quoteName(java.lang.String) -> a
    java.lang.String quoteValue(java.lang.Object) -> a
com.badlogic.gdx.utils.Logger -> com.badlogic.gdx.utils.v:
    java.lang.String tag -> a
    int level -> b
    void debug(java.lang.String) -> a
    void error(java.lang.String,java.lang.Throwable) -> a
    int getLevel() -> a
    void error(java.lang.String) -> b
    void info(java.lang.String) -> c
com.badlogic.gdx.utils.LongMap -> com.badlogic.gdx.utils.w:
    com.badlogic.gdx.utils.LongMap$Entries entries2 -> k
    com.badlogic.gdx.utils.LongMap$Entries entries1 -> j
    java.lang.Object[] valueTable -> c
    java.lang.Object zeroValue -> d
    float loadFactor -> f
    int shift -> h
    long[] keyTable -> b
    int mask -> i
    boolean hasZeroValue -> e
    int threshold -> g
    int size -> a
    com.badlogic.gdx.utils.LongMap$Entries entries() -> a
    java.lang.Object get(long) -> a
    java.lang.Object get(long,java.lang.Object) -> a
    void resize(int) -> a
    int place(long) -> b
    java.lang.Object put(long,java.lang.Object) -> b
    int locateKey(long) -> c
    void putResize(long,java.lang.Object) -> c
com.badlogic.gdx.utils.LongMap$Entries -> com.badlogic.gdx.utils.w$a:
    com.badlogic.gdx.utils.LongMap$Entry entry -> f
    void reset() -> b
com.badlogic.gdx.utils.LongMap$Entry -> com.badlogic.gdx.utils.w$b:
    java.lang.Object value -> b
    long key -> a
com.badlogic.gdx.utils.LongMap$MapIterator -> com.badlogic.gdx.utils.w$c:
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    com.badlogic.gdx.utils.LongMap map -> b
    int nextIndex -> c
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.NumberUtils -> com.badlogic.gdx.utils.x:
    int floatToIntBits(float) -> a
    float intToFloatColor(int) -> a
    int floatToIntColor(float) -> b
    int floatToRawIntBits(float) -> c
com.badlogic.gdx.utils.ObjectFloatMap -> com.badlogic.gdx.utils.y:
    java.lang.Object[] keyTable -> b
    float loadFactor -> d
    int shift -> f
    com.badlogic.gdx.utils.ObjectFloatMap$Entries entries2 -> i
    int mask -> g
    com.badlogic.gdx.utils.ObjectFloatMap$Entries entries1 -> h
    float[] valueTable -> c
    int threshold -> e
    int size -> a
    boolean containsKey(java.lang.Object) -> a
    com.badlogic.gdx.utils.ObjectFloatMap$Entries entries() -> a
    float get(java.lang.Object,float) -> a
    void resize(int) -> a
    java.lang.String toString(java.lang.String,boolean) -> a
    int locateKey(java.lang.Object) -> b
    void put(java.lang.Object,float) -> b
    int place(java.lang.Object) -> c
    void putResize(java.lang.Object,float) -> c
com.badlogic.gdx.utils.ObjectFloatMap$Entries -> com.badlogic.gdx.utils.y$a:
    com.badlogic.gdx.utils.ObjectFloatMap$Entry entry -> f
    void reset() -> b
com.badlogic.gdx.utils.ObjectFloatMap$Entry -> com.badlogic.gdx.utils.y$b:
    float value -> b
    java.lang.Object key -> a
com.badlogic.gdx.utils.ObjectFloatMap$MapIterator -> com.badlogic.gdx.utils.y$c:
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    int nextIndex -> c
    com.badlogic.gdx.utils.ObjectFloatMap map -> b
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectIntMap -> com.badlogic.gdx.utils.z:
    java.lang.Object[] keyTable -> b
    int[] valueTable -> c
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries1 -> h
    float loadFactor -> d
    int shift -> f
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries2 -> i
    int mask -> g
    int threshold -> e
    int size -> a
    boolean containsKey(java.lang.Object) -> a
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries() -> a
    int get(java.lang.Object,int) -> a
    int getAndIncrement(java.lang.Object,int,int) -> a
    void resize(int) -> a
    java.lang.String toString(java.lang.String,boolean) -> a
    int locateKey(java.lang.Object) -> b
    void put(java.lang.Object,int) -> b
    int place(java.lang.Object) -> c
    void putResize(java.lang.Object,int) -> c
com.badlogic.gdx.utils.ObjectIntMap$Entries -> com.badlogic.gdx.utils.z$a:
    com.badlogic.gdx.utils.ObjectIntMap$Entry entry -> f
    void reset() -> b
com.badlogic.gdx.utils.ObjectIntMap$Entry -> com.badlogic.gdx.utils.z$b:
    java.lang.Object key -> a
    int value -> b
com.badlogic.gdx.utils.ObjectIntMap$MapIterator -> com.badlogic.gdx.utils.z$c:
    boolean valid -> e
    int currentIndex -> d
    com.badlogic.gdx.utils.ObjectIntMap map -> b
    boolean hasNext -> a
    int nextIndex -> c
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectMap -> com.badlogic.gdx.utils.a0:
    java.lang.Object[] keyTable -> b
    java.lang.Object[] valueTable -> c
    float loadFactor -> d
    int shift -> f
    int mask -> g
    int threshold -> e
    java.lang.Object dummy -> n
    com.badlogic.gdx.utils.ObjectMap$Values values1 -> j
    com.badlogic.gdx.utils.ObjectMap$Values values2 -> k
    int size -> a
    com.badlogic.gdx.utils.ObjectMap$Keys keys1 -> l
    com.badlogic.gdx.utils.ObjectMap$Keys keys2 -> m
    com.badlogic.gdx.utils.ObjectMap$Entries entries1 -> h
    com.badlogic.gdx.utils.ObjectMap$Entries entries2 -> i
    boolean containsKey(java.lang.Object) -> a
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> a
    java.lang.Object get(java.lang.Object,java.lang.Object) -> a
    void resize(int) -> a
    java.lang.String toString(java.lang.String,boolean) -> a
    java.lang.Object get(java.lang.Object) -> b
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> b
    java.lang.Object put(java.lang.Object,java.lang.Object) -> b
    int locateKey(java.lang.Object) -> c
    void putResize(java.lang.Object,java.lang.Object) -> c
    com.badlogic.gdx.utils.ObjectMap$Values values() -> c
    int place(java.lang.Object) -> d
com.badlogic.gdx.utils.ObjectMap$Entries -> com.badlogic.gdx.utils.a0$a:
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> f
    void reset() -> b
com.badlogic.gdx.utils.ObjectMap$Entry -> com.badlogic.gdx.utils.a0$b:
    java.lang.Object value -> b
    java.lang.Object key -> a
com.badlogic.gdx.utils.ObjectMap$Keys -> com.badlogic.gdx.utils.a0$c:
    com.badlogic.gdx.utils.Array toArray(com.badlogic.gdx.utils.Array) -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectMap$MapIterator -> com.badlogic.gdx.utils.a0$d:
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    int nextIndex -> c
    com.badlogic.gdx.utils.ObjectMap map -> b
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectMap$Values -> com.badlogic.gdx.utils.a0$e:
    void reset() -> b
com.badlogic.gdx.utils.ObjectSet -> com.badlogic.gdx.utils.b0:
    java.lang.Object[] keyTable -> b
    int mask -> f
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator1 -> g
    float loadFactor -> c
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator2 -> h
    int threshold -> d
    int shift -> e
    int size -> a
    void clear(int) -> a
    java.lang.Object first() -> a
    int locateKey(java.lang.Object) -> a
    int tableSize(int,float) -> a
    java.lang.String toString(java.lang.String) -> a
    void ensureCapacity(int) -> b
    int place(java.lang.Object) -> b
    void addResize(java.lang.Object) -> c
    void resize(int) -> c
com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator -> com.badlogic.gdx.utils.b0$a:
    com.badlogic.gdx.utils.ObjectSet set -> b
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    int nextIndex -> c
    void reset() -> a
    void findNextIndex() -> b
com.badlogic.gdx.utils.OrderedMap -> com.badlogic.gdx.utils.c0:
    com.badlogic.gdx.utils.Array keys -> o
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> a
    java.lang.String toString(java.lang.String,boolean) -> a
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> b
    java.lang.Object put(java.lang.Object,java.lang.Object) -> b
    java.lang.Object removeIndex(int) -> b
    com.badlogic.gdx.utils.ObjectMap$Values values() -> c
com.badlogic.gdx.utils.OrderedMap$OrderedMapEntries -> com.badlogic.gdx.utils.c0$a:
    com.badlogic.gdx.utils.Array keys -> g
    void reset() -> b
com.badlogic.gdx.utils.OrderedMap$OrderedMapKeys -> com.badlogic.gdx.utils.c0$b:
    com.badlogic.gdx.utils.Array keys -> f
    com.badlogic.gdx.utils.Array toArray(com.badlogic.gdx.utils.Array) -> a
    void reset() -> b
com.badlogic.gdx.utils.OrderedMap$OrderedMapValues -> com.badlogic.gdx.utils.c0$c:
    com.badlogic.gdx.utils.Array keys -> f
    void reset() -> b
com.badlogic.gdx.utils.OrderedSet -> com.badlogic.gdx.utils.d0:
    com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator iterator1 -> j
    com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator iterator2 -> k
    com.badlogic.gdx.utils.Array items -> i
    void addAll(com.badlogic.gdx.utils.OrderedSet) -> a
    void clear(int) -> a
    java.lang.String toString(java.lang.String) -> a
    java.lang.Object removeIndex(int) -> c
com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator -> com.badlogic.gdx.utils.d0$a:
    com.badlogic.gdx.utils.Array items -> f
    void reset() -> a
com.badlogic.gdx.utils.Pool -> com.badlogic.gdx.utils.e0:
    com.badlogic.gdx.utils.Array freeObjects -> c
    int peak -> b
    int max -> a
    void discard(java.lang.Object) -> a
    void freeAll(com.badlogic.gdx.utils.Array) -> a
    java.lang.Object newObject() -> a
    void free(java.lang.Object) -> b
    java.lang.Object obtain() -> b
    void reset(java.lang.Object) -> c
com.badlogic.gdx.utils.Pool$Poolable -> com.badlogic.gdx.utils.e0$a:
    void reset() -> a
com.badlogic.gdx.utils.Pools -> com.badlogic.gdx.utils.f0:
    com.badlogic.gdx.utils.ObjectMap typePools -> a
    void free(java.lang.Object) -> a
    void freeAll(com.badlogic.gdx.utils.Array,boolean) -> a
    com.badlogic.gdx.utils.Pool get(java.lang.Class) -> a
    com.badlogic.gdx.utils.Pool get(java.lang.Class,int) -> a
    java.lang.Object obtain(java.lang.Class) -> b
com.badlogic.gdx.utils.PropertiesUtils -> com.badlogic.gdx.utils.g0:
    void load(com.badlogic.gdx.utils.ObjectMap,java.io.Reader) -> a
com.badlogic.gdx.utils.Queue -> com.badlogic.gdx.utils.h0:
    java.lang.Object[] values -> a
    int size -> d
    int head -> b
    com.badlogic.gdx.utils.Queue$QueueIterable iterable -> e
    int tail -> c
    void addLast(java.lang.Object) -> a
    java.lang.Object get(int) -> a
    java.lang.Object removeIndex(int) -> b
    void resize(int) -> c
com.badlogic.gdx.utils.Queue$QueueIterable -> com.badlogic.gdx.utils.h0$a:
    boolean allowRemove -> b
    com.badlogic.gdx.utils.Queue queue -> a
    com.badlogic.gdx.utils.Queue$QueueIterator iterator1 -> c
    com.badlogic.gdx.utils.Queue$QueueIterator iterator2 -> d
com.badlogic.gdx.utils.Queue$QueueIterator -> com.badlogic.gdx.utils.h0$b:
    boolean allowRemove -> b
    int index -> c
    com.badlogic.gdx.utils.Queue queue -> a
    boolean valid -> d
com.badlogic.gdx.utils.ReflectionPool -> com.badlogic.gdx.utils.i0:
    com.badlogic.gdx.utils.reflect.Constructor constructor -> d
    com.badlogic.gdx.utils.reflect.Constructor findConstructor(java.lang.Class) -> a
    java.lang.Object newObject() -> a
com.badlogic.gdx.utils.Scaling -> com.badlogic.gdx.utils.j0:
    com.badlogic.gdx.math.Vector2 temp -> a
    com.badlogic.gdx.utils.Scaling none -> d
    com.badlogic.gdx.utils.Scaling stretch -> c
    com.badlogic.gdx.utils.Scaling fit -> b
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$1 -> com.badlogic.gdx.utils.j0$a:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$2 -> com.badlogic.gdx.utils.j0$b:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$3 -> com.badlogic.gdx.utils.j0$c:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$4 -> com.badlogic.gdx.utils.j0$d:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$5 -> com.badlogic.gdx.utils.j0$e:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$6 -> com.badlogic.gdx.utils.j0$f:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$7 -> com.badlogic.gdx.utils.j0$g:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$8 -> com.badlogic.gdx.utils.j0$h:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.SerializationException -> com.badlogic.gdx.utils.k0:
    com.badlogic.gdx.utils.StringBuilder trace -> a
    void addTrace(java.lang.String) -> a
com.badlogic.gdx.utils.SharedLibraryLoader -> com.badlogic.gdx.utils.l0:
    boolean isIos -> e
    boolean isAndroid -> f
    boolean isARM -> g
    java.lang.String nativesJar -> a
    boolean is64Bit -> h
    boolean isWindows -> b
    boolean isLinux -> c
    boolean isMac -> d
    java.util.HashSet loadedLibraries -> i
    java.lang.String crc(java.io.InputStream) -> a
    java.io.File extractFile(java.lang.String,java.lang.String,java.io.File) -> a
    void load(java.lang.String) -> a
    java.lang.Throwable loadFile(java.lang.String,java.lang.String,java.io.File) -> b
    java.lang.String mapLibraryName(java.lang.String) -> b
    boolean isLoaded(java.lang.String) -> c
    void loadFile(java.lang.String) -> d
    java.io.InputStream readFile(java.lang.String) -> e
    void setLoaded(java.lang.String) -> f
com.badlogic.gdx.utils.ShortArray -> com.badlogic.gdx.utils.m0:
    short[] items -> a
    int size -> b
    boolean ordered -> c
    void add(short) -> a
    void clear() -> a
    short[] ensureCapacity(int) -> a
    short removeIndex(int) -> b
    short[] toArray() -> b
    short[] resize(int) -> c
com.badlogic.gdx.utils.SnapshotArray -> com.badlogic.gdx.utils.n0:
    java.lang.Object[] snapshot -> e
    int snapshots -> g
    java.lang.Object[] recycled -> f
    void insert(int,java.lang.Object) -> a
    void removeRange(int,int) -> a
    void sort(java.util.Comparator) -> a
    void set(int,java.lang.Object) -> b
    java.lang.Object pop() -> c
    java.lang.Object removeIndex(int) -> c
    boolean removeValue(java.lang.Object,boolean) -> c
    void sort() -> e
    void truncate(int) -> e
    java.lang.Object[] begin() -> f
    void end() -> g
    void modified() -> h
com.badlogic.gdx.utils.Sort -> com.badlogic.gdx.utils.o0:
    com.badlogic.gdx.utils.TimSort timSort -> a
    com.badlogic.gdx.utils.Sort instance -> c
    com.badlogic.gdx.utils.ComparableTimSort comparableTimSort -> b
    com.badlogic.gdx.utils.Sort instance() -> a
    void sort(java.lang.Object[],int,int) -> a
    void sort(java.lang.Object[],java.util.Comparator,int,int) -> a
com.badlogic.gdx.utils.StreamUtils -> com.badlogic.gdx.utils.p0:
    void closeQuietly(java.io.Closeable) -> a
    void copyStream(java.io.InputStream,java.io.OutputStream) -> a
    void copyStream(java.io.InputStream,java.io.OutputStream,byte[]) -> a
    byte[] copyStreamToByteArray(java.io.InputStream,int) -> a
com.badlogic.gdx.utils.StreamUtils$OptimizedByteArrayOutputStream -> com.badlogic.gdx.utils.p0$a:
com.badlogic.gdx.utils.StringBuilder -> com.badlogic.gdx.utils.q0:
    char[] chars -> a
    char[] digits -> c
    int length -> b
    com.badlogic.gdx.utils.StringBuilder append(double) -> a
    com.badlogic.gdx.utils.StringBuilder append(float) -> a
    com.badlogic.gdx.utils.StringBuilder append(int) -> a
    com.badlogic.gdx.utils.StringBuilder append(int,int) -> a
    com.badlogic.gdx.utils.StringBuilder append(int,int,char) -> a
    com.badlogic.gdx.utils.StringBuilder append(long) -> a
    com.badlogic.gdx.utils.StringBuilder append(long,int) -> a
    com.badlogic.gdx.utils.StringBuilder append(long,int,char) -> a
    com.badlogic.gdx.utils.StringBuilder append(com.badlogic.gdx.utils.StringBuilder) -> a
    com.badlogic.gdx.utils.StringBuilder append(java.lang.Object) -> a
    com.badlogic.gdx.utils.StringBuilder append(java.lang.String) -> a
    com.badlogic.gdx.utils.StringBuilder append(boolean) -> a
    com.badlogic.gdx.utils.StringBuilder append(char[]) -> a
    void append0(char) -> a
    void append0(java.lang.CharSequence,int,int) -> a
    void append0(char[],int,int) -> a
    void appendNull() -> a
    int indexOf(java.lang.String,int) -> a
    void insert0(int,java.lang.String) -> a
    com.badlogic.gdx.utils.StringBuilder replace(char,java.lang.String) -> a
    void replace0(int,int,java.lang.String) -> a
    void append0(java.lang.String) -> b
    void append0(char[]) -> b
    void clear() -> b
    int numChars(long,int) -> b
    void setLength(int) -> b
    java.lang.String substring(int,int) -> b
    void enlargeBuffer(int) -> c
    int indexOf(java.lang.String) -> c
    void move(int,int) -> c
    int numChars(int,int) -> d
com.badlogic.gdx.utils.TextFormatter -> com.badlogic.gdx.utils.r0:
com.badlogic.gdx.utils.TimSort -> com.badlogic.gdx.utils.s0:
    java.lang.Object[] tmp -> d
    int[] runBase -> g
    int[] runLen -> h
    int stackSize -> f
    int tmpCount -> e
    int minGallop -> c
    java.util.Comparator c -> b
    void binarySort(java.lang.Object[],int,int,int,java.util.Comparator) -> a
    int countRunAndMakeAscending(java.lang.Object[],int,int,java.util.Comparator) -> a
    void doSort(java.lang.Object[],java.util.Comparator,int,int) -> a
    java.lang.Object[] ensureCapacity(int) -> a
    int gallopLeft(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> a
    void mergeCollapse() -> a
    void mergeHi(int,int,int,int) -> a
    void pushRun(int,int) -> a
    void rangeCheck(int,int,int) -> a
    void reverseRange(java.lang.Object[],int,int) -> a
    int gallopRight(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> b
    void mergeAt(int) -> b
    void mergeForceCollapse() -> b
    void mergeLo(int,int,int,int) -> b
    int minRunLength(int) -> c
com.badlogic.gdx.utils.TimeUtils -> com.badlogic.gdx.utils.t0:
    long millis() -> a
    long nanoTime() -> b
com.badlogic.gdx.utils.Timer -> com.badlogic.gdx.utils.u0:
    com.badlogic.gdx.utils.Timer$TimerThread thread -> c
    com.badlogic.gdx.utils.Array tasks -> a
    java.lang.Object threadLock -> b
    void delay(long) -> a
    com.badlogic.gdx.utils.Timer$Task scheduleTask(com.badlogic.gdx.utils.Timer$Task,float) -> a
    com.badlogic.gdx.utils.Timer$Task scheduleTask(com.badlogic.gdx.utils.Timer$Task,float,float) -> a
    com.badlogic.gdx.utils.Timer$Task scheduleTask(com.badlogic.gdx.utils.Timer$Task,float,float,int) -> a
    void start() -> a
    long update(long,long) -> a
    com.badlogic.gdx.utils.Timer instance() -> b
    com.badlogic.gdx.utils.Timer$Task schedule(com.badlogic.gdx.utils.Timer$Task,float) -> b
    com.badlogic.gdx.utils.Timer$Task schedule(com.badlogic.gdx.utils.Timer$Task,float,float) -> b
    com.badlogic.gdx.utils.Timer$TimerThread thread() -> c
com.badlogic.gdx.utils.Timer$Task -> com.badlogic.gdx.utils.u0$a:
    com.badlogic.gdx.utils.Timer timer -> e
    long executeTimeMillis -> b
    int repeatCount -> d
    com.badlogic.gdx.Application app -> a
    long intervalMillis -> c
    void cancel() -> a
    boolean isScheduled() -> b
com.badlogic.gdx.utils.Timer$TimerThread -> com.badlogic.gdx.utils.u0$b:
    com.badlogic.gdx.utils.Timer instance -> d
    long pauseTimeMillis -> e
    com.badlogic.gdx.utils.Array instances -> c
    com.badlogic.gdx.Files files -> a
    com.badlogic.gdx.Application app -> b
    void dispose() -> a
    void pause() -> b
    void resume() -> c
com.badlogic.gdx.utils.UBJsonReader -> com.badlogic.gdx.utils.v0:
    boolean oldFormat -> a
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.DataInputStream) -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.DataInputStream,byte) -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.InputStream) -> a
    long parseSize(java.io.DataInputStream,byte,boolean,long) -> a
    long parseSize(java.io.DataInputStream,boolean,long) -> a
    java.lang.String parseString(java.io.DataInputStream,boolean,byte) -> a
    java.lang.String readString(java.io.DataInputStream,long) -> a
    com.badlogic.gdx.utils.JsonValue parseArray(java.io.DataInputStream) -> b
    com.badlogic.gdx.utils.JsonValue parseData(java.io.DataInputStream,byte) -> b
    com.badlogic.gdx.utils.JsonValue parseObject(java.io.DataInputStream) -> c
    java.lang.String parseString(java.io.DataInputStream,byte) -> c
    short readUChar(java.io.DataInputStream) -> d
    long readUInt(java.io.DataInputStream) -> e
    int readUShort(java.io.DataInputStream) -> f
com.badlogic.gdx.utils.async.AsyncExecutor -> com.badlogic.gdx.utils.w0.a:
    java.util.concurrent.ExecutorService executor -> a
    void dispose() -> a
    com.badlogic.gdx.utils.async.AsyncResult submit(com.badlogic.gdx.utils.async.AsyncTask) -> a
com.badlogic.gdx.utils.async.AsyncExecutor$1 -> com.badlogic.gdx.utils.w0.a$a:
    java.lang.String val$name -> a
com.badlogic.gdx.utils.async.AsyncExecutor$2 -> com.badlogic.gdx.utils.w0.a$b:
    com.badlogic.gdx.utils.async.AsyncTask val$task -> a
com.badlogic.gdx.utils.async.AsyncResult -> com.badlogic.gdx.utils.w0.b:
    java.util.concurrent.Future future -> a
    java.lang.Object get() -> a
    boolean isDone() -> b
com.badlogic.gdx.utils.async.AsyncTask -> com.badlogic.gdx.utils.w0.c:
com.badlogic.gdx.utils.async.ThreadUtils -> com.badlogic.gdx.utils.w0.d:
    void yield() -> a
com.badlogic.gdx.utils.reflect.ArrayReflection -> com.badlogic.gdx.utils.x0.a:
    java.lang.Object newInstance(java.lang.Class,int) -> a
    void set(java.lang.Object,int,java.lang.Object) -> a
com.badlogic.gdx.utils.reflect.ClassReflection -> com.badlogic.gdx.utils.x0.b:
    java.lang.Class forName(java.lang.String) -> a
    com.badlogic.gdx.utils.reflect.Constructor getConstructor(java.lang.Class,java.lang.Class[]) -> a
    com.badlogic.gdx.utils.reflect.Field[] getDeclaredFields(java.lang.Class) -> a
    boolean isAssignableFrom(java.lang.Class,java.lang.Class) -> a
    com.badlogic.gdx.utils.reflect.Constructor getDeclaredConstructor(java.lang.Class,java.lang.Class[]) -> b
    java.lang.String getSimpleName(java.lang.Class) -> b
    boolean isMemberClass(java.lang.Class) -> c
    boolean isStaticClass(java.lang.Class) -> d
    java.lang.Object newInstance(java.lang.Class) -> e
com.badlogic.gdx.utils.reflect.Constructor -> com.badlogic.gdx.utils.x0.c:
    java.lang.reflect.Constructor constructor -> a
    java.lang.Class getDeclaringClass() -> a
    java.lang.Object newInstance(java.lang.Object[]) -> a
    void setAccessible(boolean) -> a
com.badlogic.gdx.utils.reflect.Field -> com.badlogic.gdx.utils.x0.d:
    java.lang.reflect.Field field -> a
    java.lang.Object get(java.lang.Object) -> a
    java.lang.Class getDeclaringClass() -> a
    java.lang.Class getElementType(int) -> a
    boolean isAnnotationPresent(java.lang.Class) -> a
    void set(java.lang.Object,java.lang.Object) -> a
    void setAccessible(boolean) -> a
    java.lang.String getName() -> b
    java.lang.Class getType() -> c
    boolean isAccessible() -> d
    boolean isStatic() -> e
    boolean isSynthetic() -> f
    boolean isTransient() -> g
com.badlogic.gdx.utils.reflect.ReflectionException -> com.badlogic.gdx.utils.x0.e:
com.badlogic.gdx.utils.viewport.ScalingViewport -> com.badlogic.gdx.utils.y0.a:
    com.badlogic.gdx.utils.Scaling scaling -> i
    void update(int,int,boolean) -> a
com.badlogic.gdx.utils.viewport.Viewport -> com.badlogic.gdx.utils.y0.b:
    com.badlogic.gdx.graphics.Camera camera -> a
    int screenWidth -> f
    float worldHeight -> c
    int screenHeight -> g
    float worldWidth -> b
    int screenX -> d
    int screenY -> e
    com.badlogic.gdx.math.Vector3 tmp -> h
    void apply(boolean) -> a
    void calculateScissors(com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.graphics.Camera getCamera() -> a
    void setCamera(com.badlogic.gdx.graphics.Camera) -> a
    void setScreenBounds(int,int,int,int) -> a
    void setWorldSize(float,float) -> a
    com.badlogic.gdx.math.Vector2 unproject(com.badlogic.gdx.math.Vector2) -> a
    void update(int,int) -> a
    void update(int,int,boolean) -> a
    int getScreenHeight() -> b
    int getScreenWidth() -> c
    int getScreenX() -> d
    int getScreenY() -> e
    float getWorldHeight() -> f
    float getWorldWidth() -> g
com.google.android.gms.auth.api.signin.GoogleSignInAccount -> com.google.android.gms.auth.api.signin.GoogleSignInAccount:
    java.lang.String zaj -> g
    android.net.Uri zai -> f
    java.lang.String zal -> i
    java.lang.String zan -> k
    long zak -> h
    java.lang.String zao -> l
    int versionCode -> a
    com.google.android.gms.common.util.Clock zae -> n
    java.util.List zam -> j
    java.lang.String zaf -> c
    java.lang.String mId -> b
    java.lang.String zah -> e
    java.util.Set zap -> m
    java.lang.String zag -> d
    com.google.android.gms.auth.api.signin.GoogleSignInAccount zaa(java.lang.String) -> a
    com.google.android.gms.auth.api.signin.GoogleSignInAccount zaa(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.net.Uri,java.lang.Long,java.lang.String,java.util.Set) -> a
    android.accounts.Account getAccount() -> b
    java.lang.String getDisplayName() -> c
    java.lang.String getEmail() -> d
    java.lang.String getFamilyName() -> e
    java.lang.String getGivenName() -> f
    java.lang.String getId() -> g
    java.lang.String getIdToken() -> h
    android.net.Uri getPhotoUrl() -> i
    java.util.Set getRequestedScopes() -> j
    java.lang.String getServerAuthCode() -> k
com.google.android.gms.auth.api.signin.internal.Storage -> com.google.android.gms.auth.api.signin.a.a:
    android.content.SharedPreferences zaam -> b
    com.google.android.gms.auth.api.signin.internal.Storage zaak -> d
    java.util.concurrent.locks.Lock zaal -> a
    java.util.concurrent.locks.Lock zaaj -> c
    com.google.android.gms.auth.api.signin.internal.Storage getInstance(android.content.Context) -> a
    com.google.android.gms.auth.api.signin.GoogleSignInAccount getSavedDefaultGoogleSignInAccount() -> a
    java.lang.String zab(java.lang.String,java.lang.String) -> a
    com.google.android.gms.auth.api.signin.GoogleSignInAccount zad(java.lang.String) -> a
    java.lang.String zaf(java.lang.String) -> b
com.google.android.gms.auth.api.signin.zab -> com.google.android.gms.auth.api.signin.b:
com.google.android.gms.base.R$drawable -> b.b.a.a.a.a:
com.google.android.gms.base.R$string -> b.b.a.a.a.b:
com.google.android.gms.common.ConnectionResult -> b.b.a.a.b.a:
    com.google.android.gms.common.ConnectionResult RESULT_SUCCESS -> e
    android.app.PendingIntent zzi -> c
    int zzh -> b
    int zzg -> a
    java.lang.String zzj -> d
    java.lang.String zza(int) -> a
    int getErrorCode() -> b
    java.lang.String getErrorMessage() -> c
    android.app.PendingIntent getResolution() -> d
    boolean hasResolution() -> e
    boolean isSuccess() -> f
com.google.android.gms.common.ErrorDialogFragment -> b.b.a.a.b.b:
    android.content.DialogInterface$OnCancelListener zaan -> b
    android.app.Dialog mDialog -> a
    com.google.android.gms.common.ErrorDialogFragment newInstance(android.app.Dialog,android.content.DialogInterface$OnCancelListener) -> a
com.google.android.gms.common.Feature -> b.b.a.a.b.c:
    java.lang.String name -> a
    long zzl -> c
    int zzk -> b
    java.lang.String getName() -> b
    long getVersion() -> c
com.google.android.gms.common.GoogleApiAvailability -> b.b.a.a.b.d:
    com.google.android.gms.common.GoogleApiAvailability zaao -> d
    java.lang.Object mLock -> c
    java.lang.String zaap -> b
    android.app.Dialog getErrorDialog(android.app.Activity,int,int,android.content.DialogInterface$OnCancelListener) -> a
    android.content.Intent getErrorResolutionIntent(android.content.Context,int,java.lang.String) -> a
    android.app.PendingIntent getErrorResolutionPendingIntent(android.content.Context,int,int) -> a
    android.app.PendingIntent getErrorResolutionPendingIntent(android.content.Context,com.google.android.gms.common.ConnectionResult) -> a
    java.lang.String getErrorString(int) -> a
    com.google.android.gms.common.GoogleApiAvailability getInstance() -> a
    int isGooglePlayServicesAvailable(android.content.Context) -> a
    int isGooglePlayServicesAvailable(android.content.Context,int) -> a
    android.app.Dialog zaa(android.content.Context,int,com.google.android.gms.common.internal.DialogRedirect,android.content.DialogInterface$OnCancelListener) -> a
    void zaa(android.app.Activity,android.app.Dialog,java.lang.String,android.content.DialogInterface$OnCancelListener) -> a
    void zaa(android.content.Context,int,java.lang.String,android.app.PendingIntent) -> a
    boolean zaa(android.content.Context,com.google.android.gms.common.ConnectionResult,int) -> a
    boolean isUserResolvableError(int) -> b
    boolean showErrorDialogFragment(android.app.Activity,int,int,android.content.DialogInterface$OnCancelListener) -> b
    void showErrorNotification(android.content.Context,int) -> b
    void zaa(android.content.Context) -> b
    java.lang.String zag() -> b
com.google.android.gms.common.GoogleApiAvailability$zaa -> b.b.a.a.b.d$a:
    android.content.Context zaaq -> a
    com.google.android.gms.common.GoogleApiAvailability zaar -> b
com.google.android.gms.common.GoogleApiAvailabilityLight -> b.b.a.a.b.e:
    int GOOGLE_PLAY_SERVICES_VERSION_CODE -> a
    android.content.Intent getErrorResolutionIntent(android.content.Context,int,java.lang.String) -> a
    android.app.PendingIntent getErrorResolutionPendingIntent(android.content.Context,int,int) -> a
    android.app.PendingIntent getErrorResolutionPendingIntent(android.content.Context,int,int,java.lang.String) -> a
    java.lang.String getErrorString(int) -> a
    int isGooglePlayServicesAvailable(android.content.Context) -> a
    int isGooglePlayServicesAvailable(android.content.Context,int) -> a
    java.lang.String zza(android.content.Context,java.lang.String) -> a
    boolean isUserResolvableError(int) -> b
com.google.android.gms.common.GooglePlayServicesUtil -> b.b.a.a.b.f:
    android.content.res.Resources getRemoteResource(android.content.Context) -> a
com.google.android.gms.common.GooglePlayServicesUtilLight -> b.b.a.a.b.g:
    java.util.concurrent.atomic.AtomicBoolean zzak -> c
    java.util.concurrent.atomic.AtomicBoolean sCanceledAvailabilityNotification -> b
    int GOOGLE_PLAY_SERVICES_VERSION_CODE -> a
    java.lang.String getErrorString(int) -> a
    android.content.res.Resources getRemoteResource(android.content.Context) -> a
    int isGooglePlayServicesAvailable(android.content.Context,int) -> a
    boolean isUninstalledAppPossiblyUpdating(android.content.Context,java.lang.String) -> a
    int zza(android.content.Context,boolean,int) -> a
    boolean isPlayServicesPossiblyUpdating(android.content.Context,int) -> b
    boolean isRestrictedUserProfile(android.content.Context) -> b
    boolean isUserRecoverableError(int) -> b
com.google.android.gms.common.GoogleSignatureVerifier -> b.b.a.a.b.h:
    com.google.android.gms.common.GoogleSignatureVerifier zzal -> a
    com.google.android.gms.common.GoogleSignatureVerifier getInstance(android.content.Context) -> a
    com.google.android.gms.common.zze zza(android.content.pm.PackageInfo,com.google.android.gms.common.zze[]) -> a
    boolean zza(android.content.pm.PackageInfo,boolean) -> a
com.google.android.gms.common.R$string -> b.b.a.a.b.i:
com.google.android.gms.common.SupportErrorDialogFragment -> b.b.a.a.b.j:
    android.app.Dialog mDialog -> f0
    android.content.DialogInterface$OnCancelListener zaan -> g0
    com.google.android.gms.common.SupportErrorDialogFragment newInstance(android.app.Dialog,android.content.DialogInterface$OnCancelListener) -> a
    void show(android.support.v4.app.FragmentManager,java.lang.String) -> a
    android.app.Dialog onCreateDialog(android.os.Bundle) -> n
com.google.android.gms.common.api.Api -> com.google.android.gms.common.api.a:
    com.google.android.gms.common.api.Api$AbstractClientBuilder zaau -> a
    java.lang.String mName -> b
    java.lang.String getName() -> a
    com.google.android.gms.common.api.Api$AbstractClientBuilder zai() -> b
com.google.android.gms.common.api.Api$AbstractClientBuilder -> com.google.android.gms.common.api.a$a:
    com.google.android.gms.common.api.Api$Client buildClient(android.content.Context,android.os.Looper,com.google.android.gms.common.internal.ClientSettings,java.lang.Object,com.google.android.gms.common.api.GoogleApiClient$ConnectionCallbacks,com.google.android.gms.common.api.GoogleApiClient$OnConnectionFailedListener) -> a
com.google.android.gms.common.api.Api$AnyClient -> com.google.android.gms.common.api.a$b:
com.google.android.gms.common.api.Api$AnyClientKey -> com.google.android.gms.common.api.a$c:
com.google.android.gms.common.api.Api$ApiOptions -> com.google.android.gms.common.api.a$d:
com.google.android.gms.common.api.Api$ApiOptions$HasAccountOptions -> com.google.android.gms.common.api.a$d$a:
    android.accounts.Account getAccount() -> a
com.google.android.gms.common.api.Api$ApiOptions$HasGoogleSignInAccountOptions -> com.google.android.gms.common.api.a$d$b:
    com.google.android.gms.auth.api.signin.GoogleSignInAccount getGoogleSignInAccount() -> b
com.google.android.gms.common.api.Api$ApiOptions$HasOptions -> com.google.android.gms.common.api.a$d$c:
com.google.android.gms.common.api.Api$ApiOptions$NotRequiredOptions -> com.google.android.gms.common.api.a$d$d:
com.google.android.gms.common.api.Api$ApiOptions$Optional -> com.google.android.gms.common.api.a$d$e:
com.google.android.gms.common.api.Api$BaseClientBuilder -> com.google.android.gms.common.api.a$e:
com.google.android.gms.common.api.Api$Client -> com.google.android.gms.common.api.a$f:
    void connect(com.google.android.gms.common.internal.BaseGmsClient$ConnectionProgressReportCallbacks) -> a
    void getRemoteService(com.google.android.gms.common.internal.IAccountAccessor,java.util.Set) -> a
    boolean isConnecting() -> a
    void onUserSignOut(com.google.android.gms.common.internal.BaseGmsClient$SignOutCallbacks) -> a
    com.google.android.gms.common.Feature[] getAvailableFeatures() -> b
    boolean isConnected() -> c
    void disconnect() -> d
    java.lang.String getEndpointPackageName() -> f
    boolean requiresSignIn() -> g
    boolean requiresGooglePlayServices() -> h
    int getMinApkVersion() -> i
com.google.android.gms.common.api.Api$ClientKey -> com.google.android.gms.common.api.a$g:
com.google.android.gms.common.api.Api$SimpleClient -> com.google.android.gms.common.api.a$h:
    android.os.IInterface createServiceInterface(android.os.IBinder) -> a
    void setState(int,android.os.IInterface) -> a
    java.lang.String getStartServiceAction() -> j
    java.lang.String getServiceDescriptor() -> k
com.google.android.gms.common.api.ApiException -> com.google.android.gms.common.api.b:
com.google.android.gms.common.api.AvailabilityException -> com.google.android.gms.common.api.c:
    android.support.v4.util.ArrayMap zaay -> a
com.google.android.gms.common.api.CommonStatusCodes -> com.google.android.gms.common.api.d:
    java.lang.String getStatusCodeString(int) -> a
com.google.android.gms.common.api.GoogleApi -> com.google.android.gms.common.api.e:
    android.content.Context mContext -> a
    com.google.android.gms.common.api.internal.zai zabi -> d
    int mId -> e
    com.google.android.gms.common.api.Api$ApiOptions zabh -> c
    com.google.android.gms.common.api.Api mApi -> b
    com.google.android.gms.common.internal.ClientSettings$Builder createClientSettingsBuilder() -> a
    com.google.android.gms.common.api.Api$Client zaa(android.os.Looper,com.google.android.gms.common.api.internal.GoogleApiManager$zaa) -> a
    com.google.android.gms.common.api.internal.zace zaa(android.content.Context,android.os.Handler) -> a
    int getInstanceId() -> b
    com.google.android.gms.common.api.internal.zai zak() -> c
com.google.android.gms.common.api.GoogleApiActivity -> com.google.android.gms.common.api.GoogleApiActivity:
    int zabp -> a
    android.app.PendingIntent zaa(android.content.Context,android.app.PendingIntent,int) -> a
    android.content.Intent zaa(android.content.Context,android.app.PendingIntent,int,boolean) -> a
com.google.android.gms.common.api.GoogleApiClient$ConnectionCallbacks -> com.google.android.gms.common.api.f:
    void onConnected(android.os.Bundle) -> b
    void onConnectionSuspended(int) -> c
com.google.android.gms.common.api.GoogleApiClient$OnConnectionFailedListener -> com.google.android.gms.common.api.g:
    void onConnectionFailed(com.google.android.gms.common.ConnectionResult) -> a
com.google.android.gms.common.api.PendingResult -> com.google.android.gms.common.api.h:
com.google.android.gms.common.api.PendingResult$StatusListener -> com.google.android.gms.common.api.h$a:
    void onComplete(com.google.android.gms.common.api.Status) -> a
com.google.android.gms.common.api.Releasable -> com.google.android.gms.common.api.i:
    void release() -> a
com.google.android.gms.common.api.Result -> com.google.android.gms.common.api.j:
    com.google.android.gms.common.api.Status getStatus() -> a
com.google.android.gms.common.api.ResultCallback -> com.google.android.gms.common.api.k:
    void onResult(com.google.android.gms.common.api.Result) -> a
com.google.android.gms.common.api.Scope -> com.google.android.gms.common.api.Scope:
    java.lang.String zzap -> b
    int zzg -> a
    java.lang.String getScopeUri() -> b
com.google.android.gms.common.api.Status -> com.google.android.gms.common.api.Status:
    com.google.android.gms.common.api.Status RESULT_SUCCESS -> e
    com.google.android.gms.common.api.Status RESULT_CANCELED -> g
    com.google.android.gms.common.api.Status RESULT_TIMEOUT -> f
    int zzh -> b
    java.lang.String zzj -> c
    int zzg -> a
    android.app.PendingIntent zzi -> d
    com.google.android.gms.common.api.Status getStatus() -> a
    int getStatusCode() -> b
    java.lang.String getStatusMessage() -> c
    java.lang.String zzg() -> d
com.google.android.gms.common.api.UnsupportedApiCallException -> com.google.android.gms.common.api.l:
    com.google.android.gms.common.Feature zzar -> a
com.google.android.gms.common.api.internal.BackgroundDetector -> com.google.android.gms.common.api.internal.a:
    java.util.concurrent.atomic.AtomicBoolean zzau -> b
    java.util.concurrent.atomic.AtomicBoolean zzat -> a
    com.google.android.gms.common.api.internal.BackgroundDetector zzas -> e
    java.util.ArrayList zzav -> c
    boolean zzaw -> d
    void addListener(com.google.android.gms.common.api.internal.BackgroundDetector$BackgroundStateChangeListener) -> a
    void initialize(android.app.Application) -> a
    boolean isInBackground() -> a
    boolean readCurrentStateIfPossible(boolean) -> a
    com.google.android.gms.common.api.internal.BackgroundDetector getInstance() -> b
    void onBackgroundStateChanged(boolean) -> b
com.google.android.gms.common.api.internal.BackgroundDetector$BackgroundStateChangeListener -> com.google.android.gms.common.api.internal.a$a:
    void onBackgroundStateChanged(boolean) -> a
com.google.android.gms.common.api.internal.BasePendingResult -> com.google.android.gms.common.api.internal.BasePendingResult:
    boolean zadu -> i
    com.google.android.gms.common.api.Status mStatus -> h
    boolean zadv -> j
    boolean zadw -> k
    java.util.concurrent.atomic.AtomicReference zadt -> f
    com.google.android.gms.common.api.Result zaci -> g
    java.lang.Object zadn -> a
    java.util.ArrayList zadr -> d
    java.util.concurrent.CountDownLatch zadq -> c
    com.google.android.gms.common.api.internal.BasePendingResult$CallbackHandler zado -> b
    com.google.android.gms.common.api.ResultCallback zads -> e
    com.google.android.gms.common.api.Result createFailedResult(com.google.android.gms.common.api.Status) -> a
    boolean isReady() -> a
    void setResult(com.google.android.gms.common.api.Result) -> a
    com.google.android.gms.common.api.Result zaa(com.google.android.gms.common.api.internal.BasePendingResult) -> a
    com.google.android.gms.common.api.Result get() -> b
    void zaa(com.google.android.gms.common.api.Result) -> b
    void zab(com.google.android.gms.common.api.Status) -> b
    void zab(com.google.android.gms.common.api.Result) -> c
com.google.android.gms.common.api.internal.BasePendingResult$CallbackHandler -> com.google.android.gms.common.api.internal.BasePendingResult$a:
    void zaa(com.google.android.gms.common.api.ResultCallback,com.google.android.gms.common.api.Result) -> a
com.google.android.gms.common.api.internal.BasePendingResult$zaa -> com.google.android.gms.common.api.internal.BasePendingResult$b:
    com.google.android.gms.common.api.internal.BasePendingResult zaea -> a
com.google.android.gms.common.api.internal.GoogleApiManager -> com.google.android.gms.common.api.internal.b:
    com.google.android.gms.common.GoogleApiAvailability zaid -> e
    com.google.android.gms.common.api.Status zahw -> m
    long zahz -> b
    long zahy -> a
    long zaia -> c
    java.lang.Object lock -> o
    android.content.Context zaic -> d
    com.google.android.gms.common.api.Status zahx -> n
    com.google.android.gms.common.api.internal.zaae zaii -> i
    java.util.concurrent.atomic.AtomicInteger zaig -> g
    java.util.Set zaij -> j
    com.google.android.gms.common.internal.GoogleApiAvailabilityCache zaie -> f
    com.google.android.gms.common.api.internal.GoogleApiManager zaib -> p
    android.os.Handler handler -> l
    java.util.Set zaik -> k
    java.util.Map zaih -> h
    android.os.Handler zaa(com.google.android.gms.common.api.internal.GoogleApiManager) -> a
    void zaa(com.google.android.gms.common.ConnectionResult,int) -> a
    com.google.android.gms.common.api.internal.GoogleApiManager zab(android.content.Context) -> a
    void zab(com.google.android.gms.common.api.GoogleApi) -> a
    void zao() -> a
    android.content.Context zab(com.google.android.gms.common.api.internal.GoogleApiManager) -> b
    java.lang.Object zabe() -> b
    boolean zac(com.google.android.gms.common.ConnectionResult,int) -> b
    com.google.android.gms.common.api.Status zabf() -> c
    long zac(com.google.android.gms.common.api.internal.GoogleApiManager) -> c
    long zad(com.google.android.gms.common.api.internal.GoogleApiManager) -> d
    com.google.android.gms.common.internal.GoogleApiAvailabilityCache zae(com.google.android.gms.common.api.internal.GoogleApiManager) -> e
    com.google.android.gms.common.api.internal.zaae zaf(com.google.android.gms.common.api.internal.GoogleApiManager) -> f
    java.util.Set zag(com.google.android.gms.common.api.internal.GoogleApiManager) -> g
    com.google.android.gms.common.GoogleApiAvailability zah(com.google.android.gms.common.api.internal.GoogleApiManager) -> h
    long zai(com.google.android.gms.common.api.internal.GoogleApiManager) -> i
    java.util.Map zaj(com.google.android.gms.common.api.internal.GoogleApiManager) -> j
com.google.android.gms.common.api.internal.GoogleApiManager$zaa -> com.google.android.gms.common.api.internal.b$a:
    com.google.android.gms.common.api.Api$Client zain -> b
    boolean zaiu -> j
    com.google.android.gms.common.api.internal.zai zafp -> d
    int zais -> h
    com.google.android.gms.common.api.internal.GoogleApiManager zail -> m
    com.google.android.gms.common.api.internal.zace zait -> i
    com.google.android.gms.common.api.internal.zaab zaip -> e
    java.util.Set zaiq -> f
    java.util.Queue zaim -> a
    java.util.Map zair -> g
    com.google.android.gms.common.api.Api$AnyClient zaio -> c
    java.util.List zaiv -> k
    com.google.android.gms.common.ConnectionResult zaiw -> l
    void connect() -> a
    void onConnectionFailed(com.google.android.gms.common.ConnectionResult) -> a
    com.google.android.gms.common.Feature zaa(com.google.android.gms.common.Feature[]) -> a
    void zaa(com.google.android.gms.common.api.internal.GoogleApiManager$zaa,com.google.android.gms.common.api.internal.GoogleApiManager$zab) -> a
    void zaa(com.google.android.gms.common.api.internal.GoogleApiManager$zab) -> a
    void zaa(com.google.android.gms.common.api.internal.zab) -> a
    void zaa(com.google.android.gms.common.api.internal.zak) -> a
    boolean zaa(com.google.android.gms.common.api.internal.GoogleApiManager$zaa,boolean) -> a
    void zac(com.google.android.gms.common.api.Status) -> a
    boolean zac(boolean) -> a
    void zae(com.google.android.gms.common.api.internal.GoogleApiManager$zaa) -> a
    int getInstanceId() -> b
    void onConnected(android.os.Bundle) -> b
    void zab(com.google.android.gms.common.api.internal.GoogleApiManager$zaa,com.google.android.gms.common.api.internal.GoogleApiManager$zab) -> b
    void zab(com.google.android.gms.common.api.internal.GoogleApiManager$zab) -> b
    boolean zab(com.google.android.gms.common.api.internal.zab) -> b
    void zaf(com.google.android.gms.common.api.internal.GoogleApiManager$zaa) -> b
    void zag(com.google.android.gms.common.ConnectionResult) -> b
    boolean isConnected() -> c
    void onConnectionSuspended(int) -> c
    void zac(com.google.android.gms.common.api.internal.zab) -> c
    com.google.android.gms.common.api.Api$Client zag(com.google.android.gms.common.api.internal.GoogleApiManager$zaa) -> c
    boolean zah(com.google.android.gms.common.ConnectionResult) -> c
    boolean requiresSignIn() -> d
    void zai(com.google.android.gms.common.ConnectionResult) -> d
    void resume() -> e
    com.google.android.gms.common.api.Api$Client zaab() -> f
    void zaav() -> g
    void zabj() -> h
    java.util.Map zabk() -> i
    void zabl() -> j
    com.google.android.gms.common.ConnectionResult zabm() -> k
    boolean zabp() -> l
    void zabg() -> m
    void zabh() -> n
    void zabi() -> o
    void zabn() -> p
    void zabo() -> q
com.google.android.gms.common.api.internal.GoogleApiManager$zab -> com.google.android.gms.common.api.internal.b$b:
    com.google.android.gms.common.Feature zajb -> b
    com.google.android.gms.common.api.internal.zai zaja -> a
    com.google.android.gms.common.api.internal.zai zac(com.google.android.gms.common.api.internal.GoogleApiManager$zab) -> a
    com.google.android.gms.common.Feature zad(com.google.android.gms.common.api.internal.GoogleApiManager$zab) -> b
com.google.android.gms.common.api.internal.GoogleApiManager$zac -> com.google.android.gms.common.api.internal.b$c:
    com.google.android.gms.common.api.Api$Client zain -> a
    com.google.android.gms.common.api.internal.zai zafp -> b
    java.util.Set zajd -> d
    com.google.android.gms.common.internal.IAccountAccessor zajc -> c
    boolean zaje -> e
    com.google.android.gms.common.api.internal.GoogleApiManager zail -> f
    void onReportServiceBinding(com.google.android.gms.common.ConnectionResult) -> a
    com.google.android.gms.common.api.Api$Client zaa(com.google.android.gms.common.api.internal.GoogleApiManager$zac) -> a
    void zaa(com.google.android.gms.common.internal.IAccountAccessor,java.util.Set) -> a
    boolean zaa(com.google.android.gms.common.api.internal.GoogleApiManager$zac,boolean) -> a
    void zabr() -> a
    void zab(com.google.android.gms.common.api.internal.GoogleApiManager$zac) -> b
    void zag(com.google.android.gms.common.ConnectionResult) -> b
    com.google.android.gms.common.api.internal.zai zac(com.google.android.gms.common.api.internal.GoogleApiManager$zac) -> c
com.google.android.gms.common.api.internal.LifecycleActivity -> com.google.android.gms.common.api.internal.c:
com.google.android.gms.common.api.internal.LifecycleFragment -> com.google.android.gms.common.api.internal.d:
com.google.android.gms.common.api.internal.ListenerHolder$ListenerKey -> com.google.android.gms.common.api.internal.e:
    java.lang.Object zajj -> a
    java.lang.String zajm -> b
com.google.android.gms.common.api.internal.RegisterListenerMethod -> com.google.android.gms.common.api.internal.f:
    void clearListener() -> a
    void registerListener(com.google.android.gms.common.api.Api$AnyClient,com.google.android.gms.tasks.TaskCompletionSource) -> a
    com.google.android.gms.common.Feature[] getRequiredFeatures() -> b
    boolean shouldAutoResolveMissingFeatures() -> c
com.google.android.gms.common.api.internal.UnregisterListenerMethod -> com.google.android.gms.common.api.internal.g:
    void unregisterListener(com.google.android.gms.common.api.Api$AnyClient,com.google.android.gms.tasks.TaskCompletionSource) -> a
com.google.android.gms.common.api.internal.zaab -> com.google.android.gms.common.api.internal.h:
    java.util.Map zafj -> a
    java.util.Map zafk -> b
    void zaa(boolean,com.google.android.gms.common.api.Status) -> a
    boolean zaag() -> a
    void zaah() -> b
    void zaai() -> c
com.google.android.gms.common.api.internal.zaae -> com.google.android.gms.common.api.internal.i:
com.google.android.gms.common.api.internal.zaaf -> com.google.android.gms.common.api.internal.j:
    com.google.android.gms.common.api.internal.zai zafp -> a
    com.google.android.gms.tasks.TaskCompletionSource zafq -> b
    com.google.android.gms.tasks.TaskCompletionSource zaal() -> a
    com.google.android.gms.common.api.internal.zai zak() -> b
com.google.android.gms.common.api.internal.zab -> com.google.android.gms.common.api.internal.k:
    com.google.android.gms.common.api.Status zaa(android.os.RemoteException) -> a
    void zaa(com.google.android.gms.common.api.Status) -> a
    void zaa(com.google.android.gms.common.api.internal.GoogleApiManager$zaa) -> a
    void zaa(com.google.android.gms.common.api.internal.zaab,boolean) -> a
    void zaa(java.lang.RuntimeException) -> a
    com.google.android.gms.common.api.Status zab(android.os.RemoteException) -> b
com.google.android.gms.common.api.internal.zabi -> com.google.android.gms.common.api.internal.l:
    com.google.android.gms.common.api.internal.GoogleApiManager zail -> a
    void onBackgroundStateChanged(boolean) -> a
com.google.android.gms.common.api.internal.zabj -> com.google.android.gms.common.api.internal.m:
    com.google.android.gms.common.api.internal.GoogleApiManager$zaa zaix -> a
com.google.android.gms.common.api.internal.zabk -> com.google.android.gms.common.api.internal.n:
    com.google.android.gms.common.api.internal.GoogleApiManager$zaa zaix -> a
com.google.android.gms.common.api.internal.zabm -> com.google.android.gms.common.api.internal.o:
    com.google.android.gms.common.api.internal.GoogleApiManager$zaa zaix -> a
    void onSignOutComplete() -> a
com.google.android.gms.common.api.internal.zabn -> com.google.android.gms.common.api.internal.p:
    com.google.android.gms.common.api.internal.zabm zaiz -> a
com.google.android.gms.common.api.internal.zabo -> com.google.android.gms.common.api.internal.q:
    com.google.android.gms.common.ConnectionResult zaiy -> a
    com.google.android.gms.common.api.internal.GoogleApiManager$zac zajf -> b
com.google.android.gms.common.api.internal.zabv -> com.google.android.gms.common.api.internal.r:
    com.google.android.gms.common.api.internal.zab zajq -> a
    com.google.android.gms.common.api.GoogleApi zajs -> c
    int zajr -> b
com.google.android.gms.common.api.internal.zabw -> com.google.android.gms.common.api.internal.s:
    com.google.android.gms.common.api.internal.UnregisterListenerMethod zajx -> b
    com.google.android.gms.common.api.internal.RegisterListenerMethod zajw -> a
com.google.android.gms.common.api.internal.zac -> com.google.android.gms.common.api.internal.t:
    com.google.android.gms.common.Feature[] zab(com.google.android.gms.common.api.internal.GoogleApiManager$zaa) -> b
    boolean zac(com.google.android.gms.common.api.internal.GoogleApiManager$zaa) -> c
com.google.android.gms.common.api.internal.zace -> com.google.android.gms.common.api.internal.u:
    android.content.Context mContext -> a
    com.google.android.gms.common.api.Api$AbstractClientBuilder zakh -> h
    android.os.Handler mHandler -> b
    java.util.Set mScopes -> d
    com.google.android.gms.signin.zad zaga -> f
    com.google.android.gms.common.internal.ClientSettings zaes -> e
    com.google.android.gms.common.api.Api$AbstractClientBuilder zaau -> c
    com.google.android.gms.common.api.internal.zach zaki -> g
    void onConnectionFailed(com.google.android.gms.common.ConnectionResult) -> a
    com.google.android.gms.common.api.internal.zach zaa(com.google.android.gms.common.api.internal.zace) -> a
    void zaa(com.google.android.gms.common.api.internal.zace,com.google.android.gms.signin.internal.zaj) -> a
    void zaa(com.google.android.gms.common.api.internal.zach) -> a
    void zab(com.google.android.gms.signin.internal.zaj) -> a
    void onConnected(android.os.Bundle) -> b
    void zac(com.google.android.gms.signin.internal.zaj) -> b
    void onConnectionSuspended(int) -> c
    void zabs() -> e
com.google.android.gms.common.api.internal.zacf -> com.google.android.gms.common.api.internal.v:
    com.google.android.gms.common.api.internal.zace zakj -> a
com.google.android.gms.common.api.internal.zacg -> com.google.android.gms.common.api.internal.w:
    com.google.android.gms.signin.internal.zaj zagq -> a
    com.google.android.gms.common.api.internal.zace zakj -> b
com.google.android.gms.common.api.internal.zach -> com.google.android.gms.common.api.internal.x:
    void zaa(com.google.android.gms.common.internal.IAccountAccessor,java.util.Set) -> a
    void zag(com.google.android.gms.common.ConnectionResult) -> b
com.google.android.gms.common.api.internal.zacp -> com.google.android.gms.common.api.internal.y:
    com.google.android.gms.common.api.Status zakw -> a
com.google.android.gms.common.api.internal.zacs -> com.google.android.gms.common.api.internal.z:
    void zac(com.google.android.gms.common.api.internal.BasePendingResult) -> a
com.google.android.gms.common.api.internal.zad -> com.google.android.gms.common.api.internal.a0:
    com.google.android.gms.tasks.TaskCompletionSource zacm -> a
    void zaa(com.google.android.gms.common.api.Status) -> a
    void zaa(com.google.android.gms.common.api.internal.GoogleApiManager$zaa) -> a
    void zaa(java.lang.RuntimeException) -> a
    void zad(com.google.android.gms.common.api.internal.GoogleApiManager$zaa) -> d
com.google.android.gms.common.api.internal.zah -> com.google.android.gms.common.api.internal.b0:
    com.google.android.gms.common.api.internal.ListenerHolder$ListenerKey zacs -> b
    void zaa(com.google.android.gms.common.api.Status) -> a
    void zaa(com.google.android.gms.common.api.internal.zaab,boolean) -> a
    void zaa(java.lang.RuntimeException) -> a
    com.google.android.gms.common.Feature[] zab(com.google.android.gms.common.api.internal.GoogleApiManager$zaa) -> b
    boolean zac(com.google.android.gms.common.api.internal.GoogleApiManager$zaa) -> c
    void zad(com.google.android.gms.common.api.internal.GoogleApiManager$zaa) -> d
com.google.android.gms.common.api.internal.zai -> com.google.android.gms.common.api.internal.c0:
    boolean zact -> a
    int zacu -> b
    com.google.android.gms.common.api.Api mApi -> c
    com.google.android.gms.common.api.Api$ApiOptions zabh -> d
    java.lang.String zan() -> a
com.google.android.gms.common.api.internal.zak -> com.google.android.gms.common.api.internal.d0:
    android.support.v4.util.ArrayMap zada -> b
    android.support.v4.util.ArrayMap zaay -> a
    boolean zadd -> e
    int zadc -> d
    com.google.android.gms.tasks.TaskCompletionSource zadb -> c
    void zaa(com.google.android.gms.common.api.internal.zai,com.google.android.gms.common.ConnectionResult,java.lang.String) -> a
    java.util.Set zap() -> a
com.google.android.gms.common.api.internal.zal -> com.google.android.gms.common.api.internal.e0:
    void zab(com.google.android.gms.common.ConnectionResult,int) -> a
com.google.android.gms.common.api.internal.zap -> com.google.android.gms.common.api.internal.f0:
com.google.android.gms.common.api.internal.zar -> com.google.android.gms.common.api.internal.g0:
com.google.android.gms.common.api.zza -> com.google.android.gms.common.api.m:
com.google.android.gms.common.api.zzb -> com.google.android.gms.common.api.n:
com.google.android.gms.common.internal.AccountAccessor -> com.google.android.gms.common.internal.a:
    android.accounts.Account getAccountBinderSafe(com.google.android.gms.common.internal.IAccountAccessor) -> a
com.google.android.gms.common.internal.BaseGmsClient -> com.google.android.gms.common.internal.b:
    int zzcl -> o
    java.util.concurrent.atomic.AtomicInteger zzcq -> t
    com.google.android.gms.common.Feature[] zzbs -> u
    int zzci -> l
    android.content.Context mContext -> b
    com.google.android.gms.common.internal.zzb zzcp -> s
    java.lang.Object zzcc -> f
    com.google.android.gms.common.internal.GmsClientSupervisor zzca -> c
    java.lang.Object mLock -> e
    com.google.android.gms.common.internal.BaseGmsClient$ConnectionProgressReportCallbacks zzce -> h
    com.google.android.gms.common.internal.zzh zzby -> a
    java.lang.String zzcm -> p
    com.google.android.gms.common.internal.IGmsServiceBroker zzcd -> g
    boolean zzco -> r
    android.os.IInterface zzcf -> i
    com.google.android.gms.common.ConnectionResult zzcn -> q
    android.os.Handler mHandler -> d
    java.util.ArrayList zzcg -> j
    com.google.android.gms.common.internal.BaseGmsClient$BaseConnectionCallbacks zzcj -> m
    com.google.android.gms.common.internal.BaseGmsClient$zze zzch -> k
    com.google.android.gms.common.internal.BaseGmsClient$BaseOnConnectionFailedListener zzck -> n
    void connect(com.google.android.gms.common.internal.BaseGmsClient$ConnectionProgressReportCallbacks) -> a
    android.os.IInterface createServiceInterface(android.os.IBinder) -> a
    void getRemoteService(com.google.android.gms.common.internal.IAccountAccessor,java.util.Set) -> a
    boolean isConnecting() -> a
    void onConnectedLocked(android.os.IInterface) -> a
    void onConnectionFailed(com.google.android.gms.common.ConnectionResult) -> a
    void onConnectionSuspended(int) -> a
    void onPostInitHandler(int,android.os.IBinder,android.os.Bundle,int) -> a
    void onSetConnectState(int,android.os.IInterface) -> a
    void onUserSignOut(com.google.android.gms.common.internal.BaseGmsClient$SignOutCallbacks) -> a
    com.google.android.gms.common.ConnectionResult zza(com.google.android.gms.common.internal.BaseGmsClient,com.google.android.gms.common.ConnectionResult) -> a
    com.google.android.gms.common.internal.IGmsServiceBroker zza(com.google.android.gms.common.internal.BaseGmsClient,com.google.android.gms.common.internal.IGmsServiceBroker) -> a
    java.lang.Object zza(com.google.android.gms.common.internal.BaseGmsClient) -> a
    void zza(int,android.os.Bundle,int) -> a
    void zza(com.google.android.gms.common.internal.BaseGmsClient,int) -> a
    void zza(com.google.android.gms.common.internal.BaseGmsClient,int,android.os.IInterface) -> a
    void zza(com.google.android.gms.common.internal.BaseGmsClient,com.google.android.gms.common.internal.zzb) -> a
    void zza(com.google.android.gms.common.internal.zzb) -> a
    boolean zza(int,int,android.os.IInterface) -> a
    boolean zza(com.google.android.gms.common.internal.BaseGmsClient,int,int,android.os.IInterface) -> a
    com.google.android.gms.common.Feature[] getAvailableFeatures() -> b
    void triggerConnectionSuspended(int) -> b
    void zza(int,android.os.IInterface) -> b
    boolean zzb(com.google.android.gms.common.internal.BaseGmsClient) -> b
    boolean isConnected() -> c
    void zzb(int) -> c
    boolean zzc(com.google.android.gms.common.internal.BaseGmsClient) -> c
    void disconnect() -> d
    com.google.android.gms.common.ConnectionResult zzd(com.google.android.gms.common.internal.BaseGmsClient) -> d
    com.google.android.gms.common.internal.BaseGmsClient$BaseConnectionCallbacks zze(com.google.android.gms.common.internal.BaseGmsClient) -> e
    java.lang.String getEndpointPackageName() -> f
    java.util.ArrayList zzf(com.google.android.gms.common.internal.BaseGmsClient) -> f
    boolean requiresSignIn() -> g
    com.google.android.gms.common.internal.BaseGmsClient$BaseOnConnectionFailedListener zzg(com.google.android.gms.common.internal.BaseGmsClient) -> g
    boolean requiresGooglePlayServices() -> h
    int getMinApkVersion() -> i
    void checkConnected() -> j
    android.accounts.Account getAccount() -> k
    com.google.android.gms.common.Feature[] getApiFeatures() -> l
    android.os.Bundle getConnectionHint() -> m
    android.content.Context getContext() -> n
    android.os.Bundle getGetServiceRequestExtraArgs() -> o
    java.lang.String getLocalStartServiceAction() -> p
    java.util.Set getScopes() -> q
    android.os.IInterface getService() -> r
    java.lang.String getServiceDescriptor() -> s
    java.lang.String getStartServiceAction() -> t
    java.lang.String getStartServicePackage() -> u
    boolean requiresAccount() -> v
    java.lang.String zzj() -> w
    boolean zzk() -> x
    boolean zzl() -> y
com.google.android.gms.common.internal.BaseGmsClient$BaseConnectionCallbacks -> com.google.android.gms.common.internal.b$a:
    void onConnected(android.os.Bundle) -> b
    void onConnectionSuspended(int) -> c
com.google.android.gms.common.internal.BaseGmsClient$BaseOnConnectionFailedListener -> com.google.android.gms.common.internal.b$b:
    void onConnectionFailed(com.google.android.gms.common.ConnectionResult) -> a
com.google.android.gms.common.internal.BaseGmsClient$ConnectionProgressReportCallbacks -> com.google.android.gms.common.internal.b$c:
    void onReportServiceBinding(com.google.android.gms.common.ConnectionResult) -> a
com.google.android.gms.common.internal.BaseGmsClient$LegacyClientCallbackAdapter -> com.google.android.gms.common.internal.b$d:
    com.google.android.gms.common.internal.BaseGmsClient zzcs -> a
    void onReportServiceBinding(com.google.android.gms.common.ConnectionResult) -> a
com.google.android.gms.common.internal.BaseGmsClient$SignOutCallbacks -> com.google.android.gms.common.internal.b$e:
    void onSignOutComplete() -> a
com.google.android.gms.common.internal.BaseGmsClient$zza -> com.google.android.gms.common.internal.b$f:
    android.os.Bundle zzcr -> e
    int statusCode -> d
    com.google.android.gms.common.internal.BaseGmsClient zzcs -> f
    void zza(com.google.android.gms.common.ConnectionResult) -> a
    void zza(java.lang.Object) -> a
    void zzn() -> c
    boolean zzm() -> e
com.google.android.gms.common.internal.BaseGmsClient$zzb -> com.google.android.gms.common.internal.b$g:
    com.google.android.gms.common.internal.BaseGmsClient zzcs -> a
    void zza(android.os.Message) -> a
    boolean zzb(android.os.Message) -> b
com.google.android.gms.common.internal.BaseGmsClient$zzc -> com.google.android.gms.common.internal.b$h:
    java.lang.Object zzct -> a
    boolean zzcu -> b
    com.google.android.gms.common.internal.BaseGmsClient zzcs -> c
    void removeListener() -> a
    void zza(java.lang.Object) -> a
    void unregister() -> b
    void zzn() -> c
    void zzo() -> d
com.google.android.gms.common.internal.BaseGmsClient$zzd -> com.google.android.gms.common.internal.b$i:
    com.google.android.gms.common.internal.BaseGmsClient zzcv -> a
    int zzcw -> b
    void onPostInitComplete(int,android.os.IBinder,android.os.Bundle) -> a
    void zza(int,android.os.IBinder,com.google.android.gms.common.internal.zzb) -> a
    void zza(int,android.os.Bundle) -> b
com.google.android.gms.common.internal.BaseGmsClient$zze -> com.google.android.gms.common.internal.b$j:
    com.google.android.gms.common.internal.BaseGmsClient zzcs -> b
    int zzcw -> a
com.google.android.gms.common.internal.BaseGmsClient$zzf -> com.google.android.gms.common.internal.b$k:
    android.os.IBinder zzcx -> g
    com.google.android.gms.common.internal.BaseGmsClient zzcs -> h
    void zza(com.google.android.gms.common.ConnectionResult) -> a
    boolean zzm() -> e
com.google.android.gms.common.internal.BaseGmsClient$zzg -> com.google.android.gms.common.internal.b$l:
    com.google.android.gms.common.internal.BaseGmsClient zzcs -> g
    void zza(com.google.android.gms.common.ConnectionResult) -> a
    boolean zzm() -> e
com.google.android.gms.common.internal.ClientSettings -> com.google.android.gms.common.internal.c:
    android.accounts.Account zax -> a
    java.lang.String zabw -> f
    java.util.Map zaob -> d
    java.util.Set zaoa -> c
    java.lang.Integer zaod -> h
    java.util.Set zabr -> b
    com.google.android.gms.signin.SignInOptions zaoc -> g
    java.lang.String zabv -> e
    android.accounts.Account getAccount() -> a
    void setClientSessionId(java.lang.Integer) -> a
    android.accounts.Account getAccountOrDefault() -> b
    java.util.Set getAllRequestedScopes() -> c
    java.lang.Integer getClientSessionId() -> d
    java.lang.String getRealClientClassName() -> e
    java.lang.String getRealClientPackageName() -> f
    java.util.Set getRequiredScopes() -> g
    com.google.android.gms.signin.SignInOptions getSignInOptions() -> h
com.google.android.gms.common.internal.ClientSettings$Builder -> com.google.android.gms.common.internal.c$a:
    java.lang.String zabw -> g
    android.accounts.Account zax -> a
    java.lang.String zabv -> f
    java.util.Map zaob -> c
    android.support.v4.util.ArraySet zaoe -> b
    int zabt -> d
    com.google.android.gms.signin.SignInOptions zaoc -> h
    android.view.View zabu -> e
    com.google.android.gms.common.internal.ClientSettings$Builder addAllRequiredScopes(java.util.Collection) -> a
    com.google.android.gms.common.internal.ClientSettings build() -> a
    com.google.android.gms.common.internal.ClientSettings$Builder setAccount(android.accounts.Account) -> a
    com.google.android.gms.common.internal.ClientSettings$Builder setRealClientClassName(java.lang.String) -> a
    com.google.android.gms.common.internal.ClientSettings$Builder setRealClientPackageName(java.lang.String) -> b
com.google.android.gms.common.internal.ClientSettings$OptionalApiSettings -> com.google.android.gms.common.internal.c$b:
    java.util.Set mScopes -> a
com.google.android.gms.common.internal.ConnectionErrorMessages -> com.google.android.gms.common.internal.d:
    android.support.v4.util.SimpleArrayMap zaof -> a
    java.lang.String getAppName(android.content.Context) -> a
    java.lang.String getErrorDialogButtonMessage(android.content.Context,int) -> a
    java.lang.String zaa(android.content.Context,java.lang.String) -> a
    java.lang.String zaa(android.content.Context,java.lang.String,java.lang.String) -> a
    java.lang.String getDefaultNotificationChannelName(android.content.Context) -> b
    java.lang.String getErrorMessage(android.content.Context,int) -> b
    java.lang.String getErrorNotificationMessage(android.content.Context,int) -> c
    java.lang.String getErrorNotificationTitle(android.content.Context,int) -> d
    java.lang.String getErrorTitle(android.content.Context,int) -> e
com.google.android.gms.common.internal.DialogRedirect -> com.google.android.gms.common.internal.e:
    com.google.android.gms.common.internal.DialogRedirect getInstance(android.app.Activity,android.content.Intent,int) -> a
    void redirect() -> a
com.google.android.gms.common.internal.GetServiceRequest -> com.google.android.gms.common.internal.f:
    android.os.IBinder zzdi -> e
    com.google.android.gms.common.api.Scope[] zzdj -> f
    boolean zzdo -> k
    android.os.Bundle zzdk -> g
    com.google.android.gms.common.Feature[] zzdn -> j
    int zzdf -> b
    int zzdg -> c
    android.accounts.Account zzdl -> h
    com.google.android.gms.common.Feature[] zzdm -> i
    int version -> a
    java.lang.String zzdh -> d
com.google.android.gms.common.internal.GmsClient -> com.google.android.gms.common.internal.g:
    java.util.Set mScopes -> v
    android.accounts.Account zax -> w
    java.util.Set validateScopes(java.util.Set) -> a
    com.google.android.gms.common.internal.BaseGmsClient$BaseConnectionCallbacks zaa(com.google.android.gms.common.api.GoogleApiClient$ConnectionCallbacks) -> a
    com.google.android.gms.common.internal.BaseGmsClient$BaseOnConnectionFailedListener zaa(com.google.android.gms.common.api.GoogleApiClient$OnConnectionFailedListener) -> a
    java.util.Set zaa(java.util.Set) -> b
    int getMinApkVersion() -> i
    android.accounts.Account getAccount() -> k
    java.util.Set getScopes() -> q
com.google.android.gms.common.internal.GmsClientEventManager$GmsClientEventState -> com.google.android.gms.common.internal.h:
com.google.android.gms.common.internal.GmsClientSupervisor -> com.google.android.gms.common.internal.i:
    com.google.android.gms.common.internal.GmsClientSupervisor zzdq -> b
    java.lang.Object zzdp -> a
    com.google.android.gms.common.internal.GmsClientSupervisor getInstance(android.content.Context) -> a
    void zza(java.lang.String,java.lang.String,int,android.content.ServiceConnection,java.lang.String) -> a
    boolean zza(com.google.android.gms.common.internal.GmsClientSupervisor$zza,android.content.ServiceConnection,java.lang.String) -> a
    void zzb(com.google.android.gms.common.internal.GmsClientSupervisor$zza,android.content.ServiceConnection,java.lang.String) -> b
com.google.android.gms.common.internal.GmsClientSupervisor$zza -> com.google.android.gms.common.internal.i$a:
    android.content.ComponentName mComponentName -> c
    java.lang.String zzdr -> a
    int zzdt -> d
    java.lang.String zzds -> b
    android.content.ComponentName getComponentName() -> a
    android.content.Intent zzb(android.content.Context) -> a
    java.lang.String getPackage() -> b
    int zzq() -> c
com.google.android.gms.common.internal.GoogleApiAvailabilityCache -> com.google.android.gms.common.internal.j:
    com.google.android.gms.common.GoogleApiAvailabilityLight zaos -> b
    android.util.SparseIntArray zaor -> a
    void flush() -> a
    int getClientAvailability(android.content.Context,com.google.android.gms.common.api.Api$Client) -> a
com.google.android.gms.common.internal.IAccountAccessor -> com.google.android.gms.common.internal.k:
    android.accounts.Account getAccount() -> a
com.google.android.gms.common.internal.IAccountAccessor$Stub -> com.google.android.gms.common.internal.k$a:
    com.google.android.gms.common.internal.IAccountAccessor asInterface(android.os.IBinder) -> a
com.google.android.gms.common.internal.IAccountAccessor$Stub$zza -> com.google.android.gms.common.internal.k$a$a:
    android.accounts.Account getAccount() -> a
com.google.android.gms.common.internal.IGmsCallbacks -> com.google.android.gms.common.internal.l:
    void onPostInitComplete(int,android.os.IBinder,android.os.Bundle) -> a
    void zza(int,android.os.IBinder,com.google.android.gms.common.internal.zzb) -> a
    void zza(int,android.os.Bundle) -> b
com.google.android.gms.common.internal.IGmsCallbacks$zza -> com.google.android.gms.common.internal.l$a:
    boolean zza(int,android.os.Parcel,android.os.Parcel,int) -> a
com.google.android.gms.common.internal.IGmsServiceBroker -> com.google.android.gms.common.internal.n:
    void getService(com.google.android.gms.common.internal.IGmsCallbacks,com.google.android.gms.common.internal.GetServiceRequest) -> a
com.google.android.gms.common.internal.IGmsServiceBroker$Stub$zza -> com.google.android.gms.common.internal.m:
    android.os.IBinder zza -> a
    void getService(com.google.android.gms.common.internal.IGmsCallbacks,com.google.android.gms.common.internal.GetServiceRequest) -> a
com.google.android.gms.common.internal.Objects -> com.google.android.gms.common.internal.o:
    boolean equal(java.lang.Object,java.lang.Object) -> a
    int hashCode(java.lang.Object[]) -> a
    com.google.android.gms.common.internal.Objects$ToStringHelper toStringHelper(java.lang.Object) -> a
com.google.android.gms.common.internal.Objects$ToStringHelper -> com.google.android.gms.common.internal.o$a:
    java.util.List zzer -> a
    java.lang.Object zzes -> b
    com.google.android.gms.common.internal.Objects$ToStringHelper add(java.lang.String,java.lang.Object) -> a
com.google.android.gms.common.internal.Preconditions -> com.google.android.gms.common.internal.p:
    void checkArgument(boolean) -> a
    void checkHandlerThread(android.os.Handler) -> a
    java.lang.String checkNotEmpty(java.lang.String) -> a
    java.lang.String checkNotEmpty(java.lang.String,java.lang.Object) -> a
    java.lang.Object checkNotNull(java.lang.Object) -> a
    java.lang.Object checkNotNull(java.lang.Object,java.lang.Object) -> a
    void checkState(boolean,java.lang.Object) -> a
    void checkState(boolean) -> b
com.google.android.gms.common.internal.ResolveAccountRequest -> com.google.android.gms.common.internal.q:
    android.accounts.Account zax -> b
    com.google.android.gms.auth.api.signin.GoogleSignInAccount zapa -> d
    int zaoz -> c
    int zale -> a
    android.accounts.Account getAccount() -> b
    int getSessionId() -> c
    com.google.android.gms.auth.api.signin.GoogleSignInAccount getSignInAccountHint() -> d
com.google.android.gms.common.internal.ResolveAccountResponse -> com.google.android.gms.common.internal.r:
    android.os.IBinder zanw -> b
    com.google.android.gms.common.ConnectionResult zadh -> c
    boolean zapb -> e
    int zale -> a
    boolean zagf -> d
    com.google.android.gms.common.internal.IAccountAccessor getAccountAccessor() -> b
    com.google.android.gms.common.ConnectionResult getConnectionResult() -> c
    boolean getSaveDefaultAccount() -> d
    boolean isFromCrossClientAuth() -> e
com.google.android.gms.common.internal.SimpleClientAdapter -> com.google.android.gms.common.internal.s:
    com.google.android.gms.common.api.Api$SimpleClient zapf -> x
    android.os.IInterface createServiceInterface(android.os.IBinder) -> a
    void onSetConnectState(int,android.os.IInterface) -> a
    int getMinApkVersion() -> i
    java.lang.String getServiceDescriptor() -> s
    java.lang.String getStartServiceAction() -> t
    com.google.android.gms.common.api.Api$SimpleClient getClient() -> w
com.google.android.gms.common.internal.safeparcel.AbstractSafeParcelable -> com.google.android.gms.common.internal.t.a:
com.google.android.gms.common.internal.safeparcel.SafeParcelReader -> com.google.android.gms.common.internal.t.b:
    android.os.Bundle createBundle(android.os.Parcel,int) -> a
    android.os.Parcelable createParcelable(android.os.Parcel,int,android.os.Parcelable$Creator) -> a
    int getFieldId(int) -> a
    int readHeader(android.os.Parcel) -> a
    void zza(android.os.Parcel,int,int) -> a
    java.lang.String createString(android.os.Parcel,int) -> b
    java.lang.Object[] createTypedArray(android.os.Parcel,int,android.os.Parcelable$Creator) -> b
    int validateObjectHeader(android.os.Parcel) -> b
    java.util.ArrayList createTypedList(android.os.Parcel,int,android.os.Parcelable$Creator) -> c
    void ensureAtEnd(android.os.Parcel,int) -> c
    boolean readBoolean(android.os.Parcel,int) -> d
    android.os.IBinder readIBinder(android.os.Parcel,int) -> e
    int readInt(android.os.Parcel,int) -> f
    long readLong(android.os.Parcel,int) -> g
    int readSize(android.os.Parcel,int) -> h
    void skipUnknownField(android.os.Parcel,int) -> i
com.google.android.gms.common.internal.safeparcel.SafeParcelReader$ParseException -> com.google.android.gms.common.internal.t.b$a:
com.google.android.gms.common.internal.safeparcel.SafeParcelWriter -> com.google.android.gms.common.internal.t.c:
    int beginObjectHeader(android.os.Parcel) -> a
    void finishObjectHeader(android.os.Parcel,int) -> a
    void writeBoolean(android.os.Parcel,int,boolean) -> a
    void writeBundle(android.os.Parcel,int,android.os.Bundle,boolean) -> a
    void writeIBinder(android.os.Parcel,int,android.os.IBinder,boolean) -> a
    void writeInt(android.os.Parcel,int,int) -> a
    void writeLong(android.os.Parcel,int,long) -> a
    void writeParcelable(android.os.Parcel,int,android.os.Parcelable,int,boolean) -> a
    void writeString(android.os.Parcel,int,java.lang.String,boolean) -> a
    void writeTypedArray(android.os.Parcel,int,android.os.Parcelable[],int,boolean) -> a
    void writeTypedList(android.os.Parcel,int,java.util.List,boolean) -> a
    void zza(android.os.Parcel,android.os.Parcelable,int) -> a
    int zza(android.os.Parcel,int) -> b
    void zzb(android.os.Parcel,int,int) -> b
    void zzb(android.os.Parcel,int) -> c
com.google.android.gms.common.internal.safeparcel.SafeParcelable -> com.google.android.gms.common.internal.t.d:
com.google.android.gms.common.internal.zac -> com.google.android.gms.common.internal.u:
    android.content.Intent zaog -> a
    int val$requestCode -> c
    android.app.Activity val$activity -> b
    void redirect() -> a
com.google.android.gms.common.internal.zaf -> com.google.android.gms.common.internal.v:
    com.google.android.gms.common.api.GoogleApiClient$ConnectionCallbacks zaoi -> a
    void onConnected(android.os.Bundle) -> b
    void onConnectionSuspended(int) -> c
com.google.android.gms.common.internal.zag -> com.google.android.gms.common.internal.w:
    com.google.android.gms.common.api.GoogleApiClient$OnConnectionFailedListener zaoj -> a
    void onConnectionFailed(com.google.android.gms.common.ConnectionResult) -> a
com.google.android.gms.common.internal.zam -> com.google.android.gms.common.internal.x:
com.google.android.gms.common.internal.zan -> com.google.android.gms.common.internal.y:
com.google.android.gms.common.internal.zzb -> com.google.android.gms.common.internal.z:
    com.google.android.gms.common.Feature[] zzda -> b
    android.os.Bundle zzcz -> a
com.google.android.gms.common.internal.zzc -> com.google.android.gms.common.internal.a0:
com.google.android.gms.common.internal.zzd -> com.google.android.gms.common.internal.b0:
com.google.android.gms.common.internal.zze -> com.google.android.gms.common.internal.c0:
    android.os.Handler mHandler -> e
    long zzdy -> h
    long zzdx -> g
    android.content.Context zzdv -> d
    java.util.HashMap zzdu -> c
    com.google.android.gms.common.stats.ConnectionTracker zzdw -> f
    java.util.HashMap zza(com.google.android.gms.common.internal.zze) -> a
    boolean zza(com.google.android.gms.common.internal.GmsClientSupervisor$zza,android.content.ServiceConnection,java.lang.String) -> a
    android.os.Handler zzb(com.google.android.gms.common.internal.zze) -> b
    void zzb(com.google.android.gms.common.internal.GmsClientSupervisor$zza,android.content.ServiceConnection,java.lang.String) -> b
    android.content.Context zzc(com.google.android.gms.common.internal.zze) -> c
    com.google.android.gms.common.stats.ConnectionTracker zzd(com.google.android.gms.common.internal.zze) -> d
    long zze(com.google.android.gms.common.internal.zze) -> e
com.google.android.gms.common.internal.zzf -> com.google.android.gms.common.internal.d0:
    android.os.IBinder zzcy -> d
    com.google.android.gms.common.internal.zze zzec -> g
    java.util.Set zzdz -> a
    int mState -> b
    com.google.android.gms.common.internal.GmsClientSupervisor$zza zzeb -> e
    android.content.ComponentName mComponentName -> f
    boolean zzea -> c
    android.os.IBinder getBinder() -> a
    void zza(android.content.ServiceConnection,java.lang.String) -> a
    boolean zza(android.content.ServiceConnection) -> a
    void zze(java.lang.String) -> a
    android.content.ComponentName getComponentName() -> b
    void zzb(android.content.ServiceConnection,java.lang.String) -> b
    void zzf(java.lang.String) -> b
    int getState() -> c
    boolean isBound() -> d
    boolean zzr() -> e
com.google.android.gms.common.internal.zzg -> com.google.android.gms.common.internal.e0:
    android.content.Intent zza(java.lang.String,java.lang.String) -> a
    android.content.Intent zzg(java.lang.String) -> a
    android.content.Intent zzs() -> a
com.google.android.gms.common.internal.zzh -> com.google.android.gms.common.internal.f0:
    java.lang.String zzej -> a
    java.lang.String mPackageName -> b
    int zzdt -> c
    java.lang.String getPackageName() -> a
    int zzq() -> b
    java.lang.String zzt() -> c
com.google.android.gms.common.internal.zzi -> com.google.android.gms.common.internal.g0:
    int zzc() -> c
    com.google.android.gms.dynamic.IObjectWrapper zzb() -> d
com.google.android.gms.common.internal.zzj -> com.google.android.gms.common.internal.h0:
    boolean zza(int,android.os.Parcel,android.os.Parcel,int) -> a
com.google.android.gms.common.internal.zzp -> com.google.android.gms.common.internal.i0:
    java.lang.Object sLock -> a
    boolean zzeo -> b
    int zzeq -> c
    int zzd(android.content.Context) -> a
    void zze(android.content.Context) -> b
com.google.android.gms.common.internal.zzq -> com.google.android.gms.common.internal.j0:
com.google.android.gms.common.stats.ConnectionTracker -> b.b.a.a.b.k.a:
    java.lang.Object zzdp -> a
    com.google.android.gms.common.stats.ConnectionTracker zzfa -> b
    com.google.android.gms.common.stats.ConnectionTracker getInstance() -> a
    void unbindService(android.content.Context,android.content.ServiceConnection) -> a
    boolean zza(android.content.Context,java.lang.String,android.content.Intent,android.content.ServiceConnection,int) -> a
com.google.android.gms.common.util.ArrayUtils -> com.google.android.gms.common.util.a:
    boolean contains(java.lang.Object[],java.lang.Object) -> a
com.google.android.gms.common.util.ClientLibraryUtils -> com.google.android.gms.common.util.b:
    boolean zzc(android.content.Context,java.lang.String) -> a
com.google.android.gms.common.util.Clock -> com.google.android.gms.common.util.c:
    long currentTimeMillis() -> a
com.google.android.gms.common.util.DefaultClock -> com.google.android.gms.common.util.d:
    com.google.android.gms.common.util.DefaultClock zzgk -> a
    long currentTimeMillis() -> a
    com.google.android.gms.common.util.Clock getInstance() -> b
com.google.android.gms.common.util.DeviceProperties -> com.google.android.gms.common.util.e:
    java.lang.Boolean zzgq -> c
    java.lang.Boolean zzgn -> a
    java.lang.Boolean zzgo -> b
    boolean isSidewinder(android.content.Context) -> a
    boolean isWearable(android.content.Context) -> b
    boolean isWearableWithoutPlayStore(android.content.Context) -> c
    boolean zzf(android.content.Context) -> d
com.google.android.gms.common.util.PlatformVersion -> com.google.android.gms.common.util.f:
    boolean isAtLeastIceCreamSandwich() -> a
    boolean isAtLeastIceCreamSandwichMR1() -> b
    boolean isAtLeastJellyBean() -> c
    boolean isAtLeastJellyBeanMR2() -> d
    boolean isAtLeastKitKatWatch() -> e
    boolean isAtLeastLollipop() -> f
    boolean isAtLeastN() -> g
    boolean isAtLeastO() -> h
com.google.android.gms.common.util.zzb -> com.google.android.gms.common.util.g:
    int zzc(int) -> a
com.google.android.gms.common.wrappers.PackageManagerWrapper -> b.b.a.a.b.l.a:
    android.content.Context zzhv -> a
    android.content.pm.ApplicationInfo getApplicationInfo(java.lang.String,int) -> a
    java.lang.CharSequence getApplicationLabel(java.lang.String) -> a
    android.content.pm.PackageInfo getPackageInfo(java.lang.String,int) -> b
com.google.android.gms.common.wrappers.Wrappers -> b.b.a.a.b.l.b:
    com.google.android.gms.common.wrappers.Wrappers zzhx -> b
    com.google.android.gms.common.wrappers.PackageManagerWrapper zzhw -> a
    com.google.android.gms.common.wrappers.PackageManagerWrapper packageManager(android.content.Context) -> a
    com.google.android.gms.common.wrappers.PackageManagerWrapper zzi(android.content.Context) -> b
com.google.android.gms.common.zza -> b.b.a.a.b.m:
com.google.android.gms.common.zzb -> b.b.a.a.b.n:
com.google.android.gms.common.zzc -> b.b.a.a.b.o:
    android.content.Context zzp -> a
    void zza(android.content.Context) -> a
com.google.android.gms.common.zze -> b.b.a.a.b.p:
    int zzt -> a
    byte[] zza(java.lang.String) -> a
    int zzc() -> c
    com.google.android.gms.dynamic.IObjectWrapper zzb() -> d
    byte[] getBytes() -> e
com.google.android.gms.common.zzf -> b.b.a.a.b.q:
    byte[] zzu -> b
    byte[] getBytes() -> e
com.google.android.gms.common.zzg -> b.b.a.a.b.r:
    java.lang.ref.WeakReference zzw -> c
    java.lang.ref.WeakReference zzv -> b
    byte[] getBytes() -> e
    byte[] zzd() -> f
com.google.android.gms.common.zzh -> b.b.a.a.b.s:
    com.google.android.gms.common.zze[] zzx -> a
com.google.android.gms.common.zzi -> b.b.a.a.b.t:
    byte[] zzd() -> f
com.google.android.gms.common.zzj -> b.b.a.a.b.u:
    byte[] zzd() -> f
com.google.android.gms.dynamic.IObjectWrapper -> b.b.a.a.c.a:
com.google.android.gms.dynamic.IObjectWrapper$Stub -> b.b.a.a.c.a$a:
com.google.android.gms.dynamic.ObjectWrapper -> b.b.a.a.c.b:
    java.lang.Object zzhz -> a
    java.lang.Object unwrap(com.google.android.gms.dynamic.IObjectWrapper) -> a
    com.google.android.gms.dynamic.IObjectWrapper wrap(java.lang.Object) -> a
com.google.android.gms.internal.base.zaa -> b.b.a.a.d.a.a:
    android.os.IBinder zaa -> a
    java.lang.String zab -> b
    void zab(int,android.os.Parcel) -> a
    android.os.Parcel zaa() -> e
com.google.android.gms.internal.base.zab -> b.b.a.a.d.a.b:
    boolean dispatchTransaction(int,android.os.Parcel,android.os.Parcel,int) -> a
com.google.android.gms.internal.base.zac -> b.b.a.a.d.a.c:
    android.os.Parcelable zaa(android.os.Parcel,android.os.Parcelable$Creator) -> a
    void zaa(android.os.Parcel,android.os.IInterface) -> a
    void zaa(android.os.Parcel,android.os.Parcelable) -> a
com.google.android.gms.internal.base.zal -> b.b.a.a.d.a.d:
com.google.android.gms.internal.common.zza -> b.b.a.a.d.b.a:
    android.os.IBinder zza -> a
    java.lang.String zzb -> b
    android.os.Parcel zza(int,android.os.Parcel) -> a
    android.os.Parcel zza() -> e
com.google.android.gms.internal.common.zzb -> b.b.a.a.d.b.b:
    boolean zza(int,android.os.Parcel,android.os.Parcel,int) -> a
com.google.android.gms.internal.common.zzc -> b.b.a.a.d.b.c:
    android.os.Parcelable zza(android.os.Parcel,android.os.Parcelable$Creator) -> a
    void zza(android.os.Parcel,android.os.IInterface) -> a
com.google.android.gms.internal.common.zze -> b.b.a.a.d.b.d:
com.google.android.gms.signin.SignInOptions -> b.b.a.a.e.a:
    com.google.android.gms.signin.SignInOptions DEFAULT -> i
    boolean zart -> f
    boolean zars -> a
    java.lang.String zaab -> c
    java.lang.Long zaru -> g
    boolean zay -> b
    java.lang.Long zarv -> h
    java.lang.String zaac -> e
    boolean zaaa -> d
    java.lang.Long getAuthApiSignInModuleVersion() -> a
    java.lang.String getHostedDomain() -> b
    java.lang.Long getRealClientLibraryVersion() -> c
    java.lang.String getServerClientId() -> d
    boolean isForceCodeForRefreshToken() -> e
    boolean isIdTokenRequested() -> f
    boolean isOfflineAccessRequested() -> g
    boolean waitForAccessTokenRefresh() -> h
com.google.android.gms.signin.SignInOptions$zaa -> b.b.a.a.e.a$a:
com.google.android.gms.signin.internal.SignInClientImpl -> b.b.a.a.e.b.a:
    boolean zary -> x
    com.google.android.gms.common.internal.ClientSettings zaes -> y
    android.os.Bundle zarz -> z
    java.lang.Integer zaod -> A
    android.os.Bundle createBundleFromClientSettings(com.google.android.gms.common.internal.ClientSettings) -> a
    android.os.IInterface createServiceInterface(android.os.IBinder) -> a
    void zaa(com.google.android.gms.signin.internal.zad) -> a
    void connect() -> e
    boolean requiresSignIn() -> g
    int getMinApkVersion() -> i
    android.os.Bundle getGetServiceRequestExtraArgs() -> o
    java.lang.String getServiceDescriptor() -> s
    java.lang.String getStartServiceAction() -> t
com.google.android.gms.signin.internal.zaa -> b.b.a.a.e.b.b:
    android.content.Intent zarx -> c
    int zarw -> b
    int zale -> a
    com.google.android.gms.common.api.Status getStatus() -> a
com.google.android.gms.signin.internal.zab -> b.b.a.a.e.b.c:
com.google.android.gms.signin.internal.zac -> b.b.a.a.e.b.d:
    void zaa(com.google.android.gms.common.ConnectionResult,com.google.android.gms.signin.internal.zaa) -> a
    void zaa(com.google.android.gms.common.api.Status,com.google.android.gms.auth.api.signin.GoogleSignInAccount) -> a
    void zah(com.google.android.gms.common.api.Status) -> a
    void zag(com.google.android.gms.common.api.Status) -> b
com.google.android.gms.signin.internal.zad -> b.b.a.a.e.b.e:
    void zaa(com.google.android.gms.common.ConnectionResult,com.google.android.gms.signin.internal.zaa) -> a
    void zaa(com.google.android.gms.common.api.Status,com.google.android.gms.auth.api.signin.GoogleSignInAccount) -> a
    void zab(com.google.android.gms.signin.internal.zaj) -> a
    void zah(com.google.android.gms.common.api.Status) -> a
    void zag(com.google.android.gms.common.api.Status) -> b
com.google.android.gms.signin.internal.zae -> b.b.a.a.e.b.f:
    boolean dispatchTransaction(int,android.os.Parcel,android.os.Parcel,int) -> a
com.google.android.gms.signin.internal.zaf -> b.b.a.a.e.b.g:
    void zaa(com.google.android.gms.signin.internal.zah,com.google.android.gms.signin.internal.zad) -> a
com.google.android.gms.signin.internal.zag -> b.b.a.a.e.b.h:
    void zaa(com.google.android.gms.signin.internal.zah,com.google.android.gms.signin.internal.zad) -> a
com.google.android.gms.signin.internal.zah -> b.b.a.a.e.b.i:
    com.google.android.gms.common.internal.ResolveAccountRequest zasa -> b
    int zale -> a
com.google.android.gms.signin.internal.zai -> b.b.a.a.e.b.j:
com.google.android.gms.signin.internal.zaj -> b.b.a.a.e.b.k:
    com.google.android.gms.common.ConnectionResult zadh -> b
    com.google.android.gms.common.internal.ResolveAccountResponse zasb -> c
    int zale -> a
    com.google.android.gms.common.ConnectionResult getConnectionResult() -> b
    com.google.android.gms.common.internal.ResolveAccountResponse zacw() -> c
com.google.android.gms.signin.internal.zak -> b.b.a.a.e.b.l:
com.google.android.gms.signin.zaa -> b.b.a.a.e.c:
    com.google.android.gms.common.api.Api$ClientKey zarp -> b
    com.google.android.gms.common.api.Api$ClientKey CLIENT_KEY -> a
    com.google.android.gms.common.api.Api$AbstractClientBuilder zarq -> d
    com.google.android.gms.common.api.Api$AbstractClientBuilder zapg -> c
com.google.android.gms.signin.zab -> b.b.a.a.e.d:
    com.google.android.gms.common.api.Api$Client buildClient(android.content.Context,android.os.Looper,com.google.android.gms.common.internal.ClientSettings,java.lang.Object,com.google.android.gms.common.api.GoogleApiClient$ConnectionCallbacks,com.google.android.gms.common.api.GoogleApiClient$OnConnectionFailedListener) -> a
com.google.android.gms.signin.zac -> b.b.a.a.e.e:
    com.google.android.gms.common.api.Api$Client buildClient(android.content.Context,android.os.Looper,com.google.android.gms.common.internal.ClientSettings,java.lang.Object,com.google.android.gms.common.api.GoogleApiClient$ConnectionCallbacks,com.google.android.gms.common.api.GoogleApiClient$OnConnectionFailedListener) -> a
com.google.android.gms.signin.zad -> b.b.a.a.e.f:
    void zaa(com.google.android.gms.signin.internal.zad) -> a
    void connect() -> e
com.google.android.gms.tasks.Task -> b.b.a.a.f.a:
com.google.android.gms.tasks.TaskCompletionSource -> b.b.a.a.f.b:
    com.google.android.gms.tasks.zzu zza -> a
    void setException(java.lang.Exception) -> a
    void setResult(java.lang.Object) -> a
    boolean trySetException(java.lang.Exception) -> b
    boolean trySetResult(java.lang.Object) -> b
com.google.android.gms.tasks.zzq -> b.b.a.a.f.c:
    void onComplete(com.google.android.gms.tasks.Task) -> a
com.google.android.gms.tasks.zzr -> b.b.a.a.f.d:
    java.util.Queue zzt -> b
    java.lang.Object mLock -> a
    boolean zzu -> c
    void zza(com.google.android.gms.tasks.Task) -> a
com.google.android.gms.tasks.zzu -> b.b.a.a.f.e:
    com.google.android.gms.tasks.zzr zzx -> b
    java.lang.Object mLock -> a
    boolean zzy -> c
    void setException(java.lang.Exception) -> a
    void setResult(java.lang.Object) -> a
    void zzc() -> a
    boolean trySetException(java.lang.Exception) -> b
    boolean trySetResult(java.lang.Object) -> b
com.kotcrab.vis.ui.VisUI -> b.c.a.a.a:
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> b
    boolean skipGdxVersionCheck -> a
    void checkBeforeLoad() -> a
    void load(com.badlogic.gdx.scenes.scene2d.ui.Skin) -> a
    boolean isLoaded() -> b
com.shdwfghtr.entity.Bergamot -> b.d.a.a:
    com.shdwfghtr.entity.Enemy[] wormHives -> O
    com.shdwfghtr.entity.Snail snail -> Q
    com.shdwfghtr.explore.Timer spawnTimer -> T
    com.shdwfghtr.entity.Crawler[] crawlers -> P
    com.shdwfghtr.entity.Door door -> N
    float[] snailPos -> R
    com.shdwfghtr.entity.Wasp wasp -> S
    com.shdwfghtr.entity.Crawler[] access$000(com.shdwfghtr.entity.Bergamot) -> a
    com.shdwfghtr.entity.Enemy[] access$100(com.shdwfghtr.entity.Bergamot) -> b
    void initialize(com.shdwfghtr.explore.World) -> b
    com.shdwfghtr.entity.Snail access$200(com.shdwfghtr.entity.Bergamot) -> c
    float[] access$300(com.shdwfghtr.entity.Bergamot) -> d
    void takeDamage(float) -> f
    void update(float) -> g
    void destroy() -> x
com.shdwfghtr.entity.Bergamot$1 -> b.d.a.a$a:
    com.shdwfghtr.entity.Bergamot this$0 -> d
    com.shdwfghtr.explore.World val$world -> c
    boolean onCompletion() -> c
com.shdwfghtr.entity.Bomb -> b.d.a.b:
    com.shdwfghtr.explore.Timer timer -> J
    com.badlogic.gdx.utils.Pool POOL -> K
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void reset() -> a
    void setPower(float) -> h
    void destroy() -> x
com.shdwfghtr.entity.Bomb$1 -> b.d.a.b$a:
    com.shdwfghtr.entity.Bomb newObject() -> a
    java.lang.Object newObject() -> a
com.shdwfghtr.entity.Bomb$2 -> b.d.a.b$b:
    com.shdwfghtr.entity.Bomb this$0 -> c
    boolean onCompletion() -> c
com.shdwfghtr.entity.Bomb$Explosion -> b.d.a.b$c:
    void collideWith(com.shdwfghtr.entity.Entity) -> a
    void loadAnimation(com.shdwfghtr.explore.World) -> a
    void update(float) -> g
    void checkCollisions() -> w
com.shdwfghtr.entity.Boss -> b.d.a.c:
    com.badlogic.gdx.audio.Music intro_music -> K
    com.badlogic.gdx.audio.Music main_music -> L
    com.shdwfghtr.explore.World world -> M
    com.shdwfghtr.entity.Door door -> J
    void initialize(com.shdwfghtr.explore.World) -> b
    void destroy() -> x
com.shdwfghtr.entity.Boss$1 -> b.d.a.c$a:
    com.shdwfghtr.entity.Boss this$0 -> a
    void onCompletion(com.badlogic.gdx.audio.Music) -> a
com.shdwfghtr.entity.Boss$2 -> b.d.a.c$b:
    com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect[] val$effects -> J
    com.shdwfghtr.entity.Boss this$0 -> L
    com.shdwfghtr.entity.Boss val$boss -> K
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void update(float) -> g
    void destroy() -> x
com.shdwfghtr.entity.Boss$3 -> b.d.a.c$c:
    com.shdwfghtr.entity.Boss this$0 -> d
    com.shdwfghtr.entity.Entity val$explosion -> c
    boolean onCompletion() -> c
com.shdwfghtr.entity.Bullet -> b.d.a.d:
    com.badlogic.gdx.utils.Pool POOL -> L
    com.shdwfghtr.explore.Timer rangeTimer -> K
    com.shdwfghtr.entity.Entity target -> J
    void collideWith(com.shdwfghtr.entity.Entity) -> a
    void reset() -> a
    void setAnimation(com.badlogic.gdx.graphics.g2d.Animation) -> a
    void update(float) -> g
    void checkCollisions() -> w
    void destroy() -> x
com.shdwfghtr.entity.Bullet$1 -> b.d.a.d$a:
    com.shdwfghtr.entity.Bullet newObject() -> a
    java.lang.Object newObject() -> a
com.shdwfghtr.entity.Bullet$2 -> b.d.a.d$b:
    com.shdwfghtr.entity.Bullet this$0 -> c
    boolean onCompletion() -> c
com.shdwfghtr.entity.Crawler -> b.d.a.e:
    void respawn() -> J
    void setAnimation(com.badlogic.gdx.graphics.g2d.Animation) -> a
    void takeDamage(float) -> f
    void checkCollisions() -> w
com.shdwfghtr.entity.Door -> b.d.a.f:
    float animationTime -> K
    boolean open -> J
    com.shdwfghtr.explore.Timer openTimer -> L
    com.badlogic.gdx.graphics.g2d.Animation unlockedAnimation -> M
    com.badlogic.gdx.graphics.g2d.Animation lockedAnimation -> N
    boolean isLocked() -> K
    void access$000(com.shdwfghtr.entity.Door,boolean) -> a
    void collideWith(com.shdwfghtr.entity.Entity) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void loadAnimation(com.shdwfghtr.explore.World) -> a
    void setLocked(boolean) -> c
    void setOpen(boolean) -> d
    void update(float) -> g
com.shdwfghtr.entity.Door$1 -> b.d.a.f$a:
    com.shdwfghtr.entity.Door this$0 -> c
    boolean onCompletion() -> c
com.shdwfghtr.entity.Dropper -> b.d.a.g:
    boolean FALL -> J
    void respawn() -> J
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void takeDamage(float) -> f
    void update(float) -> g
    void checkCollisions() -> w
com.shdwfghtr.entity.Dropper$1 -> b.d.a.g$a:
com.shdwfghtr.entity.Dropper$Rock -> b.d.a.g$b:
    com.badlogic.gdx.utils.Pool POOL -> J
    com.badlogic.gdx.utils.Pool access$000() -> L
    void reset() -> a
    void update(float) -> g
com.shdwfghtr.entity.Dropper$Rock$1 -> b.d.a.g$b$a:
    com.shdwfghtr.entity.Dropper$Rock newObject() -> a
    java.lang.Object newObject() -> a
com.shdwfghtr.entity.Enemy -> b.d.a.h:
    void initiateMovement() -> K
    void collideWith(com.shdwfghtr.entity.Entity) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void geemerCollisionAI(com.shdwfghtr.entity.Enemy) -> a
    void dropItem(float,float) -> f
    void destroy() -> x
com.shdwfghtr.entity.Entity -> b.d.a.i:
    float importance -> G
    float stateTime -> F
    boolean delete -> v
    float power -> C
    com.badlogic.gdx.math.Vector2 VECTOR2 -> I
    float speed -> B
    boolean left -> x
    float health -> A
    boolean hurt -> y
    com.badlogic.gdx.graphics.g2d.Animation animation -> u
    com.shdwfghtr.entity.Entity$DrawLayer drawLayer -> z
    boolean persistent -> E
    com.badlogic.gdx.math.Vector2 d -> w
    com.badlogic.gdx.utils.Pool HURT_TIMER_POOL -> H
    java.lang.String name -> D
    com.badlogic.gdx.math.Vector2 getCenter() -> A
    float getCenterX() -> B
    float getCenterY() -> C
    float getImportance() -> D
    java.lang.String getName() -> E
    float getRight() -> F
    float getTop() -> G
    boolean isDead() -> H
    boolean onGround() -> I
    void respawn() -> J
    boolean hasAnimation() -> K
    void collideWith(com.shdwfghtr.entity.Entity) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    java.lang.String getSaveString(com.shdwfghtr.explore.World,com.shdwfghtr.entity.Entity) -> a
    void loadAnimation(com.shdwfghtr.explore.World) -> a
    void setAnimation(com.badlogic.gdx.graphics.g2d.Animation) -> a
    java.lang.String getSaveString(com.shdwfghtr.entity.Entity) -> b
    void setDelete(boolean) -> b
    void takeDamage(float) -> f
    void update(float) -> g
    void checkCollisions() -> w
    void destroy() -> x
    com.badlogic.gdx.graphics.g2d.Animation getAnimation() -> y
    com.badlogic.gdx.math.Rectangle getBox() -> z
com.shdwfghtr.entity.Entity$1 -> b.d.a.i$a:
    com.shdwfghtr.entity.Entity$HurtTimer newObject() -> a
    java.lang.Object newObject() -> a
com.shdwfghtr.entity.Entity$DrawLayer -> b.d.a.i$b:
    com.shdwfghtr.entity.Entity$DrawLayer BACKGROUND -> a
    com.shdwfghtr.entity.Entity$DrawLayer[] $VALUES -> d
    com.shdwfghtr.entity.Entity$DrawLayer FOREGROUND -> c
    com.shdwfghtr.entity.Entity$DrawLayer NORMAL -> b
com.shdwfghtr.entity.Entity$HurtTimer -> b.d.a.i$c:
    com.shdwfghtr.entity.Entity entity -> c
    boolean onCompletion() -> c
com.shdwfghtr.entity.Glibber -> b.d.a.j:
    com.badlogic.gdx.math.Vector2 EYE_POSITION -> S
    com.shdwfghtr.explore.Timer spawnTimer -> R
    float spawnY -> P
    boolean intro -> Q
    float spawnX -> O
    com.shdwfghtr.entity.Glibber$Body body -> N
    com.shdwfghtr.entity.Glibber$Body access$000(com.shdwfghtr.entity.Glibber) -> a
    boolean access$302(com.shdwfghtr.entity.Glibber,boolean) -> a
    void collideWith(com.shdwfghtr.entity.Entity) -> a
    float access$100(com.shdwfghtr.entity.Glibber) -> b
    void initialize(com.shdwfghtr.explore.World) -> b
    float access$200(com.shdwfghtr.entity.Glibber) -> c
    void takeDamage(float) -> f
    void update(float) -> g
    void checkCollisions() -> w
    void destroy() -> x
com.shdwfghtr.entity.Glibber$1 -> b.d.a.j$a:
    com.shdwfghtr.entity.Glibber this$0 -> d
    com.shdwfghtr.explore.World val$world -> c
    void reset() -> a
    boolean onCompletion() -> c
com.shdwfghtr.entity.Glibber$Body -> b.d.a.j$b:
    boolean crawling -> J
    com.shdwfghtr.entity.Glibber this$0 -> K
    void respawn() -> J
    boolean access$500(com.shdwfghtr.entity.Glibber$Body) -> a
    void collideWith(com.shdwfghtr.entity.Entity) -> a
    void checkCollisions() -> w
com.shdwfghtr.entity.Glibber$Goop -> b.d.a.j$c:
    com.badlogic.gdx.graphics.g2d.TextureRegion texture -> J
    com.badlogic.gdx.utils.Array FRAMES -> K
    com.badlogic.gdx.utils.Pool POOL -> L
    com.badlogic.gdx.utils.Pool access$600() -> L
    com.badlogic.gdx.utils.Array access$900() -> M
    com.badlogic.gdx.graphics.g2d.TextureRegion access$800(com.shdwfghtr.entity.Glibber$Goop) -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion access$802(com.shdwfghtr.entity.Glibber$Goop,com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
    void reset() -> a
    void update(float) -> g
com.shdwfghtr.entity.Glibber$Goop$1 -> b.d.a.j$c$a:
    com.shdwfghtr.entity.Glibber$Goop newObject() -> a
    java.lang.Object newObject() -> a
com.shdwfghtr.entity.Gnats -> b.d.a.k:
    com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect effect -> J
    void respawn() -> J
    void collideWith(com.shdwfghtr.entity.Entity) -> a
    void loadAnimation(com.shdwfghtr.explore.World) -> a
    void setDelete(boolean) -> b
    void takeDamage(float) -> f
    void update(float) -> g
com.shdwfghtr.entity.Hopper -> b.d.a.l:
    void respawn() -> J
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void takeDamage(float) -> f
    void update(float) -> g
    void checkCollisions() -> w
com.shdwfghtr.entity.Item -> b.d.a.m:
    java.util.ArrayList GENERIC_ITEMS -> K
    java.util.ArrayList OPTIONAL_ITEMS -> J
    void setAnimation(com.badlogic.gdx.graphics.g2d.Animation) -> a
com.shdwfghtr.entity.Player -> b.d.a.n:
    boolean UP -> P
    java.util.HashMap animations -> L
    com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect stepEffect -> K
    boolean MISSILE -> U
    com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect oxygenEffect -> J
    boolean SPIN -> Q
    boolean RUN -> R
    boolean DOWN -> S
    boolean MORPH -> T
    int maxArmor -> Z
    int missiles -> X
    int armor -> Y
    int maxHealth -> V
    com.badlogic.gdx.Preferences INVENTORY -> a0
    int maxMissiles -> W
    long soundID -> c0
    com.shdwfghtr.entity.Player CURRENT -> b0
    float bullet_life -> O
    float jump_speed -> N
    float charge -> M
    boolean canJump() -> K
    void fire() -> L
    void loadAnimations() -> M
    void save() -> N
    void addToInventory(com.shdwfghtr.entity.Item) -> a
    void collideWith(com.shdwfghtr.entity.Entity) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    boolean itemActive(java.lang.String) -> a
    void load(com.shdwfghtr.entity.Player) -> a
    void takeDamage(float) -> f
    void update(float) -> g
    float calculateBulletRange(float) -> h
    float calculateJumpHeight(float) -> i
    float calculateSpeed(float) -> j
    void checkCollisions() -> w
com.shdwfghtr.entity.PooledItem -> b.d.a.o:
    com.badlogic.gdx.utils.Pool POOL -> M
    com.shdwfghtr.explore.Timer lifeTimer -> L
    void reset() -> a
    void set(java.lang.String,float,float) -> a
    void destroy() -> x
com.shdwfghtr.entity.PooledItem$1 -> b.d.a.o$a:
    com.shdwfghtr.entity.PooledItem newObject() -> a
    java.lang.Object newObject() -> a
com.shdwfghtr.entity.PooledItem$2 -> b.d.a.o$b:
    com.shdwfghtr.entity.PooledItem this$0 -> c
    boolean onCompletion() -> c
com.shdwfghtr.entity.Slick -> b.d.a.p:
    com.badlogic.gdx.utils.Pool POOL -> J
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void reset() -> a
    void spawn(float,float) -> f
    void destroy() -> x
com.shdwfghtr.entity.Slick$1 -> b.d.a.p$a:
    com.shdwfghtr.entity.Slick newObject() -> a
    java.lang.Object newObject() -> a
com.shdwfghtr.entity.Slick$2 -> b.d.a.p$b:
    com.shdwfghtr.entity.Slick this$0 -> c
    boolean onCompletion() -> c
com.shdwfghtr.entity.Snail -> b.d.a.q:
    void respawn() -> J
    void collideWith(com.shdwfghtr.entity.Entity) -> a
    void setAnimation(com.badlogic.gdx.graphics.g2d.Animation) -> a
    void takeDamage(float) -> f
    void checkCollisions() -> w
com.shdwfghtr.entity.Spawner -> b.d.a.r:
    com.shdwfghtr.entity.Entity entity -> a
    float height -> e
    float width -> d
    float y -> c
    float x -> b
    com.badlogic.gdx.math.Vector2 getCenter() -> a
    void set(float,float,float,float) -> a
    void spawn() -> b
com.shdwfghtr.entity.Switch -> b.d.a.s:
    com.badlogic.gdx.graphics.g2d.Animation unlockedAnimation -> J
    com.badlogic.gdx.graphics.g2d.Animation lockedAnimation -> K
    void trigger() -> K
    void collideWith(com.shdwfghtr.entity.Entity) -> a
    void loadAnimation(com.shdwfghtr.explore.World) -> a
com.shdwfghtr.entity.Turret -> b.d.a.t:
    float arm_angle -> L
    int angle -> K
    com.badlogic.gdx.math.Vector2 pivot -> J
    void fire() -> L
    void update(float) -> g
com.shdwfghtr.entity.Turret$1 -> b.d.a.t$a:
com.shdwfghtr.entity.Turret$Projectile -> b.d.a.t$b:
    com.badlogic.gdx.utils.Pool POOL -> J
    com.badlogic.gdx.utils.Pool access$000() -> L
    void reset() -> a
com.shdwfghtr.entity.Turret$Projectile$1 -> b.d.a.t$b$a:
    com.shdwfghtr.entity.Turret$Projectile newObject() -> a
    java.lang.Object newObject() -> a
com.shdwfghtr.entity.Wasp -> b.d.a.u:
    com.badlogic.gdx.utils.Pool POOL -> J
    void respawn() -> J
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void reset() -> a
    void setAnimation(com.badlogic.gdx.graphics.g2d.Animation) -> a
    void takeDamage(float) -> f
    void update(float) -> g
    void destroy() -> x
com.shdwfghtr.entity.Wasp$1 -> b.d.a.u$a:
    com.shdwfghtr.entity.Wasp newObject() -> a
    java.lang.Object newObject() -> a
com.shdwfghtr.entity.WaspNest -> b.d.a.v:
    com.shdwfghtr.entity.Wasp wasp -> J
    com.shdwfghtr.explore.Timer spawnTimer -> K
    void respawn() -> J
    void takeDamage(float) -> f
    void update(float) -> g
com.shdwfghtr.explore.ActionResolver -> com.shdwfghtr.explore.a:
com.shdwfghtr.explore.Asset -> com.shdwfghtr.explore.b:
    com.badlogic.gdx.math.Vector2 VECTOR2 -> r
    com.badlogic.gdx.assets.AssetManager manager -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas environmentAtlas -> g
    java.lang.String[] INPUT_LIST -> x
    com.badlogic.gdx.graphics.g2d.TextureAtlas entityAtlas -> f
    com.badlogic.gdx.graphics.g2d.TextureAtlas bgAtlas -> h
    java.util.HashMap palettes -> l
    com.badlogic.gdx.scenes.scene2d.Stage stage -> d
    com.badlogic.gdx.graphics.g2d.TextureAtlas explosionAtlas -> i
    com.badlogic.gdx.graphics.g2d.TextureAtlas uiAtlas -> e
    com.badlogic.gdx.utils.Array MESSAGES -> v
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> j
    com.shdwfghtr.explore.Asset$Particles particles -> c
    com.badlogic.gdx.scenes.scene2d.ui.Image curtain -> k
    com.shdwfghtr.explore.MusicHandler musicHandler -> b
    com.shdwfghtr.explore.GameCamera CAMERA -> u
    com.badlogic.gdx.graphics.g2d.GlyphLayout GLYPH -> t
    com.badlogic.gdx.Preferences OPTIONS -> o
    java.util.ArrayList TIMERS -> w
    com.badlogic.gdx.Preferences CONTROLS -> n
    com.badlogic.gdx.Preferences DATA -> p
    java.util.Random RANDOM -> q
    float TIME -> m
    com.badlogic.gdx.math.Rectangle RECTANGLE -> s
    void dispose() -> a
    com.badlogic.gdx.graphics.Color[] getPalette(java.lang.String) -> a
    com.badlogic.gdx.graphics.Color[] paletteFromPal(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.graphics.Texture recolorTextureRegion(com.badlogic.gdx.graphics.g2d.TextureRegion,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color) -> a
    void recolorTextureRegion(com.badlogic.gdx.graphics.g2d.TextureRegion,com.badlogic.gdx.graphics.Color[],com.badlogic.gdx.graphics.Color[]) -> a
    void initializeResources() -> b
    void load() -> c
    com.badlogic.gdx.graphics.g2d.TextureAtlas getBGAtlas() -> d
    com.badlogic.gdx.graphics.g2d.BitmapFont getBodyFont() -> e
    com.badlogic.gdx.scenes.scene2d.ui.Image getCurtain() -> f
    com.badlogic.gdx.graphics.g2d.TextureAtlas getEntityAtlas() -> g
    com.badlogic.gdx.graphics.g2d.TextureAtlas getEnvironmentAtlas() -> h
    com.badlogic.gdx.graphics.g2d.TextureAtlas getExplosionAtlas() -> i
    com.badlogic.gdx.graphics.g2d.BitmapFont getHeaderFont() -> j
    com.badlogic.gdx.assets.AssetManager getManager() -> k
    com.shdwfghtr.explore.MusicHandler getMusicHandler() -> l
    com.shdwfghtr.explore.Asset$Particles getParticles() -> m
    com.badlogic.gdx.scenes.scene2d.ui.Skin getSkin() -> n
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> o
    com.shdwfghtr.explore.Timer[] getTimers() -> p
    com.badlogic.gdx.graphics.g2d.TextureAtlas getUIAtlas() -> q
    void initialize() -> r
    void resetControls() -> s
    void resetData() -> t
com.shdwfghtr.explore.Asset$Convert -> com.shdwfghtr.explore.b$a:
    long toLong(java.lang.String) -> a
    java.lang.String toString(long) -> a
com.shdwfghtr.explore.Asset$Cursors -> com.shdwfghtr.explore.b$b:
    java.lang.String CURRENT -> a
    void setCurrent(java.lang.String) -> a
com.shdwfghtr.explore.Asset$Particles -> com.shdwfghtr.explore.b$c:
    java.util.HashMap POOLS -> a
    com.badlogic.gdx.utils.Array NORMAL_EFFECTS -> c
    com.badlogic.gdx.utils.Array ADDITIVE_EFFECTS -> b
    com.badlogic.gdx.graphics.g2d.TextureAtlas atlas -> d
    void access$000(com.shdwfghtr.explore.Asset$Particles,com.badlogic.gdx.files.FileHandle) -> a
    void add(com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect) -> a
    void addParticleEffect(com.badlogic.gdx.files.FileHandle) -> a
    void colorEffect(com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect,com.badlogic.gdx.graphics.Color) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect[] getEffects() -> a
    com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect obtain(java.lang.String,java.lang.Boolean) -> a
    void update(float) -> a
    void remove(com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect) -> b
com.shdwfghtr.explore.GameCamera -> com.shdwfghtr.explore.c:
    com.badlogic.gdx.math.Vector3 POSITION -> u
    float maxOffsetY -> s
    float maxOffsetX -> r
    float maxAngle -> q
    float trauma -> p
    float padding -> o
    com.badlogic.gdx.math.Rectangle RECTANGLE -> t
    com.badlogic.gdx.math.Vector3 SHAKE -> v
    com.shdwfghtr.explore.Perlin PERLIN -> w
    void update() -> a
    void addTrauma(float) -> b
    com.badlogic.gdx.math.Rectangle getBox() -> b
    float getRight() -> c
    void setAngle(float) -> c
    float getTop() -> d
    float getX() -> e
    float getY() -> f
com.shdwfghtr.explore.GameState -> com.shdwfghtr.explore.d:
    com.shdwfghtr.explore.GameState PLAY -> a
    com.shdwfghtr.explore.GameState PAUSE -> b
    com.shdwfghtr.explore.GameState[] $VALUES -> d
    com.shdwfghtr.explore.GameState CUTSCENE -> c
com.shdwfghtr.explore.GdxGame -> com.shdwfghtr.explore.e:
    com.badlogic.gdx.graphics.Color fadeColor -> e
    com.badlogic.gdx.math.Vector2 cursor -> c
    com.shdwfghtr.explore.Asset asset -> b
    com.badlogic.gdx.graphics.profiling.GLProfiler profiler -> d
    void dispose() -> a
    void create() -> d
    void render() -> e
com.shdwfghtr.explore.HSL -> com.shdwfghtr.explore.f:
    float a -> d
    float l -> c
    float s -> b
    float h -> a
    float hue2rgb(float,float,float) -> a
    com.badlogic.gdx.math.Vector3 rgbToHsl(com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.graphics.Color toRGB() -> a
com.shdwfghtr.explore.MusicHandler -> com.shdwfghtr.explore.g:
    com.badlogic.gdx.audio.Music music -> a
    float volume -> d
    float MAX_VOLUME -> c
    float fadeTime -> b
    com.shdwfghtr.explore.MusicHandler$MusicState currentState -> e
    com.shdwfghtr.explore.MusicHandler$MusicState previousState -> f
    void fadeIn(float) -> a
    float getMaxVolume() -> a
    void playSound(java.lang.String) -> a
    void playSound(java.lang.String,float) -> a
    void playSound(java.lang.String,float,float,float) -> a
    void setMusic(com.badlogic.gdx.audio.Music,boolean) -> a
    void setState(com.shdwfghtr.explore.MusicHandler$MusicState) -> a
    void fadeOut(float) -> b
    void setMusic(java.lang.String) -> b
    void setMaxVolume(float) -> c
    void setVolume(float) -> d
    void update(float) -> e
com.shdwfghtr.explore.MusicHandler$1 -> com.shdwfghtr.explore.g$a:
    int[] $SwitchMap$com$shdwfghtr$explore$MusicHandler$MusicState -> a
com.shdwfghtr.explore.MusicHandler$MusicState -> com.shdwfghtr.explore.g$b:
    com.shdwfghtr.explore.MusicHandler$MusicState EJECTED -> a
    com.shdwfghtr.explore.MusicHandler$MusicState PAUSED -> b
    com.shdwfghtr.explore.MusicHandler$MusicState FADEIN -> c
    com.shdwfghtr.explore.MusicHandler$MusicState[] $VALUES -> h
    com.shdwfghtr.explore.MusicHandler$MusicState FADEOUT -> d
    com.shdwfghtr.explore.MusicHandler$MusicState PLAYING -> e
    com.shdwfghtr.explore.MusicHandler$MusicState STOPPED -> f
    com.shdwfghtr.explore.MusicHandler$MusicState LOOPING -> g
com.shdwfghtr.explore.Perlin -> com.shdwfghtr.explore.h:
    float[] grid -> a
    float getFloat(float) -> a
    float getFloat(float,float,float) -> a
    float getFloat(int,float) -> a
    float cerp(float,float,float) -> b
com.shdwfghtr.explore.Sector -> com.shdwfghtr.explore.i:
    char[][] charMap -> c
    boolean LEFT -> i
    boolean explored -> e
    boolean UP -> f
    float y -> b
    boolean DOWN -> g
    float x -> a
    boolean RIGHT -> h
    java.lang.String name -> d
    void addTiles(java.lang.String,boolean,boolean) -> a
    com.badlogic.gdx.math.Rectangle getBox() -> a
    char getChar(float,float) -> a
    char getChar(int,int) -> a
    void setChar(char,int,int) -> a
    void setExplored(boolean) -> a
    java.lang.String getName() -> b
    float getRight() -> c
    java.lang.String getSaveString() -> d
    float getTop() -> e
    float getX() -> f
    int getXi() -> g
    float getY() -> h
    int getYi() -> i
    boolean isExplored() -> j
    void setOpenness() -> k
com.shdwfghtr.explore.Tile -> com.shdwfghtr.explore.j:
    boolean isBreakable(char) -> a
    boolean isDisruptable(char) -> b
    boolean isIndexed(char) -> c
    boolean isRotational(char) -> d
    boolean isSolid(char) -> e
    boolean isVisible(char) -> f
com.shdwfghtr.explore.Timer -> com.shdwfghtr.explore.k:
    float duration -> b
    float start -> a
    void reset() -> a
    void reset(float) -> a
    boolean isComplete() -> b
    boolean onCompletion() -> c
    boolean update() -> d
com.shdwfghtr.explore.World -> com.shdwfghtr.explore.l:
    com.shdwfghtr.explore.World CURRENT -> q
    com.shdwfghtr.explore.Sector[][] sectorMap -> e
    com.badlogic.gdx.graphics.g2d.TextureAtlas sectorAtlas -> j
    int index -> l
    com.badlogic.gdx.graphics.Color[] palette -> i
    com.badlogic.gdx.utils.Array activeEntities -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas entityAtlas -> g
    java.lang.String name -> k
    java.util.HashMap tileRegions -> f
    com.badlogic.gdx.utils.Pool BREAK_TIMER_POOL -> o
    com.badlogic.gdx.utils.Pool DISRUPT_TIMER_POOL -> p
    com.badlogic.gdx.utils.Array spawners -> d
    com.shdwfghtr.explore.World$EntityUpdateThread entityThread -> h
    com.badlogic.gdx.utils.Array viewInterests -> c
    com.badlogic.gdx.utils.Array inactiveEntities -> b
    float atmosphere -> n
    float gravity -> m
    com.shdwfghtr.entity.Entity[] access$500(com.shdwfghtr.explore.World) -> a
    void access$700(com.shdwfghtr.explore.World,com.shdwfghtr.entity.Entity,boolean) -> a
    void addEntity(com.shdwfghtr.entity.Entity) -> a
    void addSpawner(com.shdwfghtr.entity.Spawner) -> a
    void breakTile(float,float) -> a
    void createEntities() -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void drawBackgroundTexture(com.badlogic.gdx.graphics.g2d.Batch,java.lang.String,com.badlogic.gdx.graphics.Color,float,float) -> a
    com.shdwfghtr.explore.Sector getSector(int,int) -> a
    com.shdwfghtr.explore.Sector getSector(com.badlogic.gdx.math.Vector2) -> a
    java.lang.String getType(int) -> a
    void recolorAtlasByRegion(com.badlogic.gdx.graphics.Color[],com.badlogic.gdx.graphics.Color[],com.badlogic.gdx.graphics.g2d.TextureAtlas,java.lang.String[]) -> a
    void setActive(com.shdwfghtr.entity.Entity,boolean) -> a
    void setChar(char,float,float) -> a
    void setName(java.lang.String) -> a
    void setSector(com.shdwfghtr.explore.Sector) -> a
    void setSector(java.lang.String,int,int,boolean,boolean) -> a
    void update(float) -> a
    com.shdwfghtr.entity.Spawner[] access$600(com.shdwfghtr.explore.World) -> b
    void dispose() -> b
    void disruptTile(float,float) -> b
    void drawEntities(com.badlogic.gdx.graphics.g2d.Batch) -> b
    com.badlogic.gdx.graphics.Color[] generatePalette(float) -> b
    char getChar(int,int) -> b
    void removeEntity(com.shdwfghtr.entity.Entity) -> b
    void drawTiles(com.badlogic.gdx.graphics.g2d.Batch) -> c
    com.badlogic.gdx.graphics.g2d.TextureAtlas generateSectorAtlas(com.shdwfghtr.explore.World) -> c
    void generateTileRegions() -> c
    char getChar(float,float) -> c
    float getTileRotation(int,int) -> c
    int getTileX(float) -> c
    com.shdwfghtr.entity.Entity[] getActiveEntities() -> d
    com.shdwfghtr.explore.Sector getSector(float,float) -> d
    int getTileY(float) -> d
    float getGravity() -> e
    boolean isBlocked(float,float) -> e
    int getHeight() -> f
    boolean isSlick(float,float) -> f
    com.shdwfghtr.entity.Entity[] getInterests() -> g
    com.badlogic.gdx.math.Rectangle getTileBox(float,float) -> g
    java.lang.String getName() -> h
    int getWidth() -> i
    com.badlogic.gdx.utils.Pool access$300() -> j
    com.badlogic.gdx.utils.Pool access$400() -> k
    com.shdwfghtr.entity.Entity[] getInactiveEntities() -> l
    com.shdwfghtr.entity.Spawner[] getSpawners() -> m
com.shdwfghtr.explore.World$1 -> com.shdwfghtr.explore.l$a:
    com.shdwfghtr.explore.World$RestoreTimer newObject() -> a
    java.lang.Object newObject() -> a
com.shdwfghtr.explore.World$2 -> com.shdwfghtr.explore.l$b:
    com.shdwfghtr.explore.World$DisruptTimer newObject() -> a
    java.lang.Object newObject() -> a
com.shdwfghtr.explore.World$3 -> com.shdwfghtr.explore.l$c:
    com.shdwfghtr.explore.Sector val$sector -> L
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
com.shdwfghtr.explore.World$4 -> com.shdwfghtr.explore.l$d:
    com.shdwfghtr.explore.Sector val$sector -> L
    void collideWith(com.shdwfghtr.entity.Entity) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
com.shdwfghtr.explore.World$5 -> com.shdwfghtr.explore.l$e:
    com.shdwfghtr.entity.Door val$door -> L
    void trigger() -> K
com.shdwfghtr.explore.World$6 -> com.shdwfghtr.explore.l$f:
    int[] $SwitchMap$com$shdwfghtr$entity$Entity$DrawLayer -> a
com.shdwfghtr.explore.World$DisruptTimer -> com.shdwfghtr.explore.l$g:
    char t -> d
    com.badlogic.gdx.math.Rectangle box -> c
    boolean onCompletion() -> c
com.shdwfghtr.explore.World$EntityUpdateThread -> com.shdwfghtr.explore.l$h:
    float delta -> a
    com.shdwfghtr.explore.World this$0 -> b
com.shdwfghtr.explore.World$EntityUpdateThread$1 -> com.shdwfghtr.explore.l$h$a:
    com.badlogic.gdx.utils.Array val$dead -> a
    com.badlogic.gdx.utils.Array val$deactivate -> c
    com.badlogic.gdx.utils.Array val$activate -> b
    com.shdwfghtr.explore.World$EntityUpdateThread this$1 -> d
com.shdwfghtr.explore.World$RestoreTimer -> com.shdwfghtr.explore.l$i:
    char t -> d
    com.badlogic.gdx.math.Rectangle box -> c
    boolean onCompletion() -> c
com.shdwfghtr.explore.WorldLoader -> com.shdwfghtr.explore.m:
    float progress -> l
    java.util.HashMap VARIATIONS -> n
    int y2 -> j
    com.shdwfghtr.explore.World world -> m
    int sectorCount -> k
    int x2 -> h
    int y1 -> i
    int maxSectors -> f
    long seed -> a
    int x1 -> g
    int height -> d
    char[][] charMap -> b
    int area -> e
    int width -> c
    int[][] noise -> o
    void createHall(int,int,int) -> a
    com.shdwfghtr.explore.Sector generateSector(int,int,int,int,boolean,com.shdwfghtr.explore.WorldLoader$Algorithm) -> a
    java.lang.String generateSectorName(int,int) -> a
    int getNumberOfMapVariations(java.lang.String) -> a
    float getProgress() -> a
    int[][] smoothNoise(int[][],int) -> a
    void createShaft(int,int,int) -> b
    void generateCharacterMap() -> b
    char getChar(int,int) -> b
    void generateSectors() -> c
com.shdwfghtr.explore.WorldLoader$1 -> com.shdwfghtr.explore.m$a:
    int[] $SwitchMap$com$shdwfghtr$explore$WorldLoader$Algorithm -> a
com.shdwfghtr.explore.WorldLoader$Algorithm -> com.shdwfghtr.explore.m$b:
    com.shdwfghtr.explore.WorldLoader$Algorithm RANDOM -> a
    com.shdwfghtr.explore.WorldLoader$Algorithm SYMMETRIC -> b
    com.shdwfghtr.explore.WorldLoader$Algorithm TUNNEL -> c
    com.shdwfghtr.explore.WorldLoader$Algorithm[] $VALUES -> d
com.shdwfghtr.input.GamepadHandler -> b.d.b.a:
    com.badlogic.gdx.controllers.Controller GAMEPAD -> d
    void act(float) -> a
    boolean axisMoved(com.badlogic.gdx.controllers.Controller,int,float) -> a
    boolean buttonDown(com.badlogic.gdx.controllers.Controller,int) -> a
    void connected(com.badlogic.gdx.controllers.Controller) -> a
    boolean isInputDown(java.lang.String) -> a
    void toStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    boolean buttonUp(com.badlogic.gdx.controllers.Controller,int) -> b
    void disconnected(com.badlogic.gdx.controllers.Controller) -> b
com.shdwfghtr.input.InputHandler -> b.d.b.b:
    com.shdwfghtr.entity.Player player -> b
    com.shdwfghtr.screens.GameScreen gameScreen -> c
    void act(float) -> a
    com.shdwfghtr.entity.Player getPlayer() -> a
    boolean isInputDown(java.lang.String) -> a
    void setGameScreen(com.shdwfghtr.screens.GameScreen) -> a
    void setPlayer(com.shdwfghtr.entity.Player) -> a
    void toStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    boolean inputDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> c
    boolean inputUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> d
com.shdwfghtr.input.InputHandler$1 -> b.d.b.b$a:
    void result(java.lang.Object) -> a
com.shdwfghtr.input.InputHandler$1$1 -> b.d.b.b$a$a:
    boolean onCompletion() -> c
com.shdwfghtr.input.KeyboardHandler -> b.d.b.c:
    boolean isInputDown(java.lang.String) -> a
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> b
com.shdwfghtr.input.TouchHandler -> b.d.b.d:
    java.util.HashMap pointers -> d
    com.badlogic.gdx.scenes.scene2d.ui.Button CIRCLE_LEFT -> l
    com.badlogic.gdx.scenes.scene2d.ui.Button CIRCLE_RIGHT -> k
    com.badlogic.gdx.scenes.scene2d.ui.Button CIRCLE_DOWN -> j
    com.badlogic.gdx.scenes.scene2d.ui.Button ARROW_DOWN -> i
    com.badlogic.gdx.utils.Array BUTTONS -> q
    com.badlogic.gdx.scenes.scene2d.ui.Button BAR_LEFT -> o
    com.badlogic.gdx.scenes.scene2d.ui.Button BAR_RIGHT -> n
    com.badlogic.gdx.scenes.scene2d.ui.Button CIRCLE_UP -> m
    com.badlogic.gdx.scenes.scene2d.ui.Button ARROW_LEFT -> h
    com.badlogic.gdx.scenes.scene2d.ui.Touchpad TOUCHPAD -> p
    com.badlogic.gdx.scenes.scene2d.ui.Button ARROW_UP -> g
    com.badlogic.gdx.scenes.scene2d.ui.Table table -> e
    com.badlogic.gdx.scenes.scene2d.ui.Button ARROW_RIGHT -> f
    boolean isInputDown(java.lang.String) -> a
    void toStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Touchpad access$000() -> b
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
com.shdwfghtr.input.TouchHandler$1 -> b.d.b.d$a:
    com.shdwfghtr.input.TouchHandler this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.ControlsMenu -> b.d.c.a:
    com.badlogic.gdx.controllers.ControllerAdapter adapter -> q
    com.badlogic.gdx.scenes.scene2d.ui.CheckBox checkBox -> n
    java.util.HashMap inputButtons -> h
    com.badlogic.gdx.utils.Array touchSliders -> j
    com.badlogic.gdx.scenes.scene2d.ui.Dialog inputDialog -> l
    java.lang.String inputKey -> m
    com.badlogic.gdx.scenes.scene2d.ui.Cell touchCell -> o
    com.badlogic.gdx.scenes.scene2d.ui.Cell dPadCell -> p
    com.badlogic.gdx.scenes.scene2d.ui.Touchpad touchPad -> k
    com.badlogic.gdx.scenes.scene2d.ui.Table touchTable -> f
    com.badlogic.gdx.utils.Array touchButtons -> i
    com.badlogic.gdx.scenes.scene2d.ui.Table dPadTable -> g
    boolean access$000(com.shdwfghtr.screens.ControlsMenu,int) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Touchpad access$100(com.shdwfghtr.screens.ControlsMenu) -> a
    java.lang.String access$802(com.shdwfghtr.screens.ControlsMenu,java.lang.String) -> a
    void createDPadTouchTable(float,float,float,float) -> a
    void render(float) -> a
    boolean replaceInput(int) -> a
    void resize(int,int) -> a
    void show() -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell access$200(com.shdwfghtr.screens.ControlsMenu) -> b
    void pause() -> b
    com.badlogic.gdx.scenes.scene2d.ui.Table access$300(com.shdwfghtr.screens.ControlsMenu) -> c
    void resume() -> c
    com.badlogic.gdx.scenes.scene2d.ui.Table access$400(com.shdwfghtr.screens.ControlsMenu) -> d
    void hide() -> d
    com.badlogic.gdx.utils.Array access$500(com.shdwfghtr.screens.ControlsMenu) -> e
    void dispose() -> e
    com.badlogic.gdx.scenes.scene2d.ui.Dialog access$600(com.shdwfghtr.screens.ControlsMenu) -> f
    void goToPreviousScreen() -> f
    com.badlogic.gdx.scenes.scene2d.ui.Cell access$700(com.shdwfghtr.screens.ControlsMenu) -> g
    java.lang.String access$800(com.shdwfghtr.screens.ControlsMenu) -> h
    com.badlogic.gdx.controllers.ControllerAdapter access$900(com.shdwfghtr.screens.ControlsMenu) -> i
com.shdwfghtr.screens.ControlsMenu$1 -> b.d.c.a$b:
    com.shdwfghtr.screens.ControlsMenu this$0 -> a
    boolean axisMoved(com.badlogic.gdx.controllers.Controller,int,float) -> a
    boolean buttonDown(com.badlogic.gdx.controllers.Controller,int) -> a
com.shdwfghtr.screens.ControlsMenu$10 -> b.d.c.a$a:
    com.badlogic.gdx.scenes.scene2d.ui.TextButton val$button -> o
    com.shdwfghtr.screens.ControlsMenu this$0 -> q
    java.lang.String val$key -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.shdwfghtr.screens.ControlsMenu$10$1 -> b.d.c.a$a$a:
    com.shdwfghtr.screens.ControlsMenu$10 this$1 -> b
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
com.shdwfghtr.screens.ControlsMenu$2 -> b.d.c.a$c:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox val$selectBox -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.ControlsMenu$3 -> b.d.c.a$d:
    com.shdwfghtr.screens.ControlsMenu this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.ControlsMenu$4 -> b.d.c.a$e:
    com.badlogic.gdx.scenes.scene2d.ui.Slider val$sensitivitySlider -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.ControlsMenu$5 -> b.d.c.a$f:
    com.badlogic.gdx.utils.Array cells -> a
    com.shdwfghtr.screens.ControlsMenu this$0 -> c
    com.badlogic.gdx.scenes.scene2d.ui.Slider val$paddingSlider -> b
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.ControlsMenu$6 -> b.d.c.a$g:
    com.badlogic.gdx.utils.Array cells -> a
    com.shdwfghtr.screens.ControlsMenu this$0 -> c
    com.badlogic.gdx.scenes.scene2d.ui.Slider val$sizeSlider -> b
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.ControlsMenu$7 -> b.d.c.a$h:
    com.shdwfghtr.screens.ControlsMenu this$0 -> b
    com.badlogic.gdx.scenes.scene2d.ui.Slider val$borderSlider -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.ControlsMenu$8 -> b.d.c.a$i:
    com.shdwfghtr.screens.ControlsMenu this$0 -> b
    com.badlogic.gdx.scenes.scene2d.ui.Slider val$positionSlider -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.ControlsMenu$9 -> b.d.c.a$j:
    com.shdwfghtr.screens.ControlsMenu this$0 -> b
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
com.shdwfghtr.screens.GameOverScreen -> b.d.c.b:
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> a
    void pause() -> b
    void resume() -> c
    void hide() -> d
    void dispose() -> e
com.shdwfghtr.screens.GameScreen -> b.d.c.c:
    com.shdwfghtr.input.InputHandler input -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion msgBox -> b
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> c
    com.shdwfghtr.explore.World world -> i
    com.badlogic.gdx.utils.Array items -> d
    com.shdwfghtr.explore.GameState state -> g
    com.badlogic.gdx.scenes.scene2d.ui.Table hudTable -> f
    com.badlogic.gdx.scenes.scene2d.ui.Table menu -> e
    com.badlogic.gdx.scenes.scene2d.ui.Image[][] mapImages -> h
    com.badlogic.gdx.scenes.scene2d.ui.Table access$000(com.shdwfghtr.screens.GameScreen) -> a
    void addItemActor(java.lang.String) -> a
    void render(float) -> a
    void resize(int,int) -> a
    void setMapImage(java.lang.String,int,int) -> a
    void setState(com.shdwfghtr.explore.GameState) -> a
    void show() -> a
    void pause() -> b
    void resume() -> c
    void hide() -> d
    void dispose() -> e
    com.shdwfghtr.explore.GameState getState() -> f
    void createHUD() -> g
    void createPauseMenu() -> h
com.shdwfghtr.screens.GameScreen$1 -> b.d.c.c$e:
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
com.shdwfghtr.screens.GameScreen$10 -> b.d.c.c$a:
    com.shdwfghtr.screens.GameScreen this$0 -> b
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
com.shdwfghtr.screens.GameScreen$11 -> b.d.c.c$b:
    java.lang.String val$key -> t
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
com.shdwfghtr.screens.GameScreen$12 -> b.d.c.c$c:
    java.lang.String val$key -> o
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
com.shdwfghtr.screens.GameScreen$13 -> b.d.c.c$d:
    com.shdwfghtr.screens.GameScreen this$0 -> c
    boolean onCompletion() -> c
com.shdwfghtr.screens.GameScreen$2 -> b.d.c.c$f:
    void act(float) -> a
com.shdwfghtr.screens.GameScreen$3 -> b.d.c.c$g:
    int nTanks -> s0
    com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable full -> t0
    com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable empty -> u0
    void act(float) -> a
com.shdwfghtr.screens.GameScreen$4 -> b.d.c.c$h:
    void act(float) -> a
com.shdwfghtr.screens.GameScreen$5 -> b.d.c.c$i:
    int nArmor -> s0
    com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable armor -> t0
    void act(float) -> a
com.shdwfghtr.screens.GameScreen$6 -> b.d.c.c$j:
    com.shdwfghtr.explore.Timer msgTimer -> s0
    void act(float) -> a
com.shdwfghtr.screens.GameScreen$6$1 -> b.d.c.c$j$a:
    com.shdwfghtr.screens.GameScreen$6 this$1 -> c
    boolean onCompletion() -> c
com.shdwfghtr.screens.GameScreen$7 -> b.d.c.c$k:
    com.shdwfghtr.screens.GameScreen this$0 -> s0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
com.shdwfghtr.screens.GameScreen$8 -> b.d.c.c$l:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
com.shdwfghtr.screens.GameScreen$9 -> b.d.c.c$m:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
com.shdwfghtr.screens.Menu -> b.d.c.d:
    com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect STARS -> b
    boolean backButtonPressed -> e
    com.badlogic.gdx.graphics.g2d.SpriteBatch BATCH -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table table -> c
    java.lang.String headerText -> d
    void goToScreen(com.badlogic.gdx.Screen) -> a
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> a
    void pause() -> b
    void resume() -> c
    void hide() -> d
    void dispose() -> e
    void goToPreviousScreen() -> f
com.shdwfghtr.screens.Menu$1 -> b.d.c.d$a:
    com.shdwfghtr.screens.Menu this$0 -> b
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> b
com.shdwfghtr.screens.Menu$2 -> b.d.c.d$b:
    com.shdwfghtr.screens.Menu this$0 -> t
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
com.shdwfghtr.screens.OptionsMenu -> b.d.c.e:
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> a
    void pause() -> b
    void resume() -> c
    void hide() -> d
    void dispose() -> e
    void goToPreviousScreen() -> f
com.shdwfghtr.screens.OptionsMenu$1 -> b.d.c.e$a:
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.OptionsMenu$2 -> b.d.c.e$b:
    com.badlogic.gdx.scenes.scene2d.ui.CheckBox val$checkFullscreen -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.OptionsMenu$3 -> b.d.c.e$c:
    void act(float) -> a
com.shdwfghtr.screens.OptionsMenu$4 -> b.d.c.e$d:
    com.badlogic.gdx.scenes.scene2d.ui.TextField val$fieldSeed -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.OptionsMenu$5 -> b.d.c.e$e:
    com.shdwfghtr.screens.OptionsMenu this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.OptionsMenu$6 -> b.d.c.e$f:
    com.shdwfghtr.screens.OptionsMenu this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.OptionsMenu$7 -> b.d.c.e$g:
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.Splash -> b.d.c.f:
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> c
    int numDots -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> b
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> a
    void pause() -> b
    void resume() -> c
    void hide() -> d
    void dispose() -> e
com.shdwfghtr.screens.TravelScreen -> b.d.c.g:
    java.util.Random RANDOM -> j
    com.shdwfghtr.explore.WorldLoader loading -> i
    com.badlogic.gdx.scenes.scene2d.ui.Table menu -> f
    com.badlogic.gdx.utils.Array items -> g
    com.shdwfghtr.explore.WorldLoader[] loaders -> h
    com.shdwfghtr.explore.WorldLoader access$000(com.shdwfghtr.screens.TravelScreen) -> a
    com.shdwfghtr.explore.WorldLoader access$002(com.shdwfghtr.screens.TravelScreen,com.shdwfghtr.explore.WorldLoader) -> a
    void addItemActor(java.lang.String) -> a
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> a
    com.badlogic.gdx.graphics.g2d.Animation access$100(com.shdwfghtr.screens.TravelScreen) -> b
    void pause() -> b
    com.shdwfghtr.explore.WorldLoader[] access$200(com.shdwfghtr.screens.TravelScreen) -> c
    void resume() -> c
    com.badlogic.gdx.scenes.scene2d.ui.Table access$300(com.shdwfghtr.screens.TravelScreen) -> d
    void hide() -> d
    com.badlogic.gdx.utils.Array access$400(com.shdwfghtr.screens.TravelScreen) -> e
    void dispose() -> e
    void goToPreviousScreen() -> f
    void createButtons() -> g
    void createPauseMenu() -> h
    void createStarSystem() -> i
    com.badlogic.gdx.graphics.g2d.Animation getStarAnimation() -> j
com.shdwfghtr.screens.TravelScreen$1 -> b.d.c.g$f:
    boolean onCompletion() -> c
com.shdwfghtr.screens.TravelScreen$10 -> b.d.c.g$a:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
com.shdwfghtr.screens.TravelScreen$11 -> b.d.c.g$b:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
com.shdwfghtr.screens.TravelScreen$12 -> b.d.c.g$c:
    java.lang.String val$key -> t
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
com.shdwfghtr.screens.TravelScreen$13 -> b.d.c.g$d:
    java.lang.String val$key -> o
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
com.shdwfghtr.screens.TravelScreen$14 -> b.d.c.g$e:
    void result(java.lang.Object) -> a
com.shdwfghtr.screens.TravelScreen$2 -> b.d.c.g$g:
    float val$s -> E
    int val$r -> D
    com.shdwfghtr.screens.TravelScreen this$0 -> G
    double val$a -> F
    void act(float) -> a
com.shdwfghtr.screens.TravelScreen$3 -> b.d.c.g$h:
    com.shdwfghtr.explore.WorldLoader val$loader -> p
    com.shdwfghtr.screens.TravelScreen this$0 -> q
    com.badlogic.gdx.scenes.scene2d.ui.Image val$planet -> o
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.shdwfghtr.screens.TravelScreen$3$1 -> b.d.c.g$h$a:
    com.shdwfghtr.screens.TravelScreen$3 this$1 -> O0
    void result(java.lang.Object) -> a
com.shdwfghtr.screens.TravelScreen$4 -> b.d.c.g$i:
    com.badlogic.gdx.graphics.g2d.Animation animation -> t
    com.shdwfghtr.screens.TravelScreen this$0 -> u
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
com.shdwfghtr.screens.TravelScreen$5 -> b.d.c.g$j:
    com.shdwfghtr.screens.TravelScreen this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.TravelScreen$5$1 -> b.d.c.g$j$a:
    com.shdwfghtr.screens.TravelScreen$5 this$1 -> c
    boolean onCompletion() -> c
com.shdwfghtr.screens.TravelScreen$6 -> b.d.c.g$k:
    com.shdwfghtr.screens.TravelScreen this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.TravelScreen$7 -> b.d.c.g$l:
    com.shdwfghtr.screens.TravelScreen this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.shdwfghtr.screens.TravelScreen$8 -> b.d.c.g$m:
    com.badlogic.gdx.scenes.scene2d.ui.ImageButton val$buttonStats -> b
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
com.shdwfghtr.screens.TravelScreen$9 -> b.d.c.g$n:
    java.lang.String val$name -> o
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.shdwfghtr.screens.TravelScreen$PlanetComparator -> b.d.c.g$o:
    int compare(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> a
